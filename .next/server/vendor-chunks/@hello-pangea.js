"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === 'production';\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = value => value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\nconst getDevMessage = message => clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %c👷‍ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = message => [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];\nconst isDisabledFlag = '__@hello-pangea/dnd-disable-dev-warnings';\nfunction log(type, message) {\n  if (isProduction$1) {\n    return;\n  }\n  if (typeof window !== 'undefined' && window[isDisabledFlag]) {\n    return;\n  }\n  console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, 'warn');\nconst error = log.bind(null, 'error');\n\nfunction noop$2() {}\n\nfunction getOptions(shared, fromBinding) {\n  return {\n    ...shared,\n    ...fromBinding\n  };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n  const unbindings = bindings.map(binding => {\n    const options = getOptions(sharedOptions, binding.options);\n    el.addEventListener(binding.eventName, binding.fn, options);\n    return function unbind() {\n      el.removeEventListener(binding.eventName, binding.fn, options);\n    };\n  });\n  return function unbindAll() {\n    unbindings.forEach(unbind => {\n      unbind();\n    });\n  };\n}\n\nconst isProduction = \"development\" === 'production';\nconst prefix$1 = 'Invariant failed';\nclass RbdInvariant extends Error {}\nRbdInvariant.prototype.toString = function toString() {\n  return this.message;\n};\nfunction invariant(condition, message) {\n  if (isProduction) {\n    throw new RbdInvariant(prefix$1);\n  } else {\n    throw new RbdInvariant(`${prefix$1}: ${message || ''}`);\n  }\n}\n\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n  constructor(...args) {\n    super(...args);\n    this.callbacks = null;\n    this.unbind = noop$2;\n    this.onWindowError = event => {\n      const callbacks = this.getCallbacks();\n      if (callbacks.isDragging()) {\n        callbacks.tryAbort();\n         true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n      }\n      const err = event.error;\n      if (err instanceof RbdInvariant) {\n        event.preventDefault();\n        if (true) {\n          error(err.message);\n        }\n      }\n    };\n    this.getCallbacks = () => {\n      if (!this.callbacks) {\n        throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');\n      }\n      return this.callbacks;\n    };\n    this.setCallbacks = callbacks => {\n      this.callbacks = callbacks;\n    };\n  }\n  componentDidMount() {\n    this.unbind = bindEvents(window, [{\n      eventName: 'error',\n      fn: this.onWindowError\n    }]);\n  }\n  componentDidCatch(err) {\n    if (err instanceof RbdInvariant) {\n      if (true) {\n        error(err.message);\n      }\n      this.setState({});\n      return;\n    }\n    throw err;\n  }\n  componentWillUnmount() {\n    this.unbind();\n  }\n  render() {\n    return this.props.children(this.setCallbacks);\n  }\n}\n\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = index => index + 1;\nconst onDragStart = start => `\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination) => {\n  const isInHomeList = source.droppableId === destination.droppableId;\n  const startPosition = position(source.index);\n  const endPosition = position(destination.index);\n  if (isInHomeList) {\n    return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n  }\n  return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine) => {\n  const inHomeList = source.droppableId === combine.droppableId;\n  if (inHomeList) {\n    return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n  }\n  return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = update => {\n  const location = update.destination;\n  if (location) {\n    return withLocation(update.source, location);\n  }\n  const combine = update.combine;\n  if (combine) {\n    return withCombine(update.draggableId, update.source, combine);\n  }\n  return 'You are over an area that cannot be dropped on';\n};\nconst returnedToStart = source => `\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = result => {\n  if (result.reason === 'CANCEL') {\n    return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n  }\n  const location = result.destination;\n  const combine = result.combine;\n  if (location) {\n    return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n  }\n  if (combine) {\n    return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n  }\n  return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n  dragHandleUsageInstructions,\n  onDragStart,\n  onDragUpdate,\n  onDragEnd\n};\n\nfunction isEqual$2(first, second) {\n  if (first === second) {\n    return true;\n  }\n  if (Number.isNaN(first) && Number.isNaN(second)) {\n    return true;\n  }\n  return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (let i = 0; i < newInputs.length; i++) {\n    if (!isEqual$2(newInputs[i], lastInputs[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction useMemo(getResult, inputs) {\n  const initial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({\n    inputs,\n    result: getResult()\n  }))[0];\n  const isFirstRun = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  const committed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initial);\n  const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));\n  const cache = useCache ? committed.current : {\n    inputs,\n    result: getResult()\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    isFirstRun.current = false;\n    committed.current = cache;\n  }, [cache]);\n  return cache.result;\n}\nfunction useCallback(callback, inputs) {\n  return useMemo(() => callback, inputs);\n}\n\nconst origin = {\n  x: 0,\n  y: 0\n};\nconst add = (point1, point2) => ({\n  x: point1.x + point2.x,\n  y: point1.y + point2.y\n});\nconst subtract = (point1, point2) => ({\n  x: point1.x - point2.x,\n  y: point1.y - point2.y\n});\nconst isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;\nconst negate = point => ({\n  x: point.x !== 0 ? -point.x : 0,\n  y: point.y !== 0 ? -point.y : 0\n});\nconst patch = (line, value, otherValue = 0) => {\n  if (line === 'x') {\n    return {\n      x: value,\n      y: otherValue\n    };\n  }\n  return {\n    x: otherValue,\n    y: value\n  };\n};\nconst distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points) => Math.min(...points.map(point => distance(target, point)));\nconst apply = fn => point => ({\n  x: fn(point.x),\n  y: fn(point.y)\n});\n\nvar executeClip = (frame, subject) => {\n  const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top: Math.max(subject.top, frame.top),\n    right: Math.min(subject.right, frame.right),\n    bottom: Math.min(subject.bottom, frame.bottom),\n    left: Math.max(subject.left, frame.left)\n  });\n  if (result.width <= 0 || result.height <= 0) {\n    return null;\n  }\n  return result;\n};\n\nconst offsetByPosition = (spacing, point) => ({\n  top: spacing.top + point.y,\n  left: spacing.left + point.x,\n  bottom: spacing.bottom + point.y,\n  right: spacing.right + point.x\n});\nconst getCorners = spacing => [{\n  x: spacing.left,\n  y: spacing.top\n}, {\n  x: spacing.right,\n  y: spacing.top\n}, {\n  x: spacing.left,\n  y: spacing.bottom\n}, {\n  x: spacing.right,\n  y: spacing.bottom\n}];\nconst noSpacing = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\n\nconst scroll$1 = (target, frame) => {\n  if (!frame) {\n    return target;\n  }\n  return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder) => {\n  if (withPlaceholder && withPlaceholder.increasedBy) {\n    return {\n      ...target,\n      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n    };\n  }\n  return target;\n};\nconst clip = (target, frame) => {\n  if (frame && frame.shouldClipSubject) {\n    return executeClip(frame.pageMarginBox, target);\n  }\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(target);\n};\nvar getSubject = ({\n  page,\n  withPlaceholder,\n  axis,\n  frame\n}) => {\n  const scrolled = scroll$1(page.marginBox, frame);\n  const increased = increase(scrolled, axis, withPlaceholder);\n  const clipped = clip(increased, frame);\n  return {\n    page,\n    withPlaceholder,\n    active: clipped\n  };\n};\n\nvar scrollDroppable = (droppable, newScroll) => {\n  !droppable.frame ?  true ? invariant() : 0 : void 0;\n  const scrollable = droppable.frame;\n  const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n  const scrollDisplacement = negate(scrollDiff);\n  const frame = {\n    ...scrollable,\n    scroll: {\n      initial: scrollable.scroll.initial,\n      current: newScroll,\n      diff: {\n        value: scrollDiff,\n        displacement: scrollDisplacement\n      },\n      max: scrollable.scroll.max\n    }\n  };\n  const subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: droppable.subject.withPlaceholder,\n    axis: droppable.axis,\n    frame\n  });\n  const result = {\n    ...droppable,\n    frame,\n    subject\n  };\n  return result;\n};\n\nfunction memoizeOne(resultFn, isEqual = areInputsEqual) {\n  let cache = null;\n  function memoized(...newArgs) {\n    if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n      return cache.lastResult;\n    }\n    const lastResult = resultFn.apply(this, newArgs);\n    cache = {\n      lastResult,\n      lastArgs: newArgs,\n      lastThis: this\n    };\n    return lastResult;\n  }\n  memoized.clear = function clear() {\n    cache = null;\n  };\n  return memoized;\n}\n\nconst toDroppableMap = memoizeOne(droppables => droppables.reduce((previous, current) => {\n  previous[current.descriptor.id] = current;\n  return previous;\n}, {}));\nconst toDraggableMap = memoizeOne(draggables => draggables.reduce((previous, current) => {\n  previous[current.descriptor.id] = current;\n  return previous;\n}, {}));\nconst toDroppableList = memoizeOne(droppables => Object.values(droppables));\nconst toDraggableList = memoizeOne(draggables => Object.values(draggables));\n\nvar getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {\n  const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId).sort((a, b) => a.descriptor.index - b.descriptor.index);\n  return result;\n});\n\nfunction tryGetDestination(impact) {\n  if (impact.at && impact.at.type === 'REORDER') {\n    return impact.at.destination;\n  }\n  return null;\n}\nfunction tryGetCombine(impact) {\n  if (impact.at && impact.at.type === 'COMBINE') {\n    return impact.at.combine;\n  }\n  return null;\n}\n\nvar removeDraggableFromList = memoizeOne((remove, list) => list.filter(item => item.descriptor.id !== remove.descriptor.id));\n\nvar moveToNextCombine = ({\n  isMovingForward,\n  draggable,\n  destination,\n  insideDestination,\n  previousImpact\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const location = tryGetDestination(previousImpact);\n  if (!location) {\n    return null;\n  }\n  function getImpact(target) {\n    const at = {\n      type: 'COMBINE',\n      combine: {\n        draggableId: target,\n        droppableId: destination.descriptor.id\n      }\n    };\n    return {\n      ...previousImpact,\n      at\n    };\n  }\n  const all = previousImpact.displaced.all;\n  const closestId = all.length ? all[0] : null;\n  if (isMovingForward) {\n    return closestId ? getImpact(closestId) : null;\n  }\n  const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n  if (!closestId) {\n    if (!withoutDraggable.length) {\n      return null;\n    }\n    const last = withoutDraggable[withoutDraggable.length - 1];\n    return getImpact(last.descriptor.id);\n  }\n  const indexOfClosest = withoutDraggable.findIndex(d => d.descriptor.id === closestId);\n  !(indexOfClosest !== -1) ?  true ? invariant(false, 'Could not find displaced item in set') : 0 : void 0;\n  const proposedIndex = indexOfClosest - 1;\n  if (proposedIndex < 0) {\n    return null;\n  }\n  const before = withoutDraggable[proposedIndex];\n  return getImpact(before.descriptor.id);\n};\n\nvar isHomeOf = (draggable, destination) => draggable.descriptor.droppableId === destination.descriptor.id;\n\nconst noDisplacedBy = {\n  point: origin,\n  value: 0\n};\nconst emptyGroups = {\n  invisible: {},\n  visible: {},\n  all: []\n};\nconst noImpact = {\n  displaced: emptyGroups,\n  displacedBy: noDisplacedBy,\n  at: null\n};\n\nvar isWithin = (lowerBound, upperBound) => value => lowerBound <= value && value <= upperBound;\n\nvar isPartiallyVisibleThroughFrame = frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    if (isContained) {\n      return true;\n    }\n    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n    if (isPartiallyContained) {\n      return true;\n    }\n    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n    const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n    if (isTargetBiggerThanFrame) {\n      return true;\n    }\n    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n    return isTargetBiggerOnOneAxis;\n  };\n};\n\nvar isTotallyVisibleThroughFrame = frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n    return isContained;\n  };\n};\n\nconst vertical = {\n  direction: 'vertical',\n  line: 'y',\n  crossAxisLine: 'x',\n  start: 'top',\n  end: 'bottom',\n  size: 'height',\n  crossAxisStart: 'left',\n  crossAxisEnd: 'right',\n  crossAxisSize: 'width'\n};\nconst horizontal = {\n  direction: 'horizontal',\n  line: 'x',\n  crossAxisLine: 'y',\n  start: 'left',\n  end: 'right',\n  size: 'width',\n  crossAxisStart: 'top',\n  crossAxisEnd: 'bottom',\n  crossAxisSize: 'height'\n};\n\nvar isTotallyVisibleThroughFrameOnAxis = axis => frame => {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return subject => {\n    if (axis === vertical) {\n      return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n    }\n    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n  };\n};\n\nconst getDroppableDisplaced = (target, destination) => {\n  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n  return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {\n  if (!destination.subject.active) {\n    return false;\n  }\n  return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({\n  target: toBeDisplaced,\n  destination,\n  viewport,\n  withDroppableDisplacement,\n  isVisibleThroughFrameFn\n}) => {\n  const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n});\nconst isTotallyVisible = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n});\nconst isTotallyVisibleOnAxis = args => isVisible$1({\n  ...args,\n  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n});\n\nconst getShouldAnimate = (id, last, forceShouldAnimate) => {\n  if (typeof forceShouldAnimate === 'boolean') {\n    return forceShouldAnimate;\n  }\n  if (!last) {\n    return true;\n  }\n  const {\n    invisible,\n    visible\n  } = last;\n  if (invisible[id]) {\n    return false;\n  }\n  const previous = visible[id];\n  return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n  const marginBox = draggable.page.marginBox;\n  const expandBy = {\n    top: displacedBy.point.y,\n    right: 0,\n    bottom: 0,\n    left: displacedBy.point.x\n  };\n  return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({\n  afterDragging,\n  destination,\n  displacedBy,\n  viewport,\n  forceShouldAnimate,\n  last\n}) {\n  return afterDragging.reduce(function process(groups, draggable) {\n    const target = getTarget(draggable, displacedBy);\n    const id = draggable.descriptor.id;\n    groups.all.push(id);\n    const isVisible = isPartiallyVisible({\n      target,\n      destination,\n      viewport,\n      withDroppableDisplacement: true\n    });\n    if (!isVisible) {\n      groups.invisible[draggable.descriptor.id] = true;\n      return groups;\n    }\n    const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n    const displacement = {\n      draggableId: id,\n      shouldAnimate\n    };\n    groups.visible[id] = displacement;\n    return groups;\n  }, {\n    all: [],\n    visible: {},\n    invisible: {}\n  });\n}\n\nfunction getIndexOfLastItem(draggables, options) {\n  if (!draggables.length) {\n    return 0;\n  }\n  const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({\n  insideDestination,\n  inHomeList,\n  displacedBy,\n  destination\n}) {\n  const newIndex = getIndexOfLastItem(insideDestination, {\n    inHomeList\n  });\n  return {\n    displaced: emptyGroups,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index: newIndex\n      }\n    }\n  };\n}\nfunction calculateReorderImpact({\n  draggable,\n  insideDestination,\n  destination,\n  viewport,\n  displacedBy,\n  last,\n  index,\n  forceShouldAnimate\n}) {\n  const inHomeList = isHomeOf(draggable, destination);\n  if (index == null) {\n    return goAtEnd({\n      insideDestination,\n      inHomeList,\n      displacedBy,\n      destination\n    });\n  }\n  const match = insideDestination.find(item => item.descriptor.index === index);\n  if (!match) {\n    return goAtEnd({\n      insideDestination,\n      inHomeList,\n      displacedBy,\n      destination\n    });\n  }\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const sliceFrom = insideDestination.indexOf(match);\n  const impacted = withoutDragging.slice(sliceFrom);\n  const displaced = getDisplacementGroups({\n    afterDragging: impacted,\n    destination,\n    displacedBy,\n    last,\n    viewport: viewport.frame,\n    forceShouldAnimate\n  });\n  return {\n    displaced,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: {\n        droppableId: destination.descriptor.id,\n        index\n      }\n    }\n  };\n}\n\nfunction didStartAfterCritical(draggableId, afterCritical) {\n  return Boolean(afterCritical.effected[draggableId]);\n}\n\nvar fromCombine = ({\n  isMovingForward,\n  destination,\n  draggables,\n  combine,\n  afterCritical\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const combineId = combine.draggableId;\n  const combineWith = draggables[combineId];\n  const combineWithIndex = combineWith.descriptor.index;\n  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n  if (didCombineWithStartAfterCritical) {\n    if (isMovingForward) {\n      return combineWithIndex;\n    }\n    return combineWithIndex - 1;\n  }\n  if (isMovingForward) {\n    return combineWithIndex + 1;\n  }\n  return combineWithIndex;\n};\n\nvar fromReorder = ({\n  isMovingForward,\n  isInHomeList,\n  insideDestination,\n  location\n}) => {\n  if (!insideDestination.length) {\n    return null;\n  }\n  const currentIndex = location.index;\n  const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n  const firstIndex = insideDestination[0].descriptor.index;\n  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n  const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n  if (proposedIndex < firstIndex) {\n    return null;\n  }\n  if (proposedIndex > upperBound) {\n    return null;\n  }\n  return proposedIndex;\n};\n\nvar moveToNextIndex = ({\n  isMovingForward,\n  isInHomeList,\n  draggable,\n  draggables,\n  destination,\n  insideDestination,\n  previousImpact,\n  viewport,\n  afterCritical\n}) => {\n  const wasAt = previousImpact.at;\n  !wasAt ?  true ? invariant(false, 'Cannot move in direction without previous impact location') : 0 : void 0;\n  if (wasAt.type === 'REORDER') {\n    const newIndex = fromReorder({\n      isMovingForward,\n      isInHomeList,\n      location: wasAt.destination,\n      insideDestination\n    });\n    if (newIndex == null) {\n      return null;\n    }\n    return calculateReorderImpact({\n      draggable,\n      insideDestination,\n      destination,\n      viewport,\n      last: previousImpact.displaced,\n      displacedBy: previousImpact.displacedBy,\n      index: newIndex\n    });\n  }\n  const newIndex = fromCombine({\n    isMovingForward,\n    destination,\n    displaced: previousImpact.displaced,\n    draggables,\n    combine: wasAt.combine,\n    afterCritical\n  });\n  if (newIndex == null) {\n    return null;\n  }\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    last: previousImpact.displaced,\n    displacedBy: previousImpact.displacedBy,\n    index: newIndex\n  });\n};\n\nvar getCombinedItemDisplacement = ({\n  displaced,\n  afterCritical,\n  combineWith,\n  displacedBy\n}) => {\n  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n  if (didStartAfterCritical(combineWith, afterCritical)) {\n    return isDisplaced ? origin : negate(displacedBy.point);\n  }\n  return isDisplaced ? displacedBy.point : origin;\n};\n\nvar whenCombining = ({\n  afterCritical,\n  impact,\n  draggables\n}) => {\n  const combine = tryGetCombine(impact);\n  !combine ?  true ? invariant() : 0 : void 0;\n  const combineWith = combine.draggableId;\n  const center = draggables[combineWith].page.borderBox.center;\n  const displaceBy = getCombinedItemDisplacement({\n    displaced: impact.displaced,\n    afterCritical,\n    combineWith,\n    displacedBy: impact.displacedBy\n  });\n  return add(center, displaceBy);\n};\n\nconst distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({\n  axis,\n  moveRelativeTo,\n  isMoving\n}) => patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({\n  axis,\n  moveRelativeTo,\n  isMoving\n}) => patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({\n  axis,\n  moveInto,\n  isMoving\n}) => patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n\nvar whenReordering = ({\n  impact,\n  draggable,\n  draggables,\n  droppable,\n  afterCritical\n}) => {\n  const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  const draggablePage = draggable.page;\n  const axis = droppable.axis;\n  if (!insideDestination.length) {\n    return goIntoStart({\n      axis,\n      moveInto: droppable.page,\n      isMoving: draggablePage\n    });\n  }\n  const {\n    displaced,\n    displacedBy\n  } = impact;\n  const closestAfter = displaced.all[0];\n  if (closestAfter) {\n    const closest = draggables[closestAfter];\n    if (didStartAfterCritical(closestAfter, afterCritical)) {\n      return goBefore({\n        axis,\n        moveRelativeTo: closest.page,\n        isMoving: draggablePage\n      });\n    }\n    const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(closest.page, displacedBy.point);\n    return goBefore({\n      axis,\n      moveRelativeTo: withDisplacement,\n      isMoving: draggablePage\n    });\n  }\n  const last = insideDestination[insideDestination.length - 1];\n  if (last.descriptor.id === draggable.descriptor.id) {\n    return draggablePage.borderBox.center;\n  }\n  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(last.page, negate(afterCritical.displacedBy.point));\n    return goAfter({\n      axis,\n      moveRelativeTo: page,\n      isMoving: draggablePage\n    });\n  }\n  return goAfter({\n    axis,\n    moveRelativeTo: last.page,\n    isMoving: draggablePage\n  });\n};\n\nvar withDroppableDisplacement = (droppable, point) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return point;\n  }\n  return add(point, frame.scroll.diff.displacement);\n};\n\nconst getResultWithoutDroppableDisplacement = ({\n  impact,\n  draggable,\n  droppable,\n  draggables,\n  afterCritical\n}) => {\n  const original = draggable.page.borderBox.center;\n  const at = impact.at;\n  if (!droppable) {\n    return original;\n  }\n  if (!at) {\n    return original;\n  }\n  if (at.type === 'REORDER') {\n    return whenReordering({\n      impact,\n      draggable,\n      draggables,\n      droppable,\n      afterCritical\n    });\n  }\n  return whenCombining({\n    impact,\n    draggables,\n    afterCritical\n  });\n};\nvar getPageBorderBoxCenterFromImpact = args => {\n  const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n  const droppable = args.droppable;\n  const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n  return withDisplacement;\n};\n\nvar scrollViewport = (viewport, newScroll) => {\n  const diff = subtract(newScroll, viewport.scroll.initial);\n  const displacement = negate(diff);\n  const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top: newScroll.y,\n    bottom: newScroll.y + viewport.frame.height,\n    left: newScroll.x,\n    right: newScroll.x + viewport.frame.width\n  });\n  const updated = {\n    frame,\n    scroll: {\n      initial: viewport.scroll.initial,\n      max: viewport.scroll.max,\n      current: newScroll,\n      diff: {\n        value: diff,\n        displacement\n      }\n    }\n  };\n  return updated;\n};\n\nfunction getDraggables$1(ids, draggables) {\n  return ids.map(id => draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n  for (let i = 0; i < groups.length; i++) {\n    const displacement = groups[i].visible[id];\n    if (displacement) {\n      return displacement;\n    }\n  }\n  return null;\n}\nvar speculativelyIncrease = ({\n  impact,\n  viewport,\n  destination,\n  draggables,\n  maxScrollChange\n}) => {\n  const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n  const last = impact.displaced;\n  const withViewportScroll = getDisplacementGroups({\n    afterDragging: getDraggables$1(last.all, draggables),\n    destination,\n    displacedBy: impact.displacedBy,\n    viewport: scrolledViewport.frame,\n    last,\n    forceShouldAnimate: false\n  });\n  const withDroppableScroll = getDisplacementGroups({\n    afterDragging: getDraggables$1(last.all, draggables),\n    destination: scrolledDroppable,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    last,\n    forceShouldAnimate: false\n  });\n  const invisible = {};\n  const visible = {};\n  const groups = [last, withViewportScroll, withDroppableScroll];\n  last.all.forEach(id => {\n    const displacement = tryGetVisible(id, groups);\n    if (displacement) {\n      visible[id] = displacement;\n      return;\n    }\n    invisible[id] = true;\n  });\n  const newImpact = {\n    ...impact,\n    displaced: {\n      all: last.all,\n      invisible,\n      visible\n    }\n  };\n  return newImpact;\n};\n\nvar withViewportDisplacement = (viewport, point) => add(viewport.scroll.diff.displacement, point);\n\nvar getClientFromPageBorderBoxCenter = ({\n  pageBorderBoxCenter,\n  draggable,\n  viewport\n}) => {\n  const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n  const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n  return add(draggable.client.borderBox.center, offset);\n};\n\nvar isTotallyVisibleInNewLocation = ({\n  draggable,\n  destination,\n  newPageBorderBoxCenter,\n  viewport,\n  withDroppableDisplacement,\n  onlyOnMainAxis = false\n}) => {\n  const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n  const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n  const args = {\n    target: shifted,\n    destination,\n    withDroppableDisplacement,\n    viewport\n  };\n  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\n\nvar moveToNextPlace = ({\n  isMovingForward,\n  draggable,\n  destination,\n  draggables,\n  previousImpact,\n  viewport,\n  previousPageBorderBoxCenter,\n  previousClientSelection,\n  afterCritical\n}) => {\n  if (!destination.isEnabled) {\n    return null;\n  }\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const isInHomeList = isHomeOf(draggable, destination);\n  const impact = moveToNextCombine({\n    isMovingForward,\n    draggable,\n    destination,\n    insideDestination,\n    previousImpact\n  }) || moveToNextIndex({\n    isMovingForward,\n    isInHomeList,\n    draggable,\n    draggables,\n    destination,\n    insideDestination,\n    previousImpact,\n    viewport,\n    afterCritical\n  });\n  if (!impact) {\n    return null;\n  }\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    afterCritical\n  });\n  const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n    draggable,\n    destination,\n    newPageBorderBoxCenter: pageBorderBoxCenter,\n    viewport: viewport.frame,\n    withDroppableDisplacement: false,\n    onlyOnMainAxis: true\n  });\n  if (isVisibleInNewLocation) {\n    const clientSelection = getClientFromPageBorderBoxCenter({\n      pageBorderBoxCenter,\n      draggable,\n      viewport\n    });\n    return {\n      clientSelection,\n      impact,\n      scrollJumpRequest: null\n    };\n  }\n  const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n  const cautious = speculativelyIncrease({\n    impact,\n    viewport,\n    destination,\n    draggables,\n    maxScrollChange: distance\n  });\n  return {\n    clientSelection: previousClientSelection,\n    impact: cautious,\n    scrollJumpRequest: distance\n  };\n};\n\nconst getKnownActive = droppable => {\n  const rect = droppable.subject.active;\n  !rect ?  true ? invariant(false, 'Cannot get clipped area from droppable') : 0 : void 0;\n  return rect;\n};\nvar getBestCrossAxisDroppable = ({\n  isMovingForward,\n  pageBorderBoxCenter,\n  source,\n  droppables,\n  viewport\n}) => {\n  const active = source.subject.active;\n  if (!active) {\n    return null;\n  }\n  const axis = source.axis;\n  const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n  const candidates = toDroppableList(droppables).filter(droppable => droppable !== source).filter(droppable => droppable.isEnabled).filter(droppable => Boolean(droppable.subject.active)).filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {\n    const activeOfTarget = getKnownActive(droppable);\n    if (isMovingForward) {\n      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n    }\n    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n  }).filter(droppable => {\n    const activeOfTarget = getKnownActive(droppable);\n    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n  }).sort((a, b) => {\n    const first = getKnownActive(a)[axis.crossAxisStart];\n    const second = getKnownActive(b)[axis.crossAxisStart];\n    if (isMovingForward) {\n      return first - second;\n    }\n    return second - first;\n  }).filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n  if (!candidates.length) {\n    return null;\n  }\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n  const contains = candidates.filter(droppable => {\n    const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n    return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n  });\n  if (contains.length === 1) {\n    return contains[0];\n  }\n  if (contains.length > 1) {\n    return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n  }\n  return candidates.sort((a, b) => {\n    const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n    if (first !== second) {\n      return first - second;\n    }\n    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n  })[0];\n};\n\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical) => {\n  const original = draggable.page.borderBox.center;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical) => {\n  const original = draggable.page.borderBox;\n  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\n\nvar getClosestDraggable = ({\n  pageBorderBoxCenter,\n  viewport,\n  destination,\n  insideDestination,\n  afterCritical\n}) => {\n  const sorted = insideDestination.filter(draggable => isTotallyVisible({\n    target: getCurrentPageBorderBox(draggable, afterCritical),\n    destination,\n    viewport: viewport.frame,\n    withDroppableDisplacement: true\n  })).sort((a, b) => {\n    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n    if (distanceToA < distanceToB) {\n      return -1;\n    }\n    if (distanceToB < distanceToA) {\n      return 1;\n    }\n    return a.descriptor.index - b.descriptor.index;\n  });\n  return sorted[0] || null;\n};\n\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n  const displacement = displaceBy[axis.line];\n  return {\n    value: displacement,\n    point: patch(axis.line, displacement)\n  };\n});\n\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables) => {\n  const axis = droppable.axis;\n  if (droppable.descriptor.mode === 'virtual') {\n    return patch(axis.line, placeholderSize[axis.line]);\n  }\n  const availableSpace = droppable.subject.page.contentBox[axis.size];\n  const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);\n  const requiredSpace = spaceUsed + placeholderSize[axis.line];\n  const needsToGrowBy = requiredSpace - availableSpace;\n  if (needsToGrowBy <= 0) {\n    return null;\n  }\n  return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max) => ({\n  ...frame,\n  scroll: {\n    ...frame.scroll,\n    max\n  }\n});\nconst addPlaceholder = (droppable, draggable, draggables) => {\n  const frame = droppable.frame;\n  !!isHomeOf(draggable, droppable) ?  true ? invariant(false, 'Should not add placeholder space to home list') : 0 : void 0;\n  !!droppable.subject.withPlaceholder ?  true ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : 0 : void 0;\n  const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n  const added = {\n    placeholderSize,\n    increasedBy: requiredGrowth,\n    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n  };\n  if (!frame) {\n    const subject = getSubject({\n      page: droppable.subject.page,\n      withPlaceholder: added,\n      axis: droppable.axis,\n      frame: droppable.frame\n    });\n    return {\n      ...droppable,\n      subject\n    };\n  }\n  const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n  const newFrame = withMaxScroll(frame, maxScroll);\n  const subject = getSubject({\n    page: droppable.subject.page,\n    withPlaceholder: added,\n    axis: droppable.axis,\n    frame: newFrame\n  });\n  return {\n    ...droppable,\n    subject,\n    frame: newFrame\n  };\n};\nconst removePlaceholder = droppable => {\n  const added = droppable.subject.withPlaceholder;\n  !added ?  true ? invariant(false, 'Cannot remove placeholder form subject when there was none') : 0 : void 0;\n  const frame = droppable.frame;\n  if (!frame) {\n    const subject = getSubject({\n      page: droppable.subject.page,\n      axis: droppable.axis,\n      frame: null,\n      withPlaceholder: null\n    });\n    return {\n      ...droppable,\n      subject\n    };\n  }\n  const oldMaxScroll = added.oldFrameMaxScroll;\n  !oldMaxScroll ?  true ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : 0 : void 0;\n  const newFrame = withMaxScroll(frame, oldMaxScroll);\n  const subject = getSubject({\n    page: droppable.subject.page,\n    axis: droppable.axis,\n    frame: newFrame,\n    withPlaceholder: null\n  });\n  return {\n    ...droppable,\n    subject,\n    frame: newFrame\n  };\n};\n\nvar moveToNewDroppable = ({\n  previousPageBorderBoxCenter,\n  moveRelativeTo,\n  insideDestination,\n  draggable,\n  draggables,\n  destination,\n  viewport,\n  afterCritical\n}) => {\n  if (!moveRelativeTo) {\n    if (insideDestination.length) {\n      return null;\n    }\n    const proposed = {\n      displaced: emptyGroups,\n      displacedBy: noDisplacedBy,\n      at: {\n        type: 'REORDER',\n        destination: {\n          droppableId: destination.descriptor.id,\n          index: 0\n        }\n      }\n    };\n    const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n      impact: proposed,\n      draggable,\n      droppable: destination,\n      draggables,\n      afterCritical\n    });\n    const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n      draggable,\n      destination: withPlaceholder,\n      newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n      viewport: viewport.frame,\n      withDroppableDisplacement: false,\n      onlyOnMainAxis: true\n    });\n    return isVisibleInNewLocation ? proposed : null;\n  }\n  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n  const proposedIndex = (() => {\n    const relativeTo = moveRelativeTo.descriptor.index;\n    if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n      return relativeTo;\n    }\n    if (isGoingBeforeTarget) {\n      return relativeTo;\n    }\n    return relativeTo + 1;\n  })();\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    displacedBy,\n    last: emptyGroups,\n    index: proposedIndex\n  });\n};\n\nvar moveCrossAxis = ({\n  isMovingForward,\n  previousPageBorderBoxCenter,\n  draggable,\n  isOver,\n  draggables,\n  droppables,\n  viewport,\n  afterCritical\n}) => {\n  const destination = getBestCrossAxisDroppable({\n    isMovingForward,\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    source: isOver,\n    droppables,\n    viewport\n  });\n  if (!destination) {\n    return null;\n  }\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const moveRelativeTo = getClosestDraggable({\n    pageBorderBoxCenter: previousPageBorderBoxCenter,\n    viewport,\n    destination,\n    insideDestination,\n    afterCritical\n  });\n  const impact = moveToNewDroppable({\n    previousPageBorderBoxCenter,\n    destination,\n    draggable,\n    draggables,\n    moveRelativeTo,\n    insideDestination,\n    viewport,\n    afterCritical\n  });\n  if (!impact) {\n    return null;\n  }\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    afterCritical\n  });\n  const clientSelection = getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter,\n    draggable,\n    viewport\n  });\n  return {\n    clientSelection,\n    impact,\n    scrollJumpRequest: null\n  };\n};\n\nvar whatIsDraggedOver = impact => {\n  const at = impact.at;\n  if (!at) {\n    return null;\n  }\n  if (at.type === 'REORDER') {\n    return at.destination.droppableId;\n  }\n  return at.combine.droppableId;\n};\n\nconst getDroppableOver$1 = (impact, droppables) => {\n  const id = whatIsDraggedOver(impact);\n  return id ? droppables[id] : null;\n};\nvar moveInDirection = ({\n  state,\n  type\n}) => {\n  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n  const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n  const home = state.dimensions.droppables[state.critical.droppable.id];\n  const isOver = isActuallyOver || home;\n  const direction = isOver.axis.direction;\n  const isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');\n  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n    return null;\n  }\n  const isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';\n  const draggable = state.dimensions.draggables[state.critical.draggable.id];\n  const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n  const {\n    draggables,\n    droppables\n  } = state.dimensions;\n  return isMovingOnMainAxis ? moveToNextPlace({\n    isMovingForward,\n    previousPageBorderBoxCenter,\n    draggable,\n    destination: isOver,\n    draggables,\n    viewport: state.viewport,\n    previousClientSelection: state.current.client.selection,\n    previousImpact: state.impact,\n    afterCritical: state.afterCritical\n  }) : moveCrossAxis({\n    isMovingForward,\n    previousPageBorderBoxCenter,\n    draggable,\n    isOver,\n    draggables,\n    droppables,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n};\n\nfunction isMovementAllowed(state) {\n  return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';\n}\n\nfunction isPositionInFrame(frame) {\n  const isWithinVertical = isWithin(frame.top, frame.bottom);\n  const isWithinHorizontal = isWithin(frame.left, frame.right);\n  return function run(point) {\n    return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n  };\n}\n\nfunction getHasOverlap(first, second) {\n  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({\n  pageBorderBox,\n  draggable,\n  candidates\n}) {\n  const startCenter = draggable.page.borderBox.center;\n  const sorted = candidates.map(candidate => {\n    const axis = candidate.axis;\n    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n    return {\n      id: candidate.descriptor.id,\n      distance: distance(startCenter, target)\n    };\n  }).sort((a, b) => b.distance - a.distance);\n  return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({\n  pageBorderBox,\n  draggable,\n  droppables\n}) {\n  const candidates = toDroppableList(droppables).filter(item => {\n    if (!item.isEnabled) {\n      return false;\n    }\n    const active = item.subject.active;\n    if (!active) {\n      return false;\n    }\n    if (!getHasOverlap(pageBorderBox, active)) {\n      return false;\n    }\n    if (isPositionInFrame(active)(pageBorderBox.center)) {\n      return true;\n    }\n    const axis = item.axis;\n    const childCenter = active.center[axis.crossAxisLine];\n    const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n    const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n    const isStartContained = isContained(crossAxisStart);\n    const isEndContained = isContained(crossAxisEnd);\n    if (!isStartContained && !isEndContained) {\n      return true;\n    }\n    if (isStartContained) {\n      return crossAxisStart < childCenter;\n    }\n    return crossAxisEnd > childCenter;\n  });\n  if (!candidates.length) {\n    return null;\n  }\n  if (candidates.length === 1) {\n    return candidates[0].descriptor.id;\n  }\n  return getFurthestAway({\n    pageBorderBox,\n    draggable,\n    candidates\n  });\n}\n\nconst offsetRectByPosition = (rect, point) => (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(offsetByPosition(rect, point));\n\nvar withDroppableScroll = (droppable, area) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return area;\n  }\n  return offsetRectByPosition(area, frame.scroll.diff.value);\n};\n\nfunction getIsDisplaced({\n  displaced,\n  id\n}) {\n  return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\n\nfunction atIndex({\n  draggable,\n  closest,\n  inHomeList\n}) {\n  if (!closest) {\n    return null;\n  }\n  if (!inHomeList) {\n    return closest.descriptor.index;\n  }\n  if (closest.descriptor.index > draggable.descriptor.index) {\n    return closest.descriptor.index - 1;\n  }\n  return closest.descriptor.index;\n}\nvar getReorderImpact = ({\n  pageBorderBoxWithDroppableScroll: targetRect,\n  draggable,\n  destination,\n  insideDestination,\n  last,\n  viewport,\n  afterCritical\n}) => {\n  const axis = destination.axis;\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  const displacement = displacedBy.value;\n  const targetStart = targetRect[axis.start];\n  const targetEnd = targetRect[axis.end];\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const closest = withoutDragging.find(child => {\n    const id = child.descriptor.id;\n    const childCenter = child.page.borderBox.center[axis.line];\n    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    const isDisplaced = getIsDisplaced({\n      displaced: last,\n      id\n    });\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd <= childCenter;\n      }\n      return targetStart < childCenter - displacement;\n    }\n    if (isDisplaced) {\n      return targetEnd <= childCenter + displacement;\n    }\n    return targetStart < childCenter;\n  }) || null;\n  const newIndex = atIndex({\n    draggable,\n    closest,\n    inHomeList: isHomeOf(draggable, destination)\n  });\n  return calculateReorderImpact({\n    draggable,\n    insideDestination,\n    destination,\n    viewport,\n    last,\n    displacedBy,\n    index: newIndex\n  });\n};\n\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({\n  draggable,\n  pageBorderBoxWithDroppableScroll: targetRect,\n  previousImpact,\n  destination,\n  insideDestination,\n  afterCritical\n}) => {\n  if (!destination.isCombineEnabled) {\n    return null;\n  }\n  const axis = destination.axis;\n  const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n  const displacement = displacedBy.value;\n  const targetStart = targetRect[axis.start];\n  const targetEnd = targetRect[axis.end];\n  const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n  const combineWith = withoutDragging.find(child => {\n    const id = child.descriptor.id;\n    const childRect = child.page.borderBox;\n    const childSize = childRect[axis.size];\n    const threshold = childSize / combineThresholdDivisor;\n    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n    const isDisplaced = getIsDisplaced({\n      displaced: previousImpact.displaced,\n      id\n    });\n    if (didStartAfterCritical$1) {\n      if (isDisplaced) {\n        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n      }\n      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n    }\n    if (isDisplaced) {\n      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n    }\n    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n  });\n  if (!combineWith) {\n    return null;\n  }\n  const impact = {\n    displacedBy,\n    displaced: previousImpact.displaced,\n    at: {\n      type: 'COMBINE',\n      combine: {\n        draggableId: combineWith.descriptor.id,\n        droppableId: destination.descriptor.id\n      }\n    }\n  };\n  return impact;\n};\n\nvar getDragImpact = ({\n  pageOffset,\n  draggable,\n  draggables,\n  droppables,\n  previousImpact,\n  viewport,\n  afterCritical\n}) => {\n  const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n  const destinationId = getDroppableOver({\n    pageBorderBox,\n    draggable,\n    droppables\n  });\n  if (!destinationId) {\n    return noImpact;\n  }\n  const destination = droppables[destinationId];\n  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n  return getCombineImpact({\n    pageBorderBoxWithDroppableScroll,\n    draggable,\n    previousImpact,\n    destination,\n    insideDestination,\n    afterCritical\n  }) || getReorderImpact({\n    pageBorderBoxWithDroppableScroll,\n    draggable,\n    destination,\n    insideDestination,\n    last: previousImpact.displaced,\n    viewport,\n    afterCritical\n  });\n};\n\nvar patchDroppableMap = (droppables, updated) => ({\n  ...droppables,\n  [updated.descriptor.id]: updated\n});\n\nconst clearUnusedPlaceholder = ({\n  previousImpact,\n  impact,\n  droppables\n}) => {\n  const last = whatIsDraggedOver(previousImpact);\n  const now = whatIsDraggedOver(impact);\n  if (!last) {\n    return droppables;\n  }\n  if (last === now) {\n    return droppables;\n  }\n  const lastDroppable = droppables[last];\n  if (!lastDroppable.subject.withPlaceholder) {\n    return droppables;\n  }\n  const updated = removePlaceholder(lastDroppable);\n  return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({\n  draggable,\n  draggables,\n  droppables,\n  previousImpact,\n  impact\n}) => {\n  const cleaned = clearUnusedPlaceholder({\n    previousImpact,\n    impact,\n    droppables\n  });\n  const isOver = whatIsDraggedOver(impact);\n  if (!isOver) {\n    return cleaned;\n  }\n  const droppable = droppables[isOver];\n  if (isHomeOf(draggable, droppable)) {\n    return cleaned;\n  }\n  if (droppable.subject.withPlaceholder) {\n    return cleaned;\n  }\n  const patched = addPlaceholder(droppable, draggable, draggables);\n  return patchDroppableMap(cleaned, patched);\n};\n\nvar update = ({\n  state,\n  clientSelection: forcedClientSelection,\n  dimensions: forcedDimensions,\n  viewport: forcedViewport,\n  impact: forcedImpact,\n  scrollJumpRequest\n}) => {\n  const viewport = forcedViewport || state.viewport;\n  const dimensions = forcedDimensions || state.dimensions;\n  const clientSelection = forcedClientSelection || state.current.client.selection;\n  const offset = subtract(clientSelection, state.initial.client.selection);\n  const client = {\n    offset,\n    selection: clientSelection,\n    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n  };\n  const page = {\n    selection: add(client.selection, viewport.scroll.current),\n    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n    offset: add(client.offset, viewport.scroll.diff.value)\n  };\n  const current = {\n    client,\n    page\n  };\n  if (state.phase === 'COLLECTING') {\n    return {\n      ...state,\n      dimensions,\n      viewport,\n      current\n    };\n  }\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const newImpact = forcedImpact || getDragImpact({\n    pageOffset: page.offset,\n    draggable,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact: state.impact,\n    viewport,\n    afterCritical: state.afterCritical\n  });\n  const withUpdatedPlaceholders = recomputePlaceholders({\n    draggable,\n    impact: newImpact,\n    previousImpact: state.impact,\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables\n  });\n  const result = {\n    ...state,\n    current,\n    dimensions: {\n      draggables: dimensions.draggables,\n      droppables: withUpdatedPlaceholders\n    },\n    impact: newImpact,\n    viewport,\n    scrollJumpRequest: scrollJumpRequest || null,\n    forceShouldAnimate: scrollJumpRequest ? false : null\n  };\n  return result;\n};\n\nfunction getDraggables(ids, draggables) {\n  return ids.map(id => draggables[id]);\n}\nvar recompute = ({\n  impact,\n  viewport,\n  draggables,\n  destination,\n  forceShouldAnimate\n}) => {\n  const last = impact.displaced;\n  const afterDragging = getDraggables(last.all, draggables);\n  const displaced = getDisplacementGroups({\n    afterDragging,\n    destination,\n    displacedBy: impact.displacedBy,\n    viewport: viewport.frame,\n    forceShouldAnimate,\n    last\n  });\n  return {\n    ...impact,\n    displaced\n  };\n};\n\nvar getClientBorderBoxCenter = ({\n  impact,\n  draggable,\n  droppable,\n  draggables,\n  viewport,\n  afterCritical\n}) => {\n  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n    impact,\n    draggable,\n    draggables,\n    droppable,\n    afterCritical\n  });\n  return getClientFromPageBorderBoxCenter({\n    pageBorderBoxCenter,\n    draggable,\n    viewport\n  });\n};\n\nvar refreshSnap = ({\n  state,\n  dimensions: forcedDimensions,\n  viewport: forcedViewport\n}) => {\n  !(state.movementMode === 'SNAP') ?  true ? invariant() : 0 : void 0;\n  const needsVisibilityCheck = state.impact;\n  const viewport = forcedViewport || state.viewport;\n  const dimensions = forcedDimensions || state.dimensions;\n  const {\n    draggables,\n    droppables\n  } = dimensions;\n  const draggable = draggables[state.critical.draggable.id];\n  const isOver = whatIsDraggedOver(needsVisibilityCheck);\n  !isOver ?  true ? invariant(false, 'Must be over a destination in SNAP movement mode') : 0 : void 0;\n  const destination = droppables[isOver];\n  const impact = recompute({\n    impact: needsVisibilityCheck,\n    viewport,\n    destination,\n    draggables\n  });\n  const clientSelection = getClientBorderBoxCenter({\n    impact,\n    draggable,\n    droppable: destination,\n    draggables,\n    viewport,\n    afterCritical: state.afterCritical\n  });\n  return update({\n    impact,\n    clientSelection,\n    state,\n    dimensions,\n    viewport\n  });\n};\n\nvar getHomeLocation = descriptor => ({\n  index: descriptor.index,\n  droppableId: descriptor.droppableId\n});\n\nvar getLiftEffect = ({\n  draggable,\n  home,\n  draggables,\n  viewport\n}) => {\n  const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n  const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n  const rawIndex = insideHome.indexOf(draggable);\n  !(rawIndex !== -1) ?  true ? invariant(false, 'Expected draggable to be inside home list') : 0 : void 0;\n  const afterDragging = insideHome.slice(rawIndex + 1);\n  const effected = afterDragging.reduce((previous, item) => {\n    previous[item.descriptor.id] = true;\n    return previous;\n  }, {});\n  const afterCritical = {\n    inVirtualList: home.descriptor.mode === 'virtual',\n    displacedBy,\n    effected\n  };\n  const displaced = getDisplacementGroups({\n    afterDragging,\n    destination: home,\n    displacedBy,\n    last: null,\n    viewport: viewport.frame,\n    forceShouldAnimate: false\n  });\n  const impact = {\n    displaced,\n    displacedBy,\n    at: {\n      type: 'REORDER',\n      destination: getHomeLocation(draggable.descriptor)\n    }\n  };\n  return {\n    impact,\n    afterCritical\n  };\n};\n\nvar patchDimensionMap = (dimensions, updated) => ({\n  draggables: dimensions.draggables,\n  droppables: patchDroppableMap(dimensions.droppables, updated)\n});\n\nconst start = key => {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\nconst finish = key => {\n  if (true) {\n    {\n      return;\n    }\n  }\n};\n\nvar offsetDraggable = ({\n  draggable,\n  offset: offset$1,\n  initialWindowScroll\n}) => {\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(draggable.client, offset$1);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, initialWindowScroll);\n  const moved = {\n    ...draggable,\n    placeholder: {\n      ...draggable.placeholder,\n      client\n    },\n    client,\n    page\n  };\n  return moved;\n};\n\nvar getFrame = droppable => {\n  const frame = droppable.frame;\n  !frame ?  true ? invariant(false, 'Expected Droppable to have a frame') : 0 : void 0;\n  return frame;\n};\n\nvar adjustAdditionsForScrollChanges = ({\n  additions,\n  updatedDroppables,\n  viewport\n}) => {\n  const windowScrollChange = viewport.scroll.diff.value;\n  return additions.map(draggable => {\n    const droppableId = draggable.descriptor.droppableId;\n    const modified = updatedDroppables[droppableId];\n    const frame = getFrame(modified);\n    const droppableScrollChange = frame.scroll.diff.value;\n    const totalChange = add(windowScrollChange, droppableScrollChange);\n    const moved = offsetDraggable({\n      draggable,\n      offset: totalChange,\n      initialWindowScroll: viewport.scroll.initial\n    });\n    return moved;\n  });\n};\n\nvar publishWhileDraggingInVirtual = ({\n  state,\n  published\n}) => {\n  start();\n  const withScrollChange = published.modified.map(update => {\n    const existing = state.dimensions.droppables[update.droppableId];\n    const scrolled = scrollDroppable(existing, update.scroll);\n    return scrolled;\n  });\n  const droppables = {\n    ...state.dimensions.droppables,\n    ...toDroppableMap(withScrollChange)\n  };\n  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n    additions: published.additions,\n    updatedDroppables: droppables,\n    viewport: state.viewport\n  }));\n  const draggables = {\n    ...state.dimensions.draggables,\n    ...updatedAdditions\n  };\n  published.removals.forEach(id => {\n    delete draggables[id];\n  });\n  const dimensions = {\n    droppables,\n    draggables\n  };\n  const wasOverId = whatIsDraggedOver(state.impact);\n  const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const home = dimensions.droppables[state.critical.droppable.id];\n  const {\n    impact: onLiftImpact,\n    afterCritical\n  } = getLiftEffect({\n    draggable,\n    home,\n    draggables,\n    viewport: state.viewport\n  });\n  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n  const impact = getDragImpact({\n    pageOffset: state.current.page.offset,\n    draggable: dimensions.draggables[state.critical.draggable.id],\n    draggables: dimensions.draggables,\n    droppables: dimensions.droppables,\n    previousImpact,\n    viewport: state.viewport,\n    afterCritical\n  });\n  finish();\n  const draggingState = {\n    ...state,\n    phase: 'DRAGGING',\n    impact,\n    onLiftImpact,\n    dimensions,\n    afterCritical,\n    forceShouldAnimate: false\n  };\n  if (state.phase === 'COLLECTING') {\n    return draggingState;\n  }\n  const dropPending = {\n    ...draggingState,\n    phase: 'DROP_PENDING',\n    reason: state.reason,\n    isWaiting: false\n  };\n  return dropPending;\n};\n\nconst isSnapping = state => state.movementMode === 'SNAP';\nconst postDroppableChange = (state, updated, isEnabledChanging) => {\n  const dimensions = patchDimensionMap(state.dimensions, updated);\n  if (!isSnapping(state) || isEnabledChanging) {\n    return update({\n      state,\n      dimensions\n    });\n  }\n  return refreshSnap({\n    state,\n    dimensions\n  });\n};\nfunction removeScrollJumpRequest(state) {\n  if (state.isDragging && state.movementMode === 'SNAP') {\n    return {\n      ...state,\n      scrollJumpRequest: null\n    };\n  }\n  return state;\n}\nconst idle$2 = {\n  phase: 'IDLE',\n  completed: null,\n  shouldFlush: false\n};\nvar reducer = (state = idle$2, action) => {\n  if (action.type === 'FLUSH') {\n    return {\n      ...idle$2,\n      shouldFlush: true\n    };\n  }\n  if (action.type === 'INITIAL_PUBLISH') {\n    !(state.phase === 'IDLE') ?  true ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : 0 : void 0;\n    const {\n      critical,\n      clientSelection,\n      viewport,\n      dimensions,\n      movementMode\n    } = action.payload;\n    const draggable = dimensions.draggables[critical.draggable.id];\n    const home = dimensions.droppables[critical.droppable.id];\n    const client = {\n      selection: clientSelection,\n      borderBoxCenter: draggable.client.borderBox.center,\n      offset: origin\n    };\n    const initial = {\n      client,\n      page: {\n        selection: add(client.selection, viewport.scroll.initial),\n        borderBoxCenter: add(client.selection, viewport.scroll.initial),\n        offset: add(client.selection, viewport.scroll.diff.value)\n      }\n    };\n    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(item => !item.isFixedOnPage);\n    const {\n      impact,\n      afterCritical\n    } = getLiftEffect({\n      draggable,\n      home,\n      draggables: dimensions.draggables,\n      viewport\n    });\n    const result = {\n      phase: 'DRAGGING',\n      isDragging: true,\n      critical,\n      movementMode,\n      dimensions,\n      initial,\n      current: initial,\n      isWindowScrollAllowed,\n      impact,\n      afterCritical,\n      onLiftImpact: impact,\n      viewport,\n      scrollJumpRequest: null,\n      forceShouldAnimate: null\n    };\n    return result;\n  }\n  if (action.type === 'COLLECTION_STARTING') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n    const result = {\n      ...state,\n      phase: 'COLLECTING'\n    };\n    return result;\n  }\n  if (action.type === 'PUBLISH_WHILE_DRAGGING') {\n    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n    return publishWhileDraggingInVirtual({\n      state,\n      published: action.payload\n    });\n  }\n  if (action.type === 'MOVE') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n    const {\n      client: clientSelection\n    } = action.payload;\n    if (isEqual$1(clientSelection, state.current.client.selection)) {\n      return state;\n    }\n    return update({\n      state,\n      clientSelection,\n      impact: isSnapping(state) ? state.impact : null\n    });\n  }\n  if (action.type === 'UPDATE_DROPPABLE_SCROLL') {\n    if (state.phase === 'DROP_PENDING') {\n      return removeScrollJumpRequest(state);\n    }\n    if (state.phase === 'COLLECTING') {\n      return removeScrollJumpRequest(state);\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      newScroll\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    if (!target) {\n      return state;\n    }\n    const scrolled = scrollDroppable(target, newScroll);\n    return postDroppableChange(state, scrolled, false);\n  }\n  if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      isEnabled\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n    !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n    const updated = {\n      ...target,\n      isEnabled\n    };\n    return postDroppableChange(state, updated, true);\n  }\n  if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {\n    if (state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n    const {\n      id,\n      isCombineEnabled\n    } = action.payload;\n    const target = state.dimensions.droppables[id];\n    !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n    !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n    const updated = {\n      ...target,\n      isCombineEnabled\n    };\n    return postDroppableChange(state, updated, true);\n  }\n  if (action.type === 'MOVE_BY_WINDOW_SCROLL') {\n    if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {\n      return state;\n    }\n    !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n    !state.isWindowScrollAllowed ?  true ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : 0 : void 0;\n    const newScroll = action.payload.newScroll;\n    if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n      return removeScrollJumpRequest(state);\n    }\n    const viewport = scrollViewport(state.viewport, newScroll);\n    if (isSnapping(state)) {\n      return refreshSnap({\n        state,\n        viewport\n      });\n    }\n    return update({\n      state,\n      viewport\n    });\n  }\n  if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {\n    if (!isMovementAllowed(state)) {\n      return state;\n    }\n    const maxScroll = action.payload.maxScroll;\n    if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n      return state;\n    }\n    const withMaxScroll = {\n      ...state.viewport,\n      scroll: {\n        ...state.viewport.scroll,\n        max: maxScroll\n      }\n    };\n    return {\n      ...state,\n      viewport: withMaxScroll\n    };\n  }\n  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {\n    if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {\n      return state;\n    }\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n    const result = moveInDirection({\n      state,\n      type: action.type\n    });\n    if (!result) {\n      return state;\n    }\n    return update({\n      state,\n      impact: result.impact,\n      clientSelection: result.clientSelection,\n      scrollJumpRequest: result.scrollJumpRequest\n    });\n  }\n  if (action.type === 'DROP_PENDING') {\n    const reason = action.payload.reason;\n    !(state.phase === 'COLLECTING') ?  true ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : 0 : void 0;\n    const newState = {\n      ...state,\n      phase: 'DROP_PENDING',\n      isWaiting: true,\n      reason\n    };\n    return newState;\n  }\n  if (action.type === 'DROP_ANIMATE') {\n    const {\n      completed,\n      dropDuration,\n      newHomeClientOffset\n    } = action.payload;\n    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n    const result = {\n      phase: 'DROP_ANIMATING',\n      completed,\n      dropDuration,\n      newHomeClientOffset,\n      dimensions: state.dimensions\n    };\n    return result;\n  }\n  if (action.type === 'DROP_COMPLETE') {\n    const {\n      completed\n    } = action.payload;\n    return {\n      phase: 'IDLE',\n      completed,\n      shouldFlush: false\n    };\n  }\n  return state;\n};\n\nfunction guard(action, predicate) {\n  return action instanceof Object && 'type' in action && action.type === predicate;\n}\nconst beforeInitialCapture = args => ({\n  type: 'BEFORE_INITIAL_CAPTURE',\n  payload: args\n});\nconst lift$1 = args => ({\n  type: 'LIFT',\n  payload: args\n});\nconst initialPublish = args => ({\n  type: 'INITIAL_PUBLISH',\n  payload: args\n});\nconst publishWhileDragging = args => ({\n  type: 'PUBLISH_WHILE_DRAGGING',\n  payload: args\n});\nconst collectionStarting = () => ({\n  type: 'COLLECTION_STARTING',\n  payload: null\n});\nconst updateDroppableScroll = args => ({\n  type: 'UPDATE_DROPPABLE_SCROLL',\n  payload: args\n});\nconst updateDroppableIsEnabled = args => ({\n  type: 'UPDATE_DROPPABLE_IS_ENABLED',\n  payload: args\n});\nconst updateDroppableIsCombineEnabled = args => ({\n  type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',\n  payload: args\n});\nconst move = args => ({\n  type: 'MOVE',\n  payload: args\n});\nconst moveByWindowScroll = args => ({\n  type: 'MOVE_BY_WINDOW_SCROLL',\n  payload: args\n});\nconst updateViewportMaxScroll = args => ({\n  type: 'UPDATE_VIEWPORT_MAX_SCROLL',\n  payload: args\n});\nconst moveUp = () => ({\n  type: 'MOVE_UP',\n  payload: null\n});\nconst moveDown = () => ({\n  type: 'MOVE_DOWN',\n  payload: null\n});\nconst moveRight = () => ({\n  type: 'MOVE_RIGHT',\n  payload: null\n});\nconst moveLeft = () => ({\n  type: 'MOVE_LEFT',\n  payload: null\n});\nconst flush = () => ({\n  type: 'FLUSH',\n  payload: null\n});\nconst animateDrop = args => ({\n  type: 'DROP_ANIMATE',\n  payload: args\n});\nconst completeDrop = args => ({\n  type: 'DROP_COMPLETE',\n  payload: args\n});\nconst drop = args => ({\n  type: 'DROP',\n  payload: args\n});\nconst dropPending = args => ({\n  type: 'DROP_PENDING',\n  payload: args\n});\nconst dropAnimationFinished = () => ({\n  type: 'DROP_ANIMATION_FINISHED',\n  payload: null\n});\n\nfunction checkIndexes(insideDestination) {\n  if (insideDestination.length <= 1) {\n    return;\n  }\n  const indexes = insideDestination.map(d => d.descriptor.index);\n  const errors = {};\n  for (let i = 1; i < indexes.length; i++) {\n    const current = indexes[i];\n    const previous = indexes[i - 1];\n    if (current !== previous + 1) {\n      errors[current] = true;\n    }\n  }\n  if (!Object.keys(errors).length) {\n    return;\n  }\n  const formatted = indexes.map(index => {\n    const hasError = Boolean(errors[index]);\n    return hasError ? `[🔥${index}]` : `${index}`;\n  }).join(', ');\n   true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n  if (true) {\n    const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n    checkIndexes(insideDestination);\n  }\n}\n\nvar lift = marshal => ({\n  getState,\n  dispatch\n}) => next => action => {\n  if (!guard(action, 'LIFT')) {\n    next(action);\n    return;\n  }\n  const {\n    id,\n    clientSelection,\n    movementMode\n  } = action.payload;\n  const initial = getState();\n  if (initial.phase === 'DROP_ANIMATING') {\n    dispatch(completeDrop({\n      completed: initial.completed\n    }));\n  }\n  !(getState().phase === 'IDLE') ?  true ? invariant(false, 'Unexpected phase to start a drag') : 0 : void 0;\n  dispatch(flush());\n  dispatch(beforeInitialCapture({\n    draggableId: id,\n    movementMode\n  }));\n  const scrollOptions = {\n    shouldPublishImmediately: movementMode === 'SNAP'\n  };\n  const request = {\n    draggableId: id,\n    scrollOptions\n  };\n  const {\n    critical,\n    dimensions,\n    viewport\n  } = marshal.startPublishing(request);\n  validateDimensions(critical, dimensions);\n  dispatch(initialPublish({\n    critical,\n    dimensions,\n    clientSelection,\n    movementMode,\n    viewport\n  }));\n};\n\nvar style = marshal => () => next => action => {\n  if (guard(action, 'INITIAL_PUBLISH')) {\n    marshal.dragging();\n  }\n  if (guard(action, 'DROP_ANIMATE')) {\n    marshal.dropping(action.payload.completed.result.reason);\n  }\n  if (guard(action, 'FLUSH') || guard(action, 'DROP_COMPLETE')) {\n    marshal.resting();\n  }\n  next(action);\n};\n\nconst curves = {\n  outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',\n  drop: 'cubic-bezier(.2,1,.1,1)'\n};\nconst combine = {\n  opacity: {\n    drop: 0,\n    combining: 0.7\n  },\n  scale: {\n    drop: 0.75\n  }\n};\nconst timings = {\n  outOfTheWay: 0.2,\n  minDropTime: 0.33,\n  maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n  fluid: `opacity ${outOfTheWayTiming}`,\n  snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n  drop: duration => {\n    const timing = `${duration}s ${curves.drop}`;\n    return `transform ${timing}, opacity ${timing}`;\n  },\n  outOfTheWay: `transform ${outOfTheWayTiming}`,\n  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = offset => isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n  moveTo,\n  drop: (offset, isCombining) => {\n    const translate = moveTo(offset);\n    if (!translate) {\n      return undefined;\n    }\n    if (!isCombining) {\n      return translate;\n    }\n    return `${translate} scale(${combine.scale.drop})`;\n  }\n};\n\nconst {\n  minDropTime,\n  maxDropTime\n} = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({\n  current,\n  destination,\n  reason\n}) => {\n  const distance$1 = distance(current, destination);\n  if (distance$1 <= 0) {\n    return minDropTime;\n  }\n  if (distance$1 >= maxDropTimeAtDistance) {\n    return maxDropTime;\n  }\n  const percentage = distance$1 / maxDropTimeAtDistance;\n  const duration = minDropTime + dropTimeRange * percentage;\n  const withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;\n  return Number(withDuration.toFixed(2));\n};\n\nvar getNewHomeClientOffset = ({\n  impact,\n  draggable,\n  dimensions,\n  viewport,\n  afterCritical\n}) => {\n  const {\n    draggables,\n    droppables\n  } = dimensions;\n  const droppableId = whatIsDraggedOver(impact);\n  const destination = droppableId ? droppables[droppableId] : null;\n  const home = droppables[draggable.descriptor.droppableId];\n  const newClientCenter = getClientBorderBoxCenter({\n    impact,\n    draggable,\n    draggables,\n    afterCritical,\n    droppable: destination || home,\n    viewport\n  });\n  const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n  return offset;\n};\n\nvar getDropImpact = ({\n  draggables,\n  reason,\n  lastImpact,\n  home,\n  viewport,\n  onLiftImpact\n}) => {\n  if (!lastImpact.at || reason !== 'DROP') {\n    const recomputedHomeImpact = recompute({\n      draggables,\n      impact: onLiftImpact,\n      destination: home,\n      viewport,\n      forceShouldAnimate: true\n    });\n    return {\n      impact: recomputedHomeImpact,\n      didDropInsideDroppable: false\n    };\n  }\n  if (lastImpact.at.type === 'REORDER') {\n    return {\n      impact: lastImpact,\n      didDropInsideDroppable: true\n    };\n  }\n  const withoutMovement = {\n    ...lastImpact,\n    displaced: emptyGroups\n  };\n  return {\n    impact: withoutMovement,\n    didDropInsideDroppable: true\n  };\n};\n\nconst dropMiddleware = ({\n  getState,\n  dispatch\n}) => next => action => {\n  if (!guard(action, 'DROP')) {\n    next(action);\n    return;\n  }\n  const state = getState();\n  const reason = action.payload.reason;\n  if (state.phase === 'COLLECTING') {\n    dispatch(dropPending({\n      reason\n    }));\n    return;\n  }\n  if (state.phase === 'IDLE') {\n    return;\n  }\n  const isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;\n  !!isWaitingForDrop ?  true ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : 0 : void 0;\n  !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n  const critical = state.critical;\n  const dimensions = state.dimensions;\n  const draggable = dimensions.draggables[state.critical.draggable.id];\n  const {\n    impact,\n    didDropInsideDroppable\n  } = getDropImpact({\n    reason,\n    lastImpact: state.impact,\n    afterCritical: state.afterCritical,\n    onLiftImpact: state.onLiftImpact,\n    home: state.dimensions.droppables[state.critical.droppable.id],\n    viewport: state.viewport,\n    draggables: state.dimensions.draggables\n  });\n  const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n  const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n  const source = {\n    index: critical.draggable.index,\n    droppableId: critical.droppable.id\n  };\n  const result = {\n    draggableId: draggable.descriptor.id,\n    type: draggable.descriptor.type,\n    source,\n    reason,\n    mode: state.movementMode,\n    destination,\n    combine\n  };\n  const newHomeClientOffset = getNewHomeClientOffset({\n    impact,\n    draggable,\n    dimensions,\n    viewport: state.viewport,\n    afterCritical: state.afterCritical\n  });\n  const completed = {\n    critical: state.critical,\n    afterCritical: state.afterCritical,\n    result,\n    impact\n  };\n  const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n  if (!isAnimationRequired) {\n    dispatch(completeDrop({\n      completed\n    }));\n    return;\n  }\n  const dropDuration = getDropDuration({\n    current: state.current.client.offset,\n    destination: newHomeClientOffset,\n    reason\n  });\n  const args = {\n    newHomeClientOffset,\n    dropDuration,\n    completed\n  };\n  dispatch(animateDrop(args));\n};\n\nvar getWindowScroll = () => ({\n  x: window.pageXOffset,\n  y: window.pageYOffset\n});\n\nfunction getWindowScrollBinding(update) {\n  return {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: event => {\n      if (event.target !== window && event.target !== window.document) {\n        return;\n      }\n      update();\n    }\n  };\n}\nfunction getScrollListener({\n  onWindowScroll\n}) {\n  function updateScroll() {\n    onWindowScroll(getWindowScroll());\n  }\n  const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll);\n  const binding = getWindowScrollBinding(scheduled);\n  let unbind = noop$2;\n  function isActive() {\n    return unbind !== noop$2;\n  }\n  function start() {\n    !!isActive() ?  true ? invariant(false, 'Cannot start scroll listener when already active') : 0 : void 0;\n    unbind = bindEvents(window, [binding]);\n  }\n  function stop() {\n    !isActive() ?  true ? invariant(false, 'Cannot stop scroll listener when not active') : 0 : void 0;\n    scheduled.cancel();\n    unbind();\n    unbind = noop$2;\n  }\n  return {\n    start,\n    stop,\n    isActive\n  };\n}\n\nconst shouldStop$1 = action => guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATE') || guard(action, 'FLUSH');\nconst scrollListener = store => {\n  const listener = getScrollListener({\n    onWindowScroll: newScroll => {\n      store.dispatch(moveByWindowScroll({\n        newScroll\n      }));\n    }\n  });\n  return next => action => {\n    if (!listener.isActive() && guard(action, 'INITIAL_PUBLISH')) {\n      listener.start();\n    }\n    if (listener.isActive() && shouldStop$1(action)) {\n      listener.stop();\n    }\n    next(action);\n  };\n};\n\nvar getExpiringAnnounce = announce => {\n  let wasCalled = false;\n  let isExpired = false;\n  const timeoutId = setTimeout(() => {\n    isExpired = true;\n  });\n  const result = message => {\n    if (wasCalled) {\n       true ? warning('Announcement already made. Not making a second announcement') : 0;\n      return;\n    }\n    if (isExpired) {\n       true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n      return;\n    }\n    wasCalled = true;\n    announce(message);\n    clearTimeout(timeoutId);\n  };\n  result.wasCalled = () => wasCalled;\n  return result;\n};\n\nvar getAsyncMarshal = () => {\n  const entries = [];\n  const execute = timerId => {\n    const index = entries.findIndex(item => item.timerId === timerId);\n    !(index !== -1) ?  true ? invariant(false, 'Could not find timer') : 0 : void 0;\n    const [entry] = entries.splice(index, 1);\n    entry.callback();\n  };\n  const add = fn => {\n    const timerId = setTimeout(() => execute(timerId));\n    const entry = {\n      timerId,\n      callback: fn\n    };\n    entries.push(entry);\n  };\n  const flush = () => {\n    if (!entries.length) {\n      return;\n    }\n    const shallow = [...entries];\n    entries.length = 0;\n    shallow.forEach(entry => {\n      clearTimeout(entry.timerId);\n      entry.callback();\n    });\n  };\n  return {\n    add,\n    flush\n  };\n};\n\nconst areLocationsEqual = (first, second) => {\n  if (first == null && second == null) {\n    return true;\n  }\n  if (first == null || second == null) {\n    return false;\n  }\n  return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second) => {\n  if (first == null && second == null) {\n    return true;\n  }\n  if (first == null || second == null) {\n    return false;\n  }\n  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second) => {\n  if (first === second) {\n    return true;\n  }\n  const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n  const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n  return isDraggableEqual && isDroppableEqual;\n};\n\nconst withTimings = (key, fn) => {\n  start();\n  fn();\n  finish();\n};\nconst getDragStart = (critical, mode) => ({\n  draggableId: critical.draggable.id,\n  type: critical.droppable.type,\n  source: {\n    droppableId: critical.droppable.id,\n    index: critical.draggable.index\n  },\n  mode\n});\nfunction execute(responder, data, announce, getDefaultMessage) {\n  if (!responder) {\n    announce(getDefaultMessage(data));\n    return;\n  }\n  const willExpire = getExpiringAnnounce(announce);\n  const provided = {\n    announce: willExpire\n  };\n  responder(data, provided);\n  if (!willExpire.wasCalled()) {\n    announce(getDefaultMessage(data));\n  }\n}\nvar getPublisher = (getResponders, announce) => {\n  const asyncMarshal = getAsyncMarshal();\n  let dragging = null;\n  const beforeCapture = (draggableId, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeCapture as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeCapture', () => {\n      const fn = getResponders().onBeforeCapture;\n      if (fn) {\n        const before = {\n          draggableId,\n          mode\n        };\n        fn(before);\n      }\n    });\n  };\n  const beforeStart = (critical, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    withTimings('onBeforeDragStart', () => {\n      const fn = getResponders().onBeforeDragStart;\n      if (fn) {\n        fn(getDragStart(critical, mode));\n      }\n    });\n  };\n  const start = (critical, mode) => {\n    !!dragging ?  true ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : 0 : void 0;\n    const data = getDragStart(critical, mode);\n    dragging = {\n      mode,\n      lastCritical: critical,\n      lastLocation: data.source,\n      lastCombine: null\n    };\n    asyncMarshal.add(() => {\n      withTimings('onDragStart', () => execute(getResponders().onDragStart, data, announce, preset.onDragStart));\n    });\n  };\n  const update = (critical, impact) => {\n    const location = tryGetDestination(impact);\n    const combine = tryGetCombine(impact);\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : 0 : void 0;\n    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n    if (hasCriticalChanged) {\n      dragging.lastCritical = critical;\n    }\n    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n    if (hasLocationChanged) {\n      dragging.lastLocation = location;\n    }\n    const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n    if (hasGroupingChanged) {\n      dragging.lastCombine = combine;\n    }\n    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n      return;\n    }\n    const data = {\n      ...getDragStart(critical, dragging.mode),\n      combine,\n      destination: location\n    };\n    asyncMarshal.add(() => {\n      withTimings('onDragUpdate', () => execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));\n    });\n  };\n  const flush = () => {\n    !dragging ?  true ? invariant(false, 'Can only flush responders while dragging') : 0 : void 0;\n    asyncMarshal.flush();\n  };\n  const drop = result => {\n    !dragging ?  true ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : 0 : void 0;\n    dragging = null;\n    withTimings('onDragEnd', () => execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));\n  };\n  const abort = () => {\n    if (!dragging) {\n      return;\n    }\n    const result = {\n      ...getDragStart(dragging.lastCritical, dragging.mode),\n      combine: null,\n      destination: null,\n      reason: 'CANCEL'\n    };\n    drop(result);\n  };\n  return {\n    beforeCapture,\n    beforeStart,\n    start,\n    update,\n    flush,\n    drop,\n    abort\n  };\n};\n\nvar responders = (getResponders, announce) => {\n  const publisher = getPublisher(getResponders, announce);\n  return store => next => action => {\n    if (guard(action, 'BEFORE_INITIAL_CAPTURE')) {\n      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n      return;\n    }\n    if (guard(action, 'INITIAL_PUBLISH')) {\n      const critical = action.payload.critical;\n      publisher.beforeStart(critical, action.payload.movementMode);\n      next(action);\n      publisher.start(critical, action.payload.movementMode);\n      return;\n    }\n    if (guard(action, 'DROP_COMPLETE')) {\n      const result = action.payload.completed.result;\n      publisher.flush();\n      next(action);\n      publisher.drop(result);\n      return;\n    }\n    next(action);\n    if (guard(action, 'FLUSH')) {\n      publisher.abort();\n      return;\n    }\n    const state = store.getState();\n    if (state.phase === 'DRAGGING') {\n      publisher.update(state.critical, state.impact);\n    }\n  };\n};\n\nconst dropAnimationFinishMiddleware = store => next => action => {\n  if (!guard(action, 'DROP_ANIMATION_FINISHED')) {\n    next(action);\n    return;\n  }\n  const state = store.getState();\n  !(state.phase === 'DROP_ANIMATING') ?  true ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : 0 : void 0;\n  store.dispatch(completeDrop({\n    completed: state.completed\n  }));\n};\n\nconst dropAnimationFlushOnScrollMiddleware = store => {\n  let unbind = null;\n  let frameId = null;\n  function clear() {\n    if (frameId) {\n      cancelAnimationFrame(frameId);\n      frameId = null;\n    }\n    if (unbind) {\n      unbind();\n      unbind = null;\n    }\n  }\n  return next => action => {\n    if (guard(action, 'FLUSH') || guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATION_FINISHED')) {\n      clear();\n    }\n    next(action);\n    if (!guard(action, 'DROP_ANIMATE')) {\n      return;\n    }\n    const binding = {\n      eventName: 'scroll',\n      options: {\n        capture: true,\n        passive: false,\n        once: true\n      },\n      fn: function flushDropAnimation() {\n        const state = store.getState();\n        if (state.phase === 'DROP_ANIMATING') {\n          store.dispatch(dropAnimationFinished());\n        }\n      }\n    };\n    frameId = requestAnimationFrame(() => {\n      frameId = null;\n      unbind = bindEvents(window, [binding]);\n    });\n  };\n};\n\nvar dimensionMarshalStopper = marshal => () => next => action => {\n  if (guard(action, 'DROP_COMPLETE') || guard(action, 'FLUSH') || guard(action, 'DROP_ANIMATE')) {\n    marshal.stopPublishing();\n  }\n  next(action);\n};\n\nvar focus = marshal => {\n  let isWatching = false;\n  return () => next => action => {\n    if (guard(action, 'INITIAL_PUBLISH')) {\n      isWatching = true;\n      marshal.tryRecordFocus(action.payload.critical.draggable.id);\n      next(action);\n      marshal.tryRestoreFocusRecorded();\n      return;\n    }\n    next(action);\n    if (!isWatching) {\n      return;\n    }\n    if (guard(action, 'FLUSH')) {\n      isWatching = false;\n      marshal.tryRestoreFocusRecorded();\n      return;\n    }\n    if (guard(action, 'DROP_COMPLETE')) {\n      isWatching = false;\n      const result = action.payload.completed.result;\n      if (result.combine) {\n        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n      }\n      marshal.tryRestoreFocusRecorded();\n    }\n  };\n};\n\nconst shouldStop = action => guard(action, 'DROP_COMPLETE') || guard(action, 'DROP_ANIMATE') || guard(action, 'FLUSH');\nvar autoScroll = autoScroller => store => next => action => {\n  if (shouldStop(action)) {\n    autoScroller.stop();\n    next(action);\n    return;\n  }\n  if (guard(action, 'INITIAL_PUBLISH')) {\n    next(action);\n    const state = store.getState();\n    !(state.phase === 'DRAGGING') ?  true ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : 0 : void 0;\n    autoScroller.start(state);\n    return;\n  }\n  next(action);\n  autoScroller.scroll(store.getState());\n};\n\nconst pendingDrop = store => next => action => {\n  next(action);\n  if (!guard(action, 'PUBLISH_WHILE_DRAGGING')) {\n    return;\n  }\n  const postActionState = store.getState();\n  if (postActionState.phase !== 'DROP_PENDING') {\n    return;\n  }\n  if (postActionState.isWaiting) {\n    return;\n  }\n  store.dispatch(drop({\n    reason: postActionState.reason\n  }));\n};\n\nconst composeEnhancers =  true && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n  name: '@hello-pangea/dnd'\n}) : redux__WEBPACK_IMPORTED_MODULE_5__.compose;\nvar createStore = ({\n  dimensionMarshal,\n  focusMarshal,\n  styleMarshal,\n  getResponders,\n  announce,\n  autoScroller\n}) => (0,redux__WEBPACK_IMPORTED_MODULE_5__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_5__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n\nconst clean$1 = () => ({\n  additions: {},\n  removals: {},\n  modified: {}\n});\nfunction createPublisher({\n  registry,\n  callbacks\n}) {\n  let staging = clean$1();\n  let frameId = null;\n  const collect = () => {\n    if (frameId) {\n      return;\n    }\n    callbacks.collectionStarting();\n    frameId = requestAnimationFrame(() => {\n      frameId = null;\n      start();\n      const {\n        additions,\n        removals,\n        modified\n      } = staging;\n      const added = Object.keys(additions).map(id => registry.draggable.getById(id).getDimension(origin)).sort((a, b) => a.descriptor.index - b.descriptor.index);\n      const updated = Object.keys(modified).map(id => {\n        const entry = registry.droppable.getById(id);\n        const scroll = entry.callbacks.getScrollWhileDragging();\n        return {\n          droppableId: id,\n          scroll\n        };\n      });\n      const result = {\n        additions: added,\n        removals: Object.keys(removals),\n        modified: updated\n      };\n      staging = clean$1();\n      finish();\n      callbacks.publish(result);\n    });\n  };\n  const add = entry => {\n    const id = entry.descriptor.id;\n    staging.additions[id] = entry;\n    staging.modified[entry.descriptor.droppableId] = true;\n    if (staging.removals[id]) {\n      delete staging.removals[id];\n    }\n    collect();\n  };\n  const remove = entry => {\n    const descriptor = entry.descriptor;\n    staging.removals[descriptor.id] = true;\n    staging.modified[descriptor.droppableId] = true;\n    if (staging.additions[descriptor.id]) {\n      delete staging.additions[descriptor.id];\n    }\n    collect();\n  };\n  const stop = () => {\n    if (!frameId) {\n      return;\n    }\n    cancelAnimationFrame(frameId);\n    frameId = null;\n    staging = clean$1();\n  };\n  return {\n    add,\n    remove,\n    stop\n  };\n}\n\nvar getMaxScroll = ({\n  scrollHeight,\n  scrollWidth,\n  height,\n  width\n}) => {\n  const maxScroll = subtract({\n    x: scrollWidth,\n    y: scrollHeight\n  }, {\n    x: width,\n    y: height\n  });\n  const adjustedMaxScroll = {\n    x: Math.max(0, maxScroll.x),\n    y: Math.max(0, maxScroll.y)\n  };\n  return adjustedMaxScroll;\n};\n\nvar getDocumentElement = () => {\n  const doc = document.documentElement;\n  !doc ?  true ? invariant(false, 'Cannot find document.documentElement') : 0 : void 0;\n  return doc;\n};\n\nvar getMaxWindowScroll = () => {\n  const doc = getDocumentElement();\n  const maxScroll = getMaxScroll({\n    scrollHeight: doc.scrollHeight,\n    scrollWidth: doc.scrollWidth,\n    width: doc.clientWidth,\n    height: doc.clientHeight\n  });\n  return maxScroll;\n};\n\nvar getViewport = () => {\n  const scroll = getWindowScroll();\n  const maxScroll = getMaxWindowScroll();\n  const top = scroll.y;\n  const left = scroll.x;\n  const doc = getDocumentElement();\n  const width = doc.clientWidth;\n  const height = doc.clientHeight;\n  const right = left + width;\n  const bottom = top + height;\n  const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n    top,\n    left,\n    right,\n    bottom\n  });\n  const viewport = {\n    frame,\n    scroll: {\n      initial: scroll,\n      current: scroll,\n      max: maxScroll,\n      diff: {\n        value: origin,\n        displacement: origin\n      }\n    }\n  };\n  return viewport;\n};\n\nvar getInitialPublish = ({\n  critical,\n  scrollOptions,\n  registry\n}) => {\n  start();\n  const viewport = getViewport();\n  const windowScroll = viewport.scroll.current;\n  const home = critical.droppable;\n  const droppables = registry.droppable.getAllByType(home.type).map(entry => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n  const draggables = registry.draggable.getAllByType(critical.draggable.type).map(entry => entry.getDimension(windowScroll));\n  const dimensions = {\n    draggables: toDraggableMap(draggables),\n    droppables: toDroppableMap(droppables)\n  };\n  finish();\n  const result = {\n    dimensions,\n    critical,\n    viewport\n  };\n  return result;\n};\n\nfunction shouldPublishUpdate(registry, dragging, entry) {\n  if (entry.descriptor.id === dragging.id) {\n    return false;\n  }\n  if (entry.descriptor.type !== dragging.type) {\n    return false;\n  }\n  const home = registry.droppable.getById(entry.descriptor.droppableId);\n  if (home.descriptor.mode !== 'virtual') {\n     true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n    return false;\n  }\n  return true;\n}\nvar createDimensionMarshal = (registry, callbacks) => {\n  let collection = null;\n  const publisher = createPublisher({\n    callbacks: {\n      publish: callbacks.publishWhileDragging,\n      collectionStarting: callbacks.collectionStarting\n    },\n    registry\n  });\n  const updateDroppableIsEnabled = (id, isEnabled) => {\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n    if (!collection) {\n      return;\n    }\n    callbacks.updateDroppableIsEnabled({\n      id,\n      isEnabled\n    });\n  };\n  const updateDroppableIsCombineEnabled = (id, isCombineEnabled) => {\n    if (!collection) {\n      return;\n    }\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n    callbacks.updateDroppableIsCombineEnabled({\n      id,\n      isCombineEnabled\n    });\n  };\n  const updateDroppableScroll = (id, newScroll) => {\n    if (!collection) {\n      return;\n    }\n    !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n    callbacks.updateDroppableScroll({\n      id,\n      newScroll\n    });\n  };\n  const scrollDroppable = (id, change) => {\n    if (!collection) {\n      return;\n    }\n    registry.droppable.getById(id).callbacks.scroll(change);\n  };\n  const stopPublishing = () => {\n    if (!collection) {\n      return;\n    }\n    publisher.stop();\n    const home = collection.critical.droppable;\n    registry.droppable.getAllByType(home.type).forEach(entry => entry.callbacks.dragStopped());\n    collection.unsubscribe();\n    collection = null;\n  };\n  const subscriber = event => {\n    !collection ?  true ? invariant(false, 'Should only be subscribed when a collection is occurring') : 0 : void 0;\n    const dragging = collection.critical.draggable;\n    if (event.type === 'ADDITION') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.add(event.value);\n      }\n    }\n    if (event.type === 'REMOVAL') {\n      if (shouldPublishUpdate(registry, dragging, event.value)) {\n        publisher.remove(event.value);\n      }\n    }\n  };\n  const startPublishing = request => {\n    !!collection ?  true ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : 0 : void 0;\n    const entry = registry.draggable.getById(request.draggableId);\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    const critical = {\n      draggable: entry.descriptor,\n      droppable: home.descriptor\n    };\n    const unsubscribe = registry.subscribe(subscriber);\n    collection = {\n      critical,\n      unsubscribe\n    };\n    return getInitialPublish({\n      critical,\n      registry,\n      scrollOptions: request.scrollOptions\n    });\n  };\n  const marshal = {\n    updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled,\n    scrollDroppable,\n    updateDroppableScroll,\n    startPublishing,\n    stopPublishing\n  };\n  return marshal;\n};\n\nvar canStartDrag = (state, id) => {\n  if (state.phase === 'IDLE') {\n    return true;\n  }\n  if (state.phase !== 'DROP_ANIMATING') {\n    return false;\n  }\n  if (state.completed.result.draggableId === id) {\n    return false;\n  }\n  return state.completed.result.reason === 'DROP';\n};\n\nvar scrollWindow = change => {\n  window.scrollBy(change.x, change.y);\n};\n\nconst getScrollableDroppables = memoizeOne(droppables => toDroppableList(droppables).filter(droppable => {\n  if (!droppable.isEnabled) {\n    return false;\n  }\n  if (!droppable.frame) {\n    return false;\n  }\n  return true;\n}));\nconst getScrollableDroppableOver = (target, droppables) => {\n  const maybe = getScrollableDroppables(droppables).find(droppable => {\n    !droppable.frame ?  true ? invariant(false, 'Invalid result') : 0 : void 0;\n    return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n  }) || null;\n  return maybe;\n};\nvar getBestScrollableDroppable = ({\n  center,\n  destination,\n  droppables\n}) => {\n  if (destination) {\n    const dimension = droppables[destination];\n    if (!dimension.frame) {\n      return null;\n    }\n    return dimension;\n  }\n  const dimension = getScrollableDroppableOver(center, droppables);\n  return dimension;\n};\n\nconst defaultAutoScrollerOptions = {\n  startFromPercentage: 0.25,\n  maxScrollAtPercentage: 0.05,\n  maxPixelScroll: 28,\n  ease: percentage => percentage ** 2,\n  durationDampening: {\n    stopDampeningAt: 1200,\n    accelerateAt: 360\n  },\n  disabled: false\n};\n\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n  const thresholds = {\n    startScrollingFrom,\n    maxScrollValueAt\n  };\n  return thresholds;\n};\n\nvar getPercentage = ({\n  startOfRange,\n  endOfRange,\n  current\n}) => {\n  const range = endOfRange - startOfRange;\n  if (range === 0) {\n     true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n    return 0;\n  }\n  const currentInRange = current - startOfRange;\n  const percentage = currentInRange / range;\n  return percentage;\n};\n\nvar minScroll = 1;\n\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  if (distanceToEdge > thresholds.startScrollingFrom) {\n    return 0;\n  }\n  if (distanceToEdge <= thresholds.maxScrollValueAt) {\n    return autoScrollerOptions.maxPixelScroll;\n  }\n  if (distanceToEdge === thresholds.startScrollingFrom) {\n    return minScroll;\n  }\n  const percentageFromMaxScrollValueAt = getPercentage({\n    startOfRange: thresholds.maxScrollValueAt,\n    endOfRange: thresholds.startScrollingFrom,\n    current: distanceToEdge\n  });\n  const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n  const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n  return Math.ceil(scroll);\n};\n\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions) => {\n  const autoScrollerOptions = getAutoScrollerOptions();\n  const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n  const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n  const startOfRange = dragStartTime;\n  const endOfRange = stopAt;\n  const now = Date.now();\n  const runTime = now - startOfRange;\n  if (runTime >= stopAt) {\n    return proposedScroll;\n  }\n  if (runTime < accelerateAt) {\n    return minScroll;\n  }\n  const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n    startOfRange: accelerateAt,\n    endOfRange,\n    current: runTime\n  });\n  const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n  return Math.ceil(scroll);\n};\n\nvar getValue = ({\n  distanceToEdge,\n  thresholds,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n  if (scroll === 0) {\n    return 0;\n  }\n  if (!shouldUseTimeDampening) {\n    return scroll;\n  }\n  return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\n\nvar getScrollOnAxis = ({\n  container,\n  distanceToEdges,\n  dragStartTime,\n  axis,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n  const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n  if (isCloserToEnd) {\n    return getValue({\n      distanceToEdge: distanceToEdges[axis.end],\n      thresholds,\n      dragStartTime,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n  }\n  return -1 * getValue({\n    distanceToEdge: distanceToEdges[axis.start],\n    thresholds,\n    dragStartTime,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n};\n\nvar adjustForSizeLimits = ({\n  container,\n  subject,\n  proposedScroll\n}) => {\n  const isTooBigVertically = subject.height > container.height;\n  const isTooBigHorizontally = subject.width > container.width;\n  if (!isTooBigHorizontally && !isTooBigVertically) {\n    return proposedScroll;\n  }\n  if (isTooBigHorizontally && isTooBigVertically) {\n    return null;\n  }\n  return {\n    x: isTooBigHorizontally ? 0 : proposedScroll.x,\n    y: isTooBigVertically ? 0 : proposedScroll.y\n  };\n};\n\nconst clean = apply(value => value === 0 ? 0 : value);\nvar getScroll$1 = ({\n  dragStartTime,\n  container,\n  subject,\n  center,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const distanceToEdges = {\n    top: center.y - container.top,\n    right: container.right - center.x,\n    bottom: container.bottom - center.y,\n    left: center.x - container.left\n  };\n  const y = getScrollOnAxis({\n    container,\n    distanceToEdges,\n    dragStartTime,\n    axis: vertical,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  const x = getScrollOnAxis({\n    container,\n    distanceToEdges,\n    dragStartTime,\n    axis: horizontal,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  const required = clean({\n    x,\n    y\n  });\n  if (isEqual$1(required, origin)) {\n    return null;\n  }\n  const limited = adjustForSizeLimits({\n    container,\n    subject,\n    proposedScroll: required\n  });\n  if (!limited) {\n    return null;\n  }\n  return isEqual$1(limited, origin) ? null : limited;\n};\n\nconst smallestSigned = apply(value => {\n  if (value === 0) {\n    return 0;\n  }\n  return value > 0 ? 1 : -1;\n});\nconst getOverlap = (() => {\n  const getRemainder = (target, max) => {\n    if (target < 0) {\n      return target;\n    }\n    if (target > max) {\n      return target - max;\n    }\n    return 0;\n  };\n  return ({\n    current,\n    max,\n    change\n  }) => {\n    const targetScroll = add(current, change);\n    const overlap = {\n      x: getRemainder(targetScroll.x, max.x),\n      y: getRemainder(targetScroll.y, max.y)\n    };\n    if (isEqual$1(overlap, origin)) {\n      return null;\n    }\n    return overlap;\n  };\n})();\nconst canPartiallyScroll = ({\n  max: rawMax,\n  current,\n  change\n}) => {\n  const max = {\n    x: Math.max(current.x, rawMax.x),\n    y: Math.max(current.y, rawMax.y)\n  };\n  const smallestChange = smallestSigned(change);\n  const overlap = getOverlap({\n    max,\n    current,\n    change: smallestChange\n  });\n  if (!overlap) {\n    return true;\n  }\n  if (smallestChange.x !== 0 && overlap.x === 0) {\n    return true;\n  }\n  if (smallestChange.y !== 0 && overlap.y === 0) {\n    return true;\n  }\n  return false;\n};\nconst canScrollWindow = (viewport, change) => canPartiallyScroll({\n  current: viewport.scroll.current,\n  max: viewport.scroll.max,\n  change\n});\nconst getWindowOverlap = (viewport, change) => {\n  if (!canScrollWindow(viewport, change)) {\n    return null;\n  }\n  const max = viewport.scroll.max;\n  const current = viewport.scroll.current;\n  return getOverlap({\n    current,\n    max,\n    change\n  });\n};\nconst canScrollDroppable = (droppable, change) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return false;\n  }\n  return canPartiallyScroll({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change\n  });\n};\nconst getDroppableOverlap = (droppable, change) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return null;\n  }\n  if (!canScrollDroppable(droppable, change)) {\n    return null;\n  }\n  return getOverlap({\n    current: frame.scroll.current,\n    max: frame.scroll.max,\n    change\n  });\n};\n\nvar getWindowScrollChange = ({\n  viewport,\n  subject,\n  center,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const scroll = getScroll$1({\n    dragStartTime,\n    container: viewport.frame,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\n\nvar getDroppableScrollChange = ({\n  droppable,\n  subject,\n  center,\n  dragStartTime,\n  shouldUseTimeDampening,\n  getAutoScrollerOptions\n}) => {\n  const frame = droppable.frame;\n  if (!frame) {\n    return null;\n  }\n  const scroll = getScroll$1({\n    dragStartTime,\n    container: frame.pageMarginBox,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\n\nvar scroll = ({\n  state,\n  dragStartTime,\n  shouldUseTimeDampening,\n  scrollWindow,\n  scrollDroppable,\n  getAutoScrollerOptions\n}) => {\n  const center = state.current.page.borderBoxCenter;\n  const draggable = state.dimensions.draggables[state.critical.draggable.id];\n  const subject = draggable.page.marginBox;\n  if (state.isWindowScrollAllowed) {\n    const viewport = state.viewport;\n    const change = getWindowScrollChange({\n      dragStartTime,\n      viewport,\n      subject,\n      center,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n    if (change) {\n      scrollWindow(change);\n      return;\n    }\n  }\n  const droppable = getBestScrollableDroppable({\n    center,\n    destination: whatIsDraggedOver(state.impact),\n    droppables: state.dimensions.droppables\n  });\n  if (!droppable) {\n    return;\n  }\n  const change = getDroppableScrollChange({\n    dragStartTime,\n    droppable,\n    subject,\n    center,\n    shouldUseTimeDampening,\n    getAutoScrollerOptions\n  });\n  if (change) {\n    scrollDroppable(droppable.descriptor.id, change);\n  }\n};\n\nvar createFluidScroller = ({\n  scrollWindow,\n  scrollDroppable,\n  getAutoScrollerOptions = () => defaultAutoScrollerOptions\n}) => {\n  const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollWindow);\n  const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollDroppable);\n  let dragging = null;\n  const tryScroll = state => {\n    !dragging ?  true ? invariant(false, 'Cannot fluid scroll if not dragging') : 0 : void 0;\n    const {\n      shouldUseTimeDampening,\n      dragStartTime\n    } = dragging;\n    scroll({\n      state,\n      scrollWindow: scheduleWindowScroll,\n      scrollDroppable: scheduleDroppableScroll,\n      dragStartTime,\n      shouldUseTimeDampening,\n      getAutoScrollerOptions\n    });\n  };\n  const start$1 = state => {\n    start();\n    !!dragging ?  true ? invariant(false, 'Cannot start auto scrolling when already started') : 0 : void 0;\n    const dragStartTime = Date.now();\n    let wasScrollNeeded = false;\n    const fakeScrollCallback = () => {\n      wasScrollNeeded = true;\n    };\n    scroll({\n      state,\n      dragStartTime: 0,\n      shouldUseTimeDampening: false,\n      scrollWindow: fakeScrollCallback,\n      scrollDroppable: fakeScrollCallback,\n      getAutoScrollerOptions\n    });\n    dragging = {\n      dragStartTime,\n      shouldUseTimeDampening: wasScrollNeeded\n    };\n    finish();\n    if (wasScrollNeeded) {\n      tryScroll(state);\n    }\n  };\n  const stop = () => {\n    if (!dragging) {\n      return;\n    }\n    scheduleWindowScroll.cancel();\n    scheduleDroppableScroll.cancel();\n    dragging = null;\n  };\n  return {\n    start: start$1,\n    stop,\n    scroll: tryScroll\n  };\n};\n\nvar createJumpScroller = ({\n  move,\n  scrollDroppable,\n  scrollWindow\n}) => {\n  const moveByOffset = (state, offset) => {\n    const client = add(state.current.client.selection, offset);\n    move({\n      client\n    });\n  };\n  const scrollDroppableAsMuchAsItCan = (droppable, change) => {\n    if (!canScrollDroppable(droppable, change)) {\n      return change;\n    }\n    const overlap = getDroppableOverlap(droppable, change);\n    if (!overlap) {\n      scrollDroppable(droppable.descriptor.id, change);\n      return null;\n    }\n    const whatTheDroppableCanScroll = subtract(change, overlap);\n    scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n    const remainder = subtract(change, whatTheDroppableCanScroll);\n    return remainder;\n  };\n  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change) => {\n    if (!isWindowScrollAllowed) {\n      return change;\n    }\n    if (!canScrollWindow(viewport, change)) {\n      return change;\n    }\n    const overlap = getWindowOverlap(viewport, change);\n    if (!overlap) {\n      scrollWindow(change);\n      return null;\n    }\n    const whatTheWindowCanScroll = subtract(change, overlap);\n    scrollWindow(whatTheWindowCanScroll);\n    const remainder = subtract(change, whatTheWindowCanScroll);\n    return remainder;\n  };\n  const jumpScroller = state => {\n    const request = state.scrollJumpRequest;\n    if (!request) {\n      return;\n    }\n    const destination = whatIsDraggedOver(state.impact);\n    !destination ?  true ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : 0 : void 0;\n    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n    if (!droppableRemainder) {\n      return;\n    }\n    const viewport = state.viewport;\n    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n    if (!windowRemainder) {\n      return;\n    }\n    moveByOffset(state, windowRemainder);\n  };\n  return jumpScroller;\n};\n\nvar createAutoScroller = ({\n  scrollDroppable,\n  scrollWindow,\n  move,\n  getAutoScrollerOptions\n}) => {\n  const fluidScroller = createFluidScroller({\n    scrollWindow,\n    scrollDroppable,\n    getAutoScrollerOptions\n  });\n  const jumpScroll = createJumpScroller({\n    move,\n    scrollWindow,\n    scrollDroppable\n  });\n  const scroll = state => {\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (autoScrollerOptions.disabled || state.phase !== 'DRAGGING') {\n      return;\n    }\n    if (state.movementMode === 'FLUID') {\n      fluidScroller.scroll(state);\n      return;\n    }\n    if (!state.scrollJumpRequest) {\n      return;\n    }\n    jumpScroll(state);\n  };\n  const scroller = {\n    scroll,\n    start: fluidScroller.start,\n    stop: fluidScroller.stop\n  };\n  return scroller;\n};\n\nconst prefix = 'data-rfd';\nconst dragHandle = (() => {\n  const base = `${prefix}-drag-handle`;\n  return {\n    base,\n    draggableId: `${base}-draggable-id`,\n    contextId: `${base}-context-id`\n  };\n})();\nconst draggable = (() => {\n  const base = `${prefix}-draggable`;\n  return {\n    base,\n    contextId: `${base}-context-id`,\n    id: `${base}-id`\n  };\n})();\nconst droppable = (() => {\n  const base = `${prefix}-droppable`;\n  return {\n    base,\n    contextId: `${base}-context-id`,\n    id: `${base}-id`\n  };\n})();\nconst scrollContainer = {\n  contextId: `${prefix}-scroll-container-context-id`\n};\n\nconst makeGetSelector = context => attribute => `[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property) => rules.map(rule => {\n  const value = rule.styles[property];\n  if (!value) {\n    return '';\n  }\n  return `${rule.selector} { ${value} }`;\n}).join(' ');\nconst noPointerEvents = 'pointer-events: none;';\nvar getStyles$1 = contextId => {\n  const getSelector = makeGetSelector(contextId);\n  const dragHandle$1 = (() => {\n    const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n    return {\n      selector: getSelector(dragHandle.contextId),\n      styles: {\n        always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n        resting: grabCursor,\n        dragging: noPointerEvents,\n        dropAnimating: grabCursor\n      }\n    };\n  })();\n  const draggable$1 = (() => {\n    const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n    return {\n      selector: getSelector(draggable.contextId),\n      styles: {\n        dragging: transition,\n        dropAnimating: transition,\n        userCancel: transition\n      }\n    };\n  })();\n  const droppable$1 = {\n    selector: getSelector(droppable.contextId),\n    styles: {\n      always: `overflow-anchor: none;`\n    }\n  };\n  const body = {\n    selector: 'body',\n    styles: {\n      dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n    }\n  };\n  const rules = [draggable$1, dragHandle$1, droppable$1, body];\n  return {\n    always: getStyles(rules, 'always'),\n    resting: getStyles(rules, 'resting'),\n    dragging: getStyles(rules, 'dragging'),\n    dropAnimating: getStyles(rules, 'dropAnimating'),\n    userCancel: getStyles(rules, 'userCancel')\n  };\n};\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\nconst getHead = () => {\n  const head = document.querySelector('head');\n  !head ?  true ? invariant(false, 'Cannot find the head to append a style to') : 0 : void 0;\n  return head;\n};\nconst createStyleEl = nonce => {\n  const el = document.createElement('style');\n  if (nonce) {\n    el.setAttribute('nonce', nonce);\n  }\n  el.type = 'text/css';\n  return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n  const styles = useMemo(() => getStyles$1(contextId), [contextId]);\n  const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const setDynamicStyle = useCallback(memoizeOne(proposed => {\n    const el = dynamicRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }), []);\n  const setAlwaysStyle = useCallback(proposed => {\n    const el = alwaysRef.current;\n    !el ?  true ? invariant(false, 'Cannot set dynamic style element if it is not set') : 0 : void 0;\n    el.textContent = proposed;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, 'style elements already mounted') : 0 : void 0;\n    const always = createStyleEl(nonce);\n    const dynamic = createStyleEl(nonce);\n    alwaysRef.current = always;\n    dynamicRef.current = dynamic;\n    always.setAttribute(`${prefix}-always`, contextId);\n    dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n    getHead().appendChild(always);\n    getHead().appendChild(dynamic);\n    setAlwaysStyle(styles.always);\n    setDynamicStyle(styles.resting);\n    return () => {\n      const remove = ref => {\n        const current = ref.current;\n        !current ?  true ? invariant(false, 'Cannot unmount ref as it is not set') : 0 : void 0;\n        getHead().removeChild(current);\n        ref.current = null;\n      };\n      remove(alwaysRef);\n      remove(dynamicRef);\n    };\n  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);\n  const dragging = useCallback(() => setDynamicStyle(styles.dragging), [setDynamicStyle, styles.dragging]);\n  const dropping = useCallback(reason => {\n    if (reason === 'DROP') {\n      setDynamicStyle(styles.dropAnimating);\n      return;\n    }\n    setDynamicStyle(styles.userCancel);\n  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);\n  const resting = useCallback(() => {\n    if (!dynamicRef.current) {\n      return;\n    }\n    setDynamicStyle(styles.resting);\n  }, [setDynamicStyle, styles.resting]);\n  const marshal = useMemo(() => ({\n    dragging,\n    dropping,\n    resting\n  }), [dragging, dropping, resting]);\n  return marshal;\n}\n\nfunction querySelectorAll(parentNode, selector) {\n  return Array.from(parentNode.querySelectorAll(selector));\n}\n\nvar getWindowFromEl = el => {\n  if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n    return el.ownerDocument.defaultView;\n  }\n  return window;\n};\n\nfunction isHtmlElement(el) {\n  return el instanceof getWindowFromEl(el).HTMLElement;\n}\n\nfunction findDragHandle(contextId, draggableId) {\n  const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n  const possible = querySelectorAll(document, selector);\n  if (!possible.length) {\n     true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n    return null;\n  }\n  const handle = possible.find(el => {\n    return el.getAttribute(dragHandle.draggableId) === draggableId;\n  });\n  if (!handle) {\n     true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n    return null;\n  }\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle needs to be a HTMLElement') : 0;\n    return null;\n  }\n  return handle;\n}\n\nfunction useFocusMarshal(contextId) {\n  const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const register = useCallback(function register(id, focus) {\n    const entry = {\n      id,\n      focus\n    };\n    entriesRef.current[id] = entry;\n    return function unregister() {\n      const entries = entriesRef.current;\n      const current = entries[id];\n      if (current !== entry) {\n        delete entries[id];\n      }\n    };\n  }, []);\n  const tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {\n    const handle = findDragHandle(contextId, tryGiveFocusTo);\n    if (handle && handle !== document.activeElement) {\n      handle.focus();\n    }\n  }, [contextId]);\n  const tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {\n    if (recordRef.current === previous) {\n      recordRef.current = redirectTo;\n    }\n  }, []);\n  const tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {\n    if (restoreFocusFrameRef.current) {\n      return;\n    }\n    if (!isMountedRef.current) {\n      return;\n    }\n    restoreFocusFrameRef.current = requestAnimationFrame(() => {\n      restoreFocusFrameRef.current = null;\n      const record = recordRef.current;\n      if (record) {\n        tryGiveFocus(record);\n      }\n    });\n  }, [tryGiveFocus]);\n  const tryRecordFocus = useCallback(function tryRecordFocus(id) {\n    recordRef.current = null;\n    const focused = document.activeElement;\n    if (!focused) {\n      return;\n    }\n    if (focused.getAttribute(dragHandle.draggableId) !== id) {\n      return;\n    }\n    recordRef.current = id;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    isMountedRef.current = true;\n    return function clearFrameOnUnmount() {\n      isMountedRef.current = false;\n      const frameId = restoreFocusFrameRef.current;\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, []);\n  const marshal = useMemo(() => ({\n    register,\n    tryRecordFocus,\n    tryRestoreFocusRecorded,\n    tryShiftRecord\n  }), [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);\n  return marshal;\n}\n\nfunction createRegistry() {\n  const entries = {\n    draggables: {},\n    droppables: {}\n  };\n  const subscribers = [];\n  function subscribe(cb) {\n    subscribers.push(cb);\n    return function unsubscribe() {\n      const index = subscribers.indexOf(cb);\n      if (index === -1) {\n        return;\n      }\n      subscribers.splice(index, 1);\n    };\n  }\n  function notify(event) {\n    if (subscribers.length) {\n      subscribers.forEach(cb => cb(event));\n    }\n  }\n  function findDraggableById(id) {\n    return entries.draggables[id] || null;\n  }\n  function getDraggableById(id) {\n    const entry = findDraggableById(id);\n    !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n    return entry;\n  }\n  const draggableAPI = {\n    register: entry => {\n      entries.draggables[entry.descriptor.id] = entry;\n      notify({\n        type: 'ADDITION',\n        value: entry\n      });\n    },\n    update: (entry, last) => {\n      const current = entries.draggables[last.descriptor.id];\n      if (!current) {\n        return;\n      }\n      if (current.uniqueId !== entry.uniqueId) {\n        return;\n      }\n      delete entries.draggables[last.descriptor.id];\n      entries.draggables[entry.descriptor.id] = entry;\n    },\n    unregister: entry => {\n      const draggableId = entry.descriptor.id;\n      const current = findDraggableById(draggableId);\n      if (!current) {\n        return;\n      }\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n      delete entries.draggables[draggableId];\n      if (entries.droppables[entry.descriptor.droppableId]) {\n        notify({\n          type: 'REMOVAL',\n          value: entry\n        });\n      }\n    },\n    getById: getDraggableById,\n    findById: findDraggableById,\n    exists: id => Boolean(findDraggableById(id)),\n    getAllByType: type => Object.values(entries.draggables).filter(entry => entry.descriptor.type === type)\n  };\n  function findDroppableById(id) {\n    return entries.droppables[id] || null;\n  }\n  function getDroppableById(id) {\n    const entry = findDroppableById(id);\n    !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n    return entry;\n  }\n  const droppableAPI = {\n    register: entry => {\n      entries.droppables[entry.descriptor.id] = entry;\n    },\n    unregister: entry => {\n      const current = findDroppableById(entry.descriptor.id);\n      if (!current) {\n        return;\n      }\n      if (entry.uniqueId !== current.uniqueId) {\n        return;\n      }\n      delete entries.droppables[entry.descriptor.id];\n    },\n    getById: getDroppableById,\n    findById: findDroppableById,\n    exists: id => Boolean(findDroppableById(id)),\n    getAllByType: type => Object.values(entries.droppables).filter(entry => entry.descriptor.type === type)\n  };\n  function clean() {\n    entries.draggables = {};\n    entries.droppables = {};\n    subscribers.length = 0;\n  }\n  return {\n    draggable: draggableAPI,\n    droppable: droppableAPI,\n    subscribe,\n    clean\n  };\n}\n\nfunction useRegistry() {\n  const registry = useMemo(createRegistry, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return function unmount() {\n      registry.clean();\n    };\n  }, [registry]);\n  return registry;\n}\n\nvar StoreContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nvar getBodyElement = () => {\n  const body = document.body;\n  !body ?  true ? invariant(false, 'Cannot find document.body') : 0 : void 0;\n  return body;\n};\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  margin: '-1px',\n  border: '0',\n  padding: '0',\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  'clip-path': 'inset(100%)'\n};\n\nconst getId = contextId => `rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n  const id = useMemo(() => getId(contextId), [contextId]);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n    const el = document.createElement('div');\n    ref.current = el;\n    el.id = id;\n    el.setAttribute('aria-live', 'assertive');\n    el.setAttribute('aria-atomic', 'true');\n    (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n    getBodyElement().appendChild(el);\n    return function cleanup() {\n      setTimeout(function remove() {\n        const body = getBodyElement();\n        if (body.contains(el)) {\n          body.removeChild(el);\n        }\n        if (el === ref.current) {\n          ref.current = null;\n        }\n      });\n    };\n  }, [id]);\n  const announce = useCallback(message => {\n    const el = ref.current;\n    if (el) {\n      el.textContent = message;\n      return;\n    }\n     true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n  }, []);\n  return announce;\n}\n\nconst defaults = {\n  separator: '::'\n};\nfunction useUniqueId(prefix, options = defaults) {\n  const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n  return useMemo(() => `${prefix}${options.separator}${id}`, [options.separator, prefix, id]);\n}\n\nfunction getElementId({\n  contextId,\n  uniqueId\n}) {\n  return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({\n  contextId,\n  text\n}) {\n  const uniqueId = useUniqueId('hidden-text', {\n    separator: '-'\n  });\n  const id = useMemo(() => getElementId({\n    contextId,\n    uniqueId\n  }), [uniqueId, contextId]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n    const el = document.createElement('div');\n    el.id = id;\n    el.textContent = text;\n    el.style.display = 'none';\n    getBodyElement().appendChild(el);\n    return function unmount() {\n      const body = getBodyElement();\n      if (body.contains(el)) {\n        body.removeChild(el);\n      }\n    };\n  }, [id, text]);\n  return id;\n}\n\nvar AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nvar peerDependencies = {\n\treact: \"^18.0.0 || ^19.0.0\"};\n\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = value => {\n  const result = semver.exec(value);\n  !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n  const major = Number(result[1]);\n  const minor = Number(result[2]);\n  const patch = Number(result[3]);\n  return {\n    major,\n    minor,\n    patch,\n    raw: value\n  };\n};\nconst isSatisfied = (expected, actual) => {\n  if (actual.major > expected.major) {\n    return true;\n  }\n  if (actual.major < expected.major) {\n    return false;\n  }\n  if (actual.minor > expected.minor) {\n    return true;\n  }\n  if (actual.minor < expected.minor) {\n    return false;\n  }\n  return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue) => {\n  const peerDep = getVersion(peerDepValue);\n  const actual = getVersion(actualValue);\n  if (isSatisfied(peerDep, actual)) {\n    return;\n  }\n   true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\n\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = doc => {\n  const doctype = doc.doctype;\n  if (!doctype) {\n     true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n    return;\n  }\n  if (doctype.name.toLowerCase() !== 'html') {\n     true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n  }\n  if (doctype.publicId !== '') {\n     true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n  }\n};\n\nfunction useDev(useHook) {\n  if (true) {\n    useHook();\n  }\n}\n\nfunction useDevSetupWarning(fn, inputs) {\n  useDev(() => {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      try {\n        fn();\n      } catch (e) {\n        error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n      }\n    }, inputs);\n  });\n}\n\nfunction useStartupValidation() {\n  useDevSetupWarning(() => {\n    checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n    checkDoctype(document);\n  }, []);\n}\n\nfunction usePrevious(current) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = current;\n  });\n  return ref;\n}\n\nfunction create() {\n  let lock = null;\n  function isClaimed() {\n    return Boolean(lock);\n  }\n  function isActive(value) {\n    return value === lock;\n  }\n  function claim(abandon) {\n    !!lock ?  true ? invariant(false, 'Cannot claim lock as it is already claimed') : 0 : void 0;\n    const newLock = {\n      abandon\n    };\n    lock = newLock;\n    return newLock;\n  }\n  function release() {\n    !lock ?  true ? invariant(false, 'Cannot release lock when there is no lock') : 0 : void 0;\n    lock = null;\n  }\n  function tryAbandon() {\n    if (lock) {\n      lock.abandon();\n      release();\n    }\n  }\n  return {\n    isClaimed,\n    isActive,\n    claim,\n    release,\n    tryAbandon\n  };\n}\n\nfunction isDragging(state) {\n  if (state.phase === 'IDLE' || state.phase === 'DROP_ANIMATING') {\n    return false;\n  }\n  return state.isDragging;\n}\n\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\n\nconst preventedKeys = {\n  [enter]: true,\n  [tab]: true\n};\nvar preventStandardKeyEvents = event => {\n  if (preventedKeys[event.keyCode]) {\n    event.preventDefault();\n  }\n};\n\nconst supportedEventName = (() => {\n  const base = 'visibilitychange';\n  if (typeof document === 'undefined') {\n    return base;\n  }\n  const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];\n  const supported = candidates.find(eventName => `on${eventName}` in document);\n  return supported || base;\n})();\n\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n  type: 'IDLE'\n};\nfunction getCaptureBindings({\n  cancel,\n  completed,\n  getPhase,\n  setPhase\n}) {\n  return [{\n    eventName: 'mousemove',\n    fn: event => {\n      const {\n        button,\n        clientX,\n        clientY\n      } = event;\n      if (button !== primaryButton) {\n        return;\n      }\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      const phase = getPhase();\n      if (phase.type === 'DRAGGING') {\n        event.preventDefault();\n        phase.actions.move(point);\n        return;\n      }\n      !(phase.type === 'PENDING') ?  true ? invariant(false, 'Cannot be IDLE') : 0 : void 0;\n      const pending = phase.point;\n      if (!isSloppyClickThresholdExceeded(pending, point)) {\n        return;\n      }\n      event.preventDefault();\n      const actions = phase.actions.fluidLift(point);\n      setPhase({\n        type: 'DRAGGING',\n        actions\n      });\n    }\n  }, {\n    eventName: 'mouseup',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: event => {\n      if (getPhase().type === 'DRAGGING') {\n        event.preventDefault();\n      }\n      cancel();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type === 'PENDING') {\n        cancel();\n        return;\n      }\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'scroll',\n    options: {\n      passive: true,\n      capture: false\n    },\n    fn: () => {\n      if (getPhase().type === 'PENDING') {\n        cancel();\n      }\n    }\n  }, {\n    eventName: 'webkitmouseforcedown',\n    fn: event => {\n      const phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant(false, 'Unexpected phase') : 0 : void 0;\n      if (phase.actions.shouldRespectForcePress()) {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useMouseSensor(api) {\n  const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'mousedown',\n    fn: function onMouseDown(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.button !== primaryButton) {\n        return;\n      }\n      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const actions = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!actions) {\n        return;\n      }\n      event.preventDefault();\n      const point = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      unbindEventsRef.current();\n      startPendingDrag(actions, point);\n    }\n  }), [api]);\n  const preventForcePressBinding = useMemo(() => ({\n    eventName: 'webkitmouseforcewillbegin',\n    fn: event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      const id = api.findClosestDraggableId(event);\n      if (!id) {\n        return;\n      }\n      const options = api.findOptionsForDraggable(id);\n      if (!options) {\n        return;\n      }\n      if (options.shouldRespectForcePress) {\n        return;\n      }\n      if (!api.canGetLock(id)) {\n        return;\n      }\n      event.preventDefault();\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function listenForCapture() {\n    const options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);\n  }, [preventForcePressBinding, startCaptureBinding]);\n  const stop = useCallback(() => {\n    const current = phaseRef.current;\n    if (current.type === 'IDLE') {\n      return;\n    }\n    phaseRef.current = idle$1;\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture]);\n  const cancel = useCallback(() => {\n    const phase = phaseRef.current;\n    stop();\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    const bindings = getCaptureBindings({\n      cancel,\n      completed: stop,\n      getPhase: () => phaseRef.current,\n      setPhase: phase => {\n        phaseRef.current = phase;\n      }\n    });\n    unbindEventsRef.current = bindEvents(window, bindings, options);\n  }, [cancel, stop]);\n  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n    !(phaseRef.current.type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    phaseRef.current = {\n      type: 'PENDING',\n      point,\n      actions\n    };\n    bindCapturingEvents();\n  }, [bindCapturingEvents]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nfunction noop$1() {}\nconst scrollJumpKeys = {\n  [pageDown]: true,\n  [pageUp]: true,\n  [home]: true,\n  [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n  function cancel() {\n    stop();\n    actions.cancel();\n  }\n  function drop() {\n    stop();\n    actions.drop();\n  }\n  return [{\n    eventName: 'keydown',\n    fn: event => {\n      if (event.keyCode === escape) {\n        event.preventDefault();\n        cancel();\n        return;\n      }\n      if (event.keyCode === space) {\n        event.preventDefault();\n        drop();\n        return;\n      }\n      if (event.keyCode === arrowDown) {\n        event.preventDefault();\n        actions.moveDown();\n        return;\n      }\n      if (event.keyCode === arrowUp) {\n        event.preventDefault();\n        actions.moveUp();\n        return;\n      }\n      if (event.keyCode === arrowRight) {\n        event.preventDefault();\n        actions.moveRight();\n        return;\n      }\n      if (event.keyCode === arrowLeft) {\n        event.preventDefault();\n        actions.moveLeft();\n        return;\n      }\n      if (scrollJumpKeys[event.keyCode]) {\n        event.preventDefault();\n        return;\n      }\n      preventStandardKeyEvents(event);\n    }\n  }, {\n    eventName: 'mousedown',\n    fn: cancel\n  }, {\n    eventName: 'mouseup',\n    fn: cancel\n  }, {\n    eventName: 'click',\n    fn: cancel\n  }, {\n    eventName: 'touchstart',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'wheel',\n    fn: cancel,\n    options: {\n      passive: true\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useKeyboardSensor(api) {\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'keydown',\n    fn: function onKeyDown(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.keyCode !== space) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const preDrag = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!preDrag) {\n        return;\n      }\n      event.preventDefault();\n      let isCapturing = true;\n      const actions = preDrag.snapLift();\n      unbindEventsRef.current();\n      function stop() {\n        !isCapturing ?  true ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : 0 : void 0;\n        isCapturing = false;\n        unbindEventsRef.current();\n        listenForCapture();\n      }\n      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n        capture: true,\n        passive: false\n      });\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function tryStartCapture() {\n    const options = {\n      passive: false,\n      capture: true\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n    };\n  }, [listenForCapture]);\n}\n\nconst idle = {\n  type: 'IDLE'\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({\n  cancel,\n  getPhase\n}) {\n  return [{\n    eventName: 'orientationchange',\n    fn: cancel\n  }, {\n    eventName: 'resize',\n    fn: cancel\n  }, {\n    eventName: 'contextmenu',\n    fn: event => {\n      event.preventDefault();\n    }\n  }, {\n    eventName: 'keydown',\n    fn: event => {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      if (event.keyCode === escape) {\n        event.preventDefault();\n      }\n      cancel();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction getHandleBindings({\n  cancel,\n  completed,\n  getPhase\n}) {\n  return [{\n    eventName: 'touchmove',\n    options: {\n      capture: false\n    },\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      phase.hasMoved = true;\n      const {\n        clientX,\n        clientY\n      } = event.touches[0];\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      event.preventDefault();\n      phase.actions.move(point);\n    }\n  }, {\n    eventName: 'touchend',\n    fn: event => {\n      const phase = getPhase();\n      if (phase.type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      phase.actions.drop({\n        shouldBlockNextClick: true\n      });\n      completed();\n    }\n  }, {\n    eventName: 'touchcancel',\n    fn: event => {\n      if (getPhase().type !== 'DRAGGING') {\n        cancel();\n        return;\n      }\n      event.preventDefault();\n      cancel();\n    }\n  }, {\n    eventName: 'touchforcechange',\n    fn: event => {\n      const phase = getPhase();\n      !(phase.type !== 'IDLE') ?  true ? invariant() : 0 : void 0;\n      const touch = event.touches[0];\n      if (!touch) {\n        return;\n      }\n      const isForcePress = touch.force >= forcePressThreshold;\n      if (!isForcePress) {\n        return;\n      }\n      const shouldRespect = phase.actions.shouldRespectForcePress();\n      if (phase.type === 'PENDING') {\n        if (shouldRespect) {\n          cancel();\n        }\n        return;\n      }\n      if (shouldRespect) {\n        if (phase.hasMoved) {\n          event.preventDefault();\n          return;\n        }\n        cancel();\n        return;\n      }\n      event.preventDefault();\n    }\n  }, {\n    eventName: supportedEventName,\n    fn: cancel\n  }];\n}\nfunction useTouchSensor(api) {\n  const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n  const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n  const getPhase = useCallback(function getPhase() {\n    return phaseRef.current;\n  }, []);\n  const setPhase = useCallback(function setPhase(phase) {\n    phaseRef.current = phase;\n  }, []);\n  const startCaptureBinding = useMemo(() => ({\n    eventName: 'touchstart',\n    fn: function onTouchStart(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n      const draggableId = api.findClosestDraggableId(event);\n      if (!draggableId) {\n        return;\n      }\n      const actions = api.tryGetLock(draggableId, stop, {\n        sourceEvent: event\n      });\n      if (!actions) {\n        return;\n      }\n      const touch = event.touches[0];\n      const {\n        clientX,\n        clientY\n      } = touch;\n      const point = {\n        x: clientX,\n        y: clientY\n      };\n      unbindEventsRef.current();\n      startPendingDrag(actions, point);\n    }\n  }), [api]);\n  const listenForCapture = useCallback(function listenForCapture() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);\n  }, [startCaptureBinding]);\n  const stop = useCallback(() => {\n    const current = phaseRef.current;\n    if (current.type === 'IDLE') {\n      return;\n    }\n    if (current.type === 'PENDING') {\n      clearTimeout(current.longPressTimerId);\n    }\n    setPhase(idle);\n    unbindEventsRef.current();\n    listenForCapture();\n  }, [listenForCapture, setPhase]);\n  const cancel = useCallback(() => {\n    const phase = phaseRef.current;\n    stop();\n    if (phase.type === 'DRAGGING') {\n      phase.actions.cancel({\n        shouldBlockNextClick: true\n      });\n    }\n    if (phase.type === 'PENDING') {\n      phase.actions.abort();\n    }\n  }, [stop]);\n  const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n    const options = {\n      capture: true,\n      passive: false\n    };\n    const args = {\n      cancel,\n      completed: stop,\n      getPhase\n    };\n    const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n    const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n    unbindEventsRef.current = function unbindAll() {\n      unbindTarget();\n      unbindWindow();\n    };\n  }, [cancel, getPhase, stop]);\n  const startDragging = useCallback(function startDragging() {\n    const phase = getPhase();\n    !(phase.type === 'PENDING') ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n    const actions = phase.actions.fluidLift(phase.point);\n    setPhase({\n      type: 'DRAGGING',\n      actions,\n      hasMoved: false\n    });\n  }, [getPhase, setPhase]);\n  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n    !(getPhase().type === 'IDLE') ?  true ? invariant(false, 'Expected to move from IDLE to PENDING drag') : 0 : void 0;\n    const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n    setPhase({\n      type: 'PENDING',\n      point,\n      actions,\n      longPressTimerId\n    });\n    bindCapturingEvents();\n  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);\n  useIsomorphicLayoutEffect(function mount() {\n    listenForCapture();\n    return function unmount() {\n      unbindEventsRef.current();\n      const phase = getPhase();\n      if (phase.type === 'PENDING') {\n        clearTimeout(phase.longPressTimerId);\n        setPhase(idle);\n      }\n    };\n  }, [getPhase, listenForCapture, setPhase]);\n  useIsomorphicLayoutEffect(function webkitHack() {\n    const unbind = bindEvents(window, [{\n      eventName: 'touchmove',\n      fn: () => {},\n      options: {\n        capture: false,\n        passive: false\n      }\n    }]);\n    return unbind;\n  }, []);\n}\n\nfunction useValidateSensorHooks(sensorHooks) {\n  useDev(() => {\n    const previousRef = usePrevious(sensorHooks);\n    useDevSetupWarning(() => {\n      !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : 0 : void 0;\n    });\n  });\n}\n\nconst interactiveTagNames = ['input', 'button', 'textarea', 'select', 'option', 'optgroup', 'video', 'audio'];\nfunction isAnInteractiveElement(parent, current) {\n  if (current == null) {\n    return false;\n  }\n  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n  if (hasAnInteractiveTag) {\n    return true;\n  }\n  const attribute = current.getAttribute('contenteditable');\n  if (attribute === 'true' || attribute === '') {\n    return true;\n  }\n  if (current === parent) {\n    return false;\n  }\n  return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n  const target = event.target;\n  if (!isHtmlElement(target)) {\n    return false;\n  }\n  return isAnInteractiveElement(draggable, target);\n}\n\nvar getBorderBoxCenterPosition = el => (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(el.getBoundingClientRect()).center;\n\nfunction isElement(el) {\n  return el instanceof getWindowFromEl(el).Element;\n}\n\nconst supportedMatchesName = (() => {\n  const base = 'matches';\n  if (typeof document === 'undefined') {\n    return base;\n  }\n  const candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];\n  const value = candidates.find(name => name in Element.prototype);\n  return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n  if (el == null) {\n    return null;\n  }\n  if (el[supportedMatchesName](selector)) {\n    return el;\n  }\n  return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n  return closestPonyfill(el, selector);\n}\n\nfunction getSelector(contextId) {\n  return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n  const target = event.target;\n  if (!isElement(target)) {\n     true ? warning('event.target must be a Element') : 0;\n    return null;\n  }\n  const selector = getSelector(contextId);\n  const handle = closest(target, selector);\n  if (!handle) {\n    return null;\n  }\n  if (!isHtmlElement(handle)) {\n     true ? warning('drag handle must be a HTMLElement') : 0;\n    return null;\n  }\n  return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n  const handle = findClosestDragHandleFromEvent(contextId, event);\n  if (!handle) {\n    return null;\n  }\n  return handle.getAttribute(dragHandle.draggableId);\n}\n\nfunction findDraggable(contextId, draggableId) {\n  const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n  const possible = querySelectorAll(document, selector);\n  const draggable$1 = possible.find(el => {\n    return el.getAttribute(draggable.id) === draggableId;\n  });\n  if (!draggable$1) {\n    return null;\n  }\n  if (!isHtmlElement(draggable$1)) {\n     true ? warning('Draggable element is not a HTMLElement') : 0;\n    return null;\n  }\n  return draggable$1;\n}\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction isActive({\n  expected,\n  phase,\n  isLockActive,\n  shouldWarn\n}) {\n  if (!isLockActive()) {\n    if (shouldWarn) {\n       true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n    }\n    return false;\n  }\n  if (expected !== phase) {\n    if (shouldWarn) {\n       true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n    }\n    return false;\n  }\n  return true;\n}\nfunction canStart({\n  lockAPI,\n  store,\n  registry,\n  draggableId\n}) {\n  if (lockAPI.isClaimed()) {\n    return false;\n  }\n  const entry = registry.draggable.findById(draggableId);\n  if (!entry) {\n     true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n    return false;\n  }\n  if (!entry.options.isEnabled) {\n    return false;\n  }\n  if (!canStartDrag(store.getState(), draggableId)) {\n    return false;\n  }\n  return true;\n}\nfunction tryStart({\n  lockAPI,\n  contextId,\n  store,\n  registry,\n  draggableId,\n  forceSensorStop,\n  sourceEvent\n}) {\n  const shouldStart = canStart({\n    lockAPI,\n    store,\n    registry,\n    draggableId\n  });\n  if (!shouldStart) {\n    return null;\n  }\n  const entry = registry.draggable.getById(draggableId);\n  const el = findDraggable(contextId, entry.descriptor.id);\n  if (!el) {\n     true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n    return null;\n  }\n  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n    return null;\n  }\n  const lock = lockAPI.claim(forceSensorStop || noop$2);\n  let phase = 'PRE_DRAG';\n  function getShouldRespectForcePress() {\n    return entry.options.shouldRespectForcePress;\n  }\n  function isLockActive() {\n    return lockAPI.isActive(lock);\n  }\n  function tryDispatch(expected, getAction) {\n    if (isActive({\n      expected,\n      phase,\n      isLockActive,\n      shouldWarn: true\n    })) {\n      store.dispatch(getAction());\n    }\n  }\n  const tryDispatchWhenDragging = tryDispatch.bind(null, 'DRAGGING');\n  function lift(args) {\n    function completed() {\n      lockAPI.release();\n      phase = 'COMPLETED';\n    }\n    if (phase !== 'PRE_DRAG') {\n      completed();\n       true ? invariant(false, `Cannot lift in phase ${phase}`) : 0 ;\n    }\n    store.dispatch(lift$1(args.liftActionArgs));\n    phase = 'DRAGGING';\n    function finish(reason, options = {\n      shouldBlockNextClick: false\n    }) {\n      args.cleanup();\n      if (options.shouldBlockNextClick) {\n        const unbind = bindEvents(window, [{\n          eventName: 'click',\n          fn: preventDefault,\n          options: {\n            once: true,\n            passive: false,\n            capture: true\n          }\n        }]);\n        setTimeout(unbind);\n      }\n      completed();\n      store.dispatch(drop({\n        reason\n      }));\n    }\n    return {\n      isActive: () => isActive({\n        expected: 'DRAGGING',\n        phase,\n        isLockActive,\n        shouldWarn: false\n      }),\n      shouldRespectForcePress: getShouldRespectForcePress,\n      drop: options => finish('DROP', options),\n      cancel: options => finish('CANCEL', options),\n      ...args.actions\n    };\n  }\n  function fluidLift(clientSelection) {\n    const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(client => {\n      tryDispatchWhenDragging(() => move({\n        client\n      }));\n    });\n    const api = lift({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection,\n        movementMode: 'FLUID'\n      },\n      cleanup: () => move$1.cancel(),\n      actions: {\n        move: move$1\n      }\n    });\n    return {\n      ...api,\n      move: move$1\n    };\n  }\n  function snapLift() {\n    const actions = {\n      moveUp: () => tryDispatchWhenDragging(moveUp),\n      moveRight: () => tryDispatchWhenDragging(moveRight),\n      moveDown: () => tryDispatchWhenDragging(moveDown),\n      moveLeft: () => tryDispatchWhenDragging(moveLeft)\n    };\n    return lift({\n      liftActionArgs: {\n        id: draggableId,\n        clientSelection: getBorderBoxCenterPosition(el),\n        movementMode: 'SNAP'\n      },\n      cleanup: noop$2,\n      actions\n    });\n  }\n  function abortPreDrag() {\n    const shouldRelease = isActive({\n      expected: 'PRE_DRAG',\n      phase,\n      isLockActive,\n      shouldWarn: true\n    });\n    if (shouldRelease) {\n      lockAPI.release();\n    }\n  }\n  const preDrag = {\n    isActive: () => isActive({\n      expected: 'PRE_DRAG',\n      phase,\n      isLockActive,\n      shouldWarn: false\n    }),\n    shouldRespectForcePress: getShouldRespectForcePress,\n    fluidLift,\n    snapLift,\n    abort: abortPreDrag\n  };\n  return preDrag;\n}\nconst defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];\nfunction useSensorMarshal({\n  contextId,\n  store,\n  registry,\n  customSensors,\n  enableDefaultSensors\n}) {\n  const useSensors = [...(enableDefaultSensors ? defaultSensors : []), ...(customSensors || [])];\n  const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => create())[0];\n  const tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {\n    if (isDragging(previous) && !isDragging(current)) {\n      lockAPI.tryAbandon();\n    }\n  }, [lockAPI]);\n  useIsomorphicLayoutEffect(function listenToStore() {\n    let previous = store.getState();\n    const unsubscribe = store.subscribe(() => {\n      const current = store.getState();\n      tryAbandonLock(previous, current);\n      previous = current;\n    });\n    return unsubscribe;\n  }, [lockAPI, store, tryAbandonLock]);\n  useIsomorphicLayoutEffect(() => {\n    return lockAPI.tryAbandon;\n  }, [lockAPI.tryAbandon]);\n  const canGetLock = useCallback(draggableId => {\n    return canStart({\n      lockAPI,\n      registry,\n      store,\n      draggableId\n    });\n  }, [lockAPI, registry, store]);\n  const tryGetLock = useCallback((draggableId, forceStop, options) => tryStart({\n    lockAPI,\n    registry,\n    contextId,\n    store,\n    draggableId,\n    forceSensorStop: forceStop || null,\n    sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n  }), [contextId, lockAPI, registry, store]);\n  const findClosestDraggableId = useCallback(event => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);\n  const findOptionsForDraggable = useCallback(id => {\n    const entry = registry.draggable.findById(id);\n    return entry ? entry.options : null;\n  }, [registry.draggable]);\n  const tryReleaseLock = useCallback(function tryReleaseLock() {\n    if (!lockAPI.isClaimed()) {\n      return;\n    }\n    lockAPI.tryAbandon();\n    if (store.getState().phase !== 'IDLE') {\n      store.dispatch(flush());\n    }\n  }, [lockAPI, store]);\n  const isLockClaimed = useCallback(() => lockAPI.isClaimed(), [lockAPI]);\n  const api = useMemo(() => ({\n    canGetLock,\n    tryGetLock,\n    findClosestDraggableId,\n    findOptionsForDraggable,\n    tryReleaseLock,\n    isLockClaimed\n  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);\n  useValidateSensorHooks(useSensors);\n  for (let i = 0; i < useSensors.length; i++) {\n    useSensors[i](api);\n  }\n}\n\nconst createResponders = props => ({\n  onBeforeCapture: t => {\n    const onBeforeCapureCallback = () => {\n      if (props.onBeforeCapture) {\n        props.onBeforeCapture(t);\n      }\n    };\n    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n  },\n  onBeforeDragStart: props.onBeforeDragStart,\n  onDragStart: props.onDragStart,\n  onDragEnd: props.onDragEnd,\n  onDragUpdate: props.onDragUpdate\n});\nconst createAutoScrollerOptions = props => ({\n  ...defaultAutoScrollerOptions,\n  ...props.autoScrollerOptions,\n  durationDampening: {\n    ...defaultAutoScrollerOptions.durationDampening,\n    ...props.autoScrollerOptions\n  }\n});\nfunction getStore(lazyRef) {\n  !lazyRef.current ?  true ? invariant(false, 'Could not find store from lazy ref') : 0 : void 0;\n  return lazyRef.current;\n}\nfunction App(props) {\n  const {\n    contextId,\n    setCallbacks,\n    sensors,\n    nonce,\n    dragHandleUsageInstructions\n  } = props;\n  const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  useStartupValidation();\n  const lastPropsRef = usePrevious(props);\n  const getResponders = useCallback(() => {\n    return createResponders(lastPropsRef.current);\n  }, [lastPropsRef]);\n  const getAutoScrollerOptions = useCallback(() => {\n    return createAutoScrollerOptions(lastPropsRef.current);\n  }, [lastPropsRef]);\n  const announce = useAnnouncer(contextId);\n  const dragHandleUsageInstructionsId = useHiddenTextElement({\n    contextId,\n    text: dragHandleUsageInstructions\n  });\n  const styleMarshal = useStyleMarshal(contextId, nonce);\n  const lazyDispatch = useCallback(action => {\n    getStore(lazyStoreRef).dispatch(action);\n  }, []);\n  const marshalCallbacks = useMemo(() => (0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n    publishWhileDragging,\n    updateDroppableScroll,\n    updateDroppableIsEnabled,\n    updateDroppableIsCombineEnabled,\n    collectionStarting\n  }, lazyDispatch), [lazyDispatch]);\n  const registry = useRegistry();\n  const dimensionMarshal = useMemo(() => {\n    return createDimensionMarshal(registry, marshalCallbacks);\n  }, [registry, marshalCallbacks]);\n  const autoScroller = useMemo(() => createAutoScroller({\n    scrollWindow,\n    scrollDroppable: dimensionMarshal.scrollDroppable,\n    getAutoScrollerOptions,\n    ...(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n      move\n    }, lazyDispatch)\n  }), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);\n  const focusMarshal = useFocusMarshal(contextId);\n  const store = useMemo(() => createStore({\n    announce,\n    autoScroller,\n    dimensionMarshal,\n    focusMarshal,\n    getResponders,\n    styleMarshal\n  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);\n  if (true) {\n    if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n       true ? warning('unexpected store change') : 0;\n    }\n  }\n  lazyStoreRef.current = store;\n  const tryResetStore = useCallback(() => {\n    const current = getStore(lazyStoreRef);\n    const state = current.getState();\n    if (state.phase !== 'IDLE') {\n      current.dispatch(flush());\n    }\n  }, []);\n  const isDragging = useCallback(() => {\n    const state = getStore(lazyStoreRef).getState();\n    if (state.phase === 'DROP_ANIMATING') {\n      return true;\n    }\n    if (state.phase === 'IDLE') {\n      return false;\n    }\n    return state.isDragging;\n  }, []);\n  const appCallbacks = useMemo(() => ({\n    isDragging,\n    tryAbort: tryResetStore\n  }), [isDragging, tryResetStore]);\n  setCallbacks(appCallbacks);\n  const getCanLift = useCallback(id => canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n  const getIsMovementAllowed = useCallback(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n  const appContext = useMemo(() => ({\n    marshal: dimensionMarshal,\n    focus: focusMarshal,\n    contextId,\n    canLift: getCanLift,\n    isMovementAllowed: getIsMovementAllowed,\n    dragHandleUsageInstructionsId,\n    registry\n  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);\n  useSensorMarshal({\n    contextId,\n    store,\n    registry,\n    customSensors: sensors || null,\n    enableDefaultSensors: props.enableDefaultSensors !== false\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return tryResetStore;\n  }, [tryResetStore]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: appContext\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_6__.Provider, {\n    context: StoreContext,\n    store: store\n  }, props.children));\n}\n\nfunction useUniqueContextId() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\n\nfunction DragDropContext(props) {\n  const contextId = useUniqueContextId();\n  const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, setCallbacks => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n    nonce: props.nonce,\n    contextId: contextId,\n    setCallbacks: setCallbacks,\n    dragHandleUsageInstructions: dragHandleUsageInstructions,\n    enableDefaultSensors: props.enableDefaultSensors,\n    sensors: props.sensors,\n    onBeforeCapture: props.onBeforeCapture,\n    onBeforeDragStart: props.onBeforeDragStart,\n    onDragStart: props.onDragStart,\n    onDragUpdate: props.onDragUpdate,\n    onDragEnd: props.onDragEnd,\n    autoScrollerOptions: props.autoScrollerOptions\n  }, props.children));\n}\n\nconst zIndexOptions = {\n  dragging: 5000,\n  dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping) => {\n  if (dropping) {\n    return transitions.drop(dropping.duration);\n  }\n  if (shouldAnimateDragMovement) {\n    return transitions.snap;\n  }\n  return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating) => {\n  if (!isCombining) {\n    return undefined;\n  }\n  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = dragging => {\n  if (dragging.forceShouldAnimate != null) {\n    return dragging.forceShouldAnimate;\n  }\n  return dragging.mode === 'SNAP';\n};\nfunction getDraggingStyle(dragging) {\n  const dimension = dragging.dimension;\n  const box = dimension.client;\n  const {\n    offset,\n    combineWith,\n    dropping\n  } = dragging;\n  const isCombining = Boolean(combineWith);\n  const shouldAnimate = getShouldDraggingAnimate(dragging);\n  const isDropAnimating = Boolean(dropping);\n  const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n  const style = {\n    position: 'fixed',\n    top: box.marginBox.top,\n    left: box.marginBox.left,\n    boxSizing: 'border-box',\n    width: box.borderBox.width,\n    height: box.borderBox.height,\n    transition: getDraggingTransition(shouldAnimate, dropping),\n    transform,\n    opacity: getDraggingOpacity(isCombining, isDropAnimating),\n    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n    pointerEvents: 'none'\n  };\n  return style;\n}\nfunction getSecondaryStyle(secondary) {\n  return {\n    transform: transforms.moveTo(secondary.offset),\n    transition: secondary.shouldAnimateDisplacement ? undefined : 'none'\n  };\n}\nfunction getStyle$1(mapped) {\n  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\n\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n  const computedStyles = window.getComputedStyle(el);\n  const borderBox = el.getBoundingClientRect();\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.calculateBox)(borderBox, computedStyles);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n  const placeholder = {\n    client,\n    tagName: el.tagName.toLowerCase(),\n    display: computedStyles.display\n  };\n  const displaceBy = {\n    x: client.marginBox.width,\n    y: client.marginBox.height\n  };\n  const dimension = {\n    descriptor,\n    placeholder,\n    displaceBy,\n    client,\n    page\n  };\n  return dimension;\n}\n\nfunction useDraggablePublisher(args) {\n  const uniqueId = useUniqueId('draggable');\n  const {\n    descriptor,\n    registry,\n    getDraggableRef,\n    canDragInteractiveElements,\n    shouldRespectForcePress,\n    isEnabled\n  } = args;\n  const options = useMemo(() => ({\n    canDragInteractiveElements,\n    shouldRespectForcePress,\n    isEnabled\n  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);\n  const getDimension = useCallback(windowScroll => {\n    const el = getDraggableRef();\n    !el ?  true ? invariant(false, 'Cannot get dimension when no ref is set') : 0 : void 0;\n    return getDimension$1(descriptor, el, windowScroll);\n  }, [descriptor, getDraggableRef]);\n  const entry = useMemo(() => ({\n    uniqueId,\n    descriptor,\n    options,\n    getDimension\n  }), [descriptor, getDimension, options, uniqueId]);\n  const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n  const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  useIsomorphicLayoutEffect(() => {\n    registry.draggable.register(publishedRef.current);\n    return () => registry.draggable.unregister(publishedRef.current);\n  }, [registry.draggable]);\n  useIsomorphicLayoutEffect(() => {\n    if (isFirstPublishRef.current) {\n      isFirstPublishRef.current = false;\n      return;\n    }\n    const last = publishedRef.current;\n    publishedRef.current = entry;\n    registry.draggable.update(entry, last);\n  }, [entry, registry.draggable]);\n}\n\nvar DroppableContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction checkIsValidInnerRef(el) {\n  !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\n\nfunction useValidation$1(props, contextId, getRef) {\n  useDevSetupWarning(() => {\n    function prefix(id) {\n      return `Draggable[id: ${id}]: `;\n    }\n    const id = props.draggableId;\n    !id ?  true ? invariant(false, 'Draggable requires a draggableId') : 0 : void 0;\n    !(typeof id === 'string') ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n    !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n    if (props.mapped.type === 'DRAGGING') {\n      return;\n    }\n    checkIsValidInnerRef(getRef());\n    if (props.isEnabled) {\n      !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n    }\n  });\n}\nfunction useClonePropValidation(isClone) {\n  useDev(() => {\n    const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n    useDevSetupWarning(() => {\n      !(isClone === initialRef.current) ?  true ? invariant(false, 'Draggable isClone prop value changed during component life') : 0 : void 0;\n    }, [isClone]);\n  });\n}\n\nfunction useRequiredContext(Context) {\n  const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n  !result ?  true ? invariant(false, 'Could not find required context') : 0 : void 0;\n  return result;\n}\n\nfunction preventHtml5Dnd(event) {\n  event.preventDefault();\n}\nconst Draggable = props => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const setRef = useCallback((el = null) => {\n    ref.current = el;\n  }, []);\n  const getRef = useCallback(() => ref.current, []);\n  const {\n    contextId,\n    dragHandleUsageInstructionsId,\n    registry\n  } = useRequiredContext(AppContext);\n  const {\n    type,\n    droppableId\n  } = useRequiredContext(DroppableContext);\n  const descriptor = useMemo(() => ({\n    id: props.draggableId,\n    index: props.index,\n    type,\n    droppableId\n  }), [props.draggableId, props.index, type, droppableId]);\n  const {\n    children,\n    draggableId,\n    isEnabled,\n    shouldRespectForcePress,\n    canDragInteractiveElements,\n    isClone,\n    mapped,\n    dropAnimationFinished: dropAnimationFinishedAction\n  } = props;\n  useValidation$1(props, contextId, getRef);\n  useClonePropValidation(isClone);\n  if (!isClone) {\n    const forPublisher = useMemo(() => ({\n      descriptor,\n      registry,\n      getDraggableRef: getRef,\n      canDragInteractiveElements,\n      shouldRespectForcePress,\n      isEnabled\n    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);\n    useDraggablePublisher(forPublisher);\n  }\n  const dragHandleProps = useMemo(() => isEnabled ? {\n    tabIndex: 0,\n    role: 'button',\n    'aria-describedby': dragHandleUsageInstructionsId,\n    'data-rfd-drag-handle-draggable-id': draggableId,\n    'data-rfd-drag-handle-context-id': contextId,\n    draggable: false,\n    onDragStart: preventHtml5Dnd\n  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);\n  const onMoveEnd = useCallback(event => {\n    if (mapped.type !== 'DRAGGING') {\n      return;\n    }\n    if (!mapped.dropping) {\n      return;\n    }\n    if (event.propertyName !== 'transform') {\n      return;\n    }\n    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n  }, [dropAnimationFinishedAction, mapped]);\n  const provided = useMemo(() => {\n    const style = getStyle$1(mapped);\n    const onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : undefined;\n    const result = {\n      innerRef: setRef,\n      draggableProps: {\n        'data-rfd-draggable-context-id': contextId,\n        'data-rfd-draggable-id': draggableId,\n        style,\n        onTransitionEnd\n      },\n      dragHandleProps\n    };\n    return result;\n  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);\n  const rubric = useMemo(() => ({\n    draggableId: descriptor.id,\n    type: descriptor.type,\n    source: {\n      index: descriptor.index,\n      droppableId: descriptor.droppableId\n    }\n  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\n\nvar isStrictEqual = (a, b) => a === b;\n\nvar whatIsDraggedOverFromResult = result => {\n  const {\n    combine,\n    destination\n  } = result;\n  if (destination) {\n    return destination.droppableId;\n  }\n  if (combine) {\n    return combine.droppableId;\n  }\n  return null;\n};\n\nconst getCombineWithFromResult = result => {\n  return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = impact => {\n  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n  const memoizedOffset = memoizeOne((x, y) => ({\n    x,\n    y\n  }));\n  const getMemoizedSnapshot = memoizeOne((mode, isClone, draggingOver = null, combineWith = null, dropping = null) => ({\n    isDragging: true,\n    isClone,\n    isDropAnimating: Boolean(dropping),\n    dropAnimation: dropping,\n    mode,\n    draggingOver,\n    combineWith,\n    combineTargetFor: null\n  }));\n  const getMemoizedProps = memoizeOne((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null) => ({\n    mapped: {\n      type: 'DRAGGING',\n      dropping: null,\n      draggingOver,\n      combineWith,\n      mode,\n      offset,\n      dimension,\n      forceShouldAnimate,\n      snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n    }\n  }));\n  const selector = (state, ownProps) => {\n    if (isDragging(state)) {\n      if (state.critical.draggable.id !== ownProps.draggableId) {\n        return null;\n      }\n      const offset = state.current.client.offset;\n      const dimension = state.dimensions.draggables[ownProps.draggableId];\n      const draggingOver = whatIsDraggedOver(state.impact);\n      const combineWith = getCombineWithFromImpact(state.impact);\n      const forceShouldAnimate = state.forceShouldAnimate;\n      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (completed.result.draggableId !== ownProps.draggableId) {\n        return null;\n      }\n      const isClone = ownProps.isClone;\n      const dimension = state.dimensions.draggables[ownProps.draggableId];\n      const result = completed.result;\n      const mode = result.mode;\n      const draggingOver = whatIsDraggedOverFromResult(result);\n      const combineWith = getCombineWithFromResult(result);\n      const duration = state.dropDuration;\n      const dropping = {\n        duration,\n        curve: curves.drop,\n        moveTo: state.newHomeClientOffset,\n        opacity: combineWith ? combine.opacity.drop : null,\n        scale: combineWith ? combine.scale.drop : null\n      };\n      return {\n        mapped: {\n          type: 'DRAGGING',\n          offset: state.newHomeClientOffset,\n          dimension,\n          dropping,\n          draggingOver,\n          combineWith,\n          mode,\n          forceShouldAnimate: null,\n          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n        }\n      };\n    }\n    return null;\n  };\n  return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n  return {\n    isDragging: false,\n    isDropAnimating: false,\n    isClone: false,\n    dropAnimation: null,\n    mode: null,\n    draggingOver: null,\n    combineTargetFor,\n    combineWith: null\n  };\n}\nconst atRest = {\n  mapped: {\n    type: 'SECONDARY',\n    offset: origin,\n    combineTargetFor: null,\n    shouldAnimateDisplacement: true,\n    snapshot: getSecondarySnapshot(null)\n  }\n};\nfunction getSecondarySelector() {\n  const memoizedOffset = memoizeOne((x, y) => ({\n    x,\n    y\n  }));\n  const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n  const getMemoizedProps = memoizeOne((offset, combineTargetFor = null, shouldAnimateDisplacement) => ({\n    mapped: {\n      type: 'SECONDARY',\n      offset,\n      combineTargetFor,\n      shouldAnimateDisplacement,\n      snapshot: getMemoizedSnapshot(combineTargetFor)\n    }\n  }));\n  const getFallback = combineTargetFor => {\n    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n  };\n  const getProps = (ownId, draggingId, impact, afterCritical) => {\n    const visualDisplacement = impact.displaced.visible[ownId];\n    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n    const combine = tryGetCombine(impact);\n    const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n    if (!visualDisplacement) {\n      if (!isAfterCriticalInVirtualList) {\n        return getFallback(combineTargetFor);\n      }\n      if (impact.displaced.invisible[ownId]) {\n        return null;\n      }\n      const change = negate(afterCritical.displacedBy.point);\n      const offset = memoizedOffset(change.x, change.y);\n      return getMemoizedProps(offset, combineTargetFor, true);\n    }\n    if (isAfterCriticalInVirtualList) {\n      return getFallback(combineTargetFor);\n    }\n    const displaceBy = impact.displacedBy.point;\n    const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n  };\n  const selector = (state, ownProps) => {\n    if (isDragging(state)) {\n      if (state.critical.draggable.id === ownProps.draggableId) {\n        return null;\n      }\n      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (completed.result.draggableId === ownProps.draggableId) {\n        return null;\n      }\n      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n    }\n    return null;\n  };\n  return selector;\n}\nconst makeMapStateToProps$1 = () => {\n  const draggingSelector = getDraggableSelector();\n  const secondarySelector = getSecondarySelector();\n  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n  return selector;\n};\nconst mapDispatchToProps$1 = {\n  dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n  context: StoreContext,\n  areStatePropsEqual: isStrictEqual\n})(Draggable);\n\nfunction PrivateDraggable(props) {\n  const droppableContext = useRequiredContext(DroppableContext);\n  const isUsingCloneFor = droppableContext.isUsingCloneFor;\n  if (isUsingCloneFor === props.draggableId && !props.isClone) {\n    return null;\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n  const isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;\n  const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n  const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n    isClone: false,\n    isEnabled: isEnabled,\n    canDragInteractiveElements: canDragInteractiveElements,\n    shouldRespectForcePress: shouldRespectForcePress\n  }));\n}\n\nconst isEqual = base => value => base === value;\nconst isScroll = isEqual('scroll');\nconst isAuto = isEqual('auto');\nconst isVisible = isEqual('visible');\nconst isEither = (overflow, fn) => fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn) => fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = el => {\n  const style = window.getComputedStyle(el);\n  const overflow = {\n    overflowX: style.overflowX,\n    overflowY: style.overflowY\n  };\n  return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = () => {\n  if (false) {}\n  const body = getBodyElement();\n  const html = document.documentElement;\n  !html ?  true ? invariant() : 0 : void 0;\n  if (!isElementScrollable(body)) {\n    return false;\n  }\n  const htmlStyle = window.getComputedStyle(html);\n  const htmlOverflow = {\n    overflowX: htmlStyle.overflowX,\n    overflowY: htmlStyle.overflowY\n  };\n  if (isBoth(htmlOverflow, isVisible)) {\n    return false;\n  }\n   true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n  return false;\n};\nconst getClosestScrollable = el => {\n  if (el == null) {\n    return null;\n  }\n  if (el === document.body) {\n    return isBodyScrollable() ? el : null;\n  }\n  if (el === document.documentElement) {\n    return null;\n  }\n  if (!isElementScrollable(el)) {\n    return getClosestScrollable(el.parentElement);\n  }\n  return el;\n};\n\nvar checkForNestedScrollContainers = scrollable => {\n  if (!scrollable) {\n    return;\n  }\n  const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n  if (!anotherScrollParent) {\n    return;\n  }\n   true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\n\nvar getScroll = el => ({\n  x: el.scrollLeft,\n  y: el.scrollTop\n});\n\nconst getIsFixed = el => {\n  if (!el) {\n    return false;\n  }\n  const style = window.getComputedStyle(el);\n  if (style.position === 'fixed') {\n    return true;\n  }\n  return getIsFixed(el.parentElement);\n};\nvar getEnv = start => {\n  const closestScrollable = getClosestScrollable(start);\n  const isFixedOnPage = getIsFixed(start);\n  return {\n    closestScrollable,\n    isFixedOnPage\n  };\n};\n\nvar getDroppableDimension = ({\n  descriptor,\n  isEnabled,\n  isCombineEnabled,\n  isFixedOnPage,\n  direction,\n  client,\n  page,\n  closest\n}) => {\n  const frame = (() => {\n    if (!closest) {\n      return null;\n    }\n    const {\n      scrollSize,\n      client: frameClient\n    } = closest;\n    const maxScroll = getMaxScroll({\n      scrollHeight: scrollSize.scrollHeight,\n      scrollWidth: scrollSize.scrollWidth,\n      height: frameClient.paddingBox.height,\n      width: frameClient.paddingBox.width\n    });\n    return {\n      pageMarginBox: closest.page.marginBox,\n      frameClient,\n      scrollSize,\n      shouldClipSubject: closest.shouldClipSubject,\n      scroll: {\n        initial: closest.scroll,\n        current: closest.scroll,\n        max: maxScroll,\n        diff: {\n          value: origin,\n          displacement: origin\n        }\n      }\n    };\n  })();\n  const axis = direction === 'vertical' ? vertical : horizontal;\n  const subject = getSubject({\n    page,\n    withPlaceholder: null,\n    axis,\n    frame\n  });\n  const dimension = {\n    descriptor,\n    isCombineEnabled,\n    isFixedOnPage,\n    axis,\n    isEnabled,\n    client,\n    page,\n    frame,\n    subject\n  };\n  return dimension;\n};\n\nconst getClient = (targetRef, closestScrollable) => {\n  const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(targetRef);\n  if (!closestScrollable) {\n    return base;\n  }\n  if (targetRef !== closestScrollable) {\n    return base;\n  }\n  const top = base.paddingBox.top - closestScrollable.scrollTop;\n  const left = base.paddingBox.left - closestScrollable.scrollLeft;\n  const bottom = top + closestScrollable.scrollHeight;\n  const right = left + closestScrollable.scrollWidth;\n  const paddingBox = {\n    top,\n    right,\n    bottom,\n    left\n  };\n  const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(paddingBox, base.border);\n  const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.createBox)({\n    borderBox,\n    margin: base.margin,\n    border: base.border,\n    padding: base.padding\n  });\n  return client;\n};\nvar getDimension = ({\n  ref,\n  descriptor,\n  env,\n  windowScroll,\n  direction,\n  isDropDisabled,\n  isCombineEnabled,\n  shouldClipSubject\n}) => {\n  const closestScrollable = env.closestScrollable;\n  const client = getClient(ref, closestScrollable);\n  const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n  const closest = (() => {\n    if (!closestScrollable) {\n      return null;\n    }\n    const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(closestScrollable);\n    const scrollSize = {\n      scrollHeight: closestScrollable.scrollHeight,\n      scrollWidth: closestScrollable.scrollWidth\n    };\n    return {\n      client: frameClient,\n      page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(frameClient, windowScroll),\n      scroll: getScroll(closestScrollable),\n      scrollSize,\n      shouldClipSubject\n    };\n  })();\n  const dimension = getDroppableDimension({\n    descriptor,\n    isEnabled: !isDropDisabled,\n    isCombineEnabled,\n    isFixedOnPage: env.isFixedOnPage,\n    direction,\n    client,\n    page,\n    closest\n  });\n  return dimension;\n};\n\nconst immediate = {\n  passive: false\n};\nconst delayed = {\n  passive: true\n};\nvar getListenerOptions = options => options.shouldPublishImmediately ? immediate : delayed;\n\nconst getClosestScrollableFromDrag = dragging => dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n  const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const appContext = useRequiredContext(AppContext);\n  const uniqueId = useUniqueId('droppable');\n  const {\n    registry,\n    marshal\n  } = appContext;\n  const previousRef = usePrevious(args);\n  const descriptor = useMemo(() => ({\n    id: args.droppableId,\n    type: args.type,\n    mode: args.mode\n  }), [args.droppableId, args.mode, args.type]);\n  const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n  const memoizedUpdateScroll = useMemo(() => memoizeOne((x, y) => {\n    !whileDraggingRef.current ?  true ? invariant(false, 'Can only update scroll when dragging') : 0 : void 0;\n    const scroll = {\n      x,\n      y\n    };\n    marshal.updateDroppableScroll(descriptor.id, scroll);\n  }), [descriptor.id, marshal]);\n  const getClosestScroll = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    if (!dragging || !dragging.env.closestScrollable) {\n      return origin;\n    }\n    return getScroll(dragging.env.closestScrollable);\n  }, []);\n  const updateScroll = useCallback(() => {\n    const scroll = getClosestScroll();\n    memoizedUpdateScroll(scroll.x, scroll.y);\n  }, [getClosestScroll, memoizedUpdateScroll]);\n  const scheduleScrollUpdate = useMemo(() => (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll), [updateScroll]);\n  const onClosestScroll = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Could not find scroll options while scrolling') : 0 : void 0;\n    const options = dragging.scrollOptions;\n    if (options.shouldPublishImmediately) {\n      updateScroll();\n      return;\n    }\n    scheduleScrollUpdate();\n  }, [scheduleScrollUpdate, updateScroll]);\n  const getDimensionAndWatchScroll = useCallback((windowScroll, options) => {\n    !!whileDraggingRef.current ?  true ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : 0 : void 0;\n    const previous = previousRef.current;\n    const ref = previous.getDroppableRef();\n    !ref ?  true ? invariant(false, 'Cannot collect without a droppable ref') : 0 : void 0;\n    const env = getEnv(ref);\n    const dragging = {\n      ref,\n      descriptor,\n      env,\n      scrollOptions: options\n    };\n    whileDraggingRef.current = dragging;\n    const dimension = getDimension({\n      ref,\n      descriptor,\n      env,\n      windowScroll,\n      direction: previous.direction,\n      isDropDisabled: previous.isDropDisabled,\n      isCombineEnabled: previous.isCombineEnabled,\n      shouldClipSubject: !previous.ignoreContainerClipping\n    });\n    const scrollable = env.closestScrollable;\n    if (scrollable) {\n      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n      if (true) {\n        checkForNestedScrollContainers(scrollable);\n      }\n    }\n    return dimension;\n  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);\n  const getScrollWhileDragging = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !(dragging && closest) ?  true ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : 0 : void 0;\n    return getScroll(closest);\n  }, []);\n  const dragStopped = useCallback(() => {\n    const dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot stop drag when no active drag') : 0 : void 0;\n    const closest = getClosestScrollableFromDrag(dragging);\n    whileDraggingRef.current = null;\n    if (!closest) {\n      return;\n    }\n    scheduleScrollUpdate.cancel();\n    closest.removeAttribute(scrollContainer.contextId);\n    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));\n  }, [onClosestScroll, scheduleScrollUpdate]);\n  const scroll = useCallback(change => {\n    const dragging = whileDraggingRef.current;\n    !dragging ?  true ? invariant(false, 'Cannot scroll when there is no drag') : 0 : void 0;\n    const closest = getClosestScrollableFromDrag(dragging);\n    !closest ?  true ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : 0 : void 0;\n    closest.scrollTop += change.y;\n    closest.scrollLeft += change.x;\n  }, []);\n  const callbacks = useMemo(() => {\n    return {\n      getDimensionAndWatchScroll,\n      getScrollWhileDragging,\n      dragStopped,\n      scroll\n    };\n  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);\n  const entry = useMemo(() => ({\n    uniqueId,\n    descriptor,\n    callbacks\n  }), [callbacks, descriptor, uniqueId]);\n  useIsomorphicLayoutEffect(() => {\n    publishedDescriptorRef.current = entry.descriptor;\n    registry.droppable.register(entry);\n    return () => {\n      if (whileDraggingRef.current) {\n         true ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : 0;\n        dragStopped();\n      }\n      registry.droppable.unregister(entry);\n    };\n  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);\n  useIsomorphicLayoutEffect(() => {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n  }, [args.isDropDisabled, marshal]);\n  useIsomorphicLayoutEffect(() => {\n    if (!whileDraggingRef.current) {\n      return;\n    }\n    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n  }, [args.isCombineEnabled, marshal]);\n}\n\nfunction noop() {}\nconst empty = {\n  width: 0,\n  height: 0,\n  margin: noSpacing\n};\nconst getSize = ({\n  isAnimatingOpenOnMount,\n  placeholder,\n  animate\n}) => {\n  if (isAnimatingOpenOnMount) {\n    return empty;\n  }\n  if (animate === 'close') {\n    return empty;\n  }\n  return {\n    height: placeholder.client.borderBox.height,\n    width: placeholder.client.borderBox.width,\n    margin: placeholder.client.margin\n  };\n};\nconst getStyle = ({\n  isAnimatingOpenOnMount,\n  placeholder,\n  animate\n}) => {\n  const size = getSize({\n    isAnimatingOpenOnMount,\n    placeholder,\n    animate\n  });\n  return {\n    display: placeholder.display,\n    boxSizing: 'border-box',\n    width: size.width,\n    height: size.height,\n    marginTop: size.margin.top,\n    marginRight: size.margin.right,\n    marginBottom: size.margin.bottom,\n    marginLeft: size.margin.left,\n    flexShrink: '0',\n    flexGrow: '0',\n    pointerEvents: 'none',\n    transition: animate !== 'none' ? transitions.placeholder : null\n  };\n};\nconst Placeholder = props => {\n  const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const tryClearAnimateOpenTimer = useCallback(() => {\n    if (!animateOpenTimerRef.current) {\n      return;\n    }\n    clearTimeout(animateOpenTimerRef.current);\n    animateOpenTimerRef.current = null;\n  }, []);\n  const {\n    animate,\n    onTransitionEnd,\n    onClose,\n    contextId\n  } = props;\n  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === 'open');\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isAnimatingOpenOnMount) {\n      return noop;\n    }\n    if (animate !== 'open') {\n      tryClearAnimateOpenTimer();\n      setIsAnimatingOpenOnMount(false);\n      return noop;\n    }\n    if (animateOpenTimerRef.current) {\n      return noop;\n    }\n    animateOpenTimerRef.current = setTimeout(() => {\n      animateOpenTimerRef.current = null;\n      setIsAnimatingOpenOnMount(false);\n    });\n    return tryClearAnimateOpenTimer;\n  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);\n  const onSizeChangeEnd = useCallback(event => {\n    if (event.propertyName !== 'height') {\n      return;\n    }\n    onTransitionEnd();\n    if (animate === 'close') {\n      onClose();\n    }\n  }, [animate, onClose, onTransitionEnd]);\n  const style = getStyle({\n    isAnimatingOpenOnMount,\n    animate: props.animate,\n    placeholder: props.placeholder\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n    style,\n    'data-rfd-placeholder-context-id': contextId,\n    onTransitionEnd: onSizeChangeEnd,\n    ref: props.innerRef\n  });\n};\nvar Placeholder$1 = react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\nfunction runChecks(args, checks) {\n  checks.forEach(check => check(args));\n}\nconst shared = [function required({\n  props\n}) {\n  !props.droppableId ?  true ? invariant(false, 'A Droppable requires a droppableId prop') : 0 : void 0;\n  !(typeof props.droppableId === 'string') ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n}, function boolean({\n  props\n}) {\n  !isBoolean(props.isDropDisabled) ?  true ? invariant(false, 'isDropDisabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, 'isCombineEnabled must be a boolean') : 0 : void 0;\n  !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, 'ignoreContainerClipping must be a boolean') : 0 : void 0;\n}, function ref({\n  getDroppableRef\n}) {\n  checkIsValidInnerRef(getDroppableRef());\n}];\nconst standard = [function placeholder({\n  props,\n  getPlaceholderRef\n}) {\n  if (!props.placeholder) {\n    return;\n  }\n  const ref = getPlaceholderRef();\n  if (ref) {\n    return;\n  }\n   true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n}];\nconst virtual = [function hasClone({\n  props\n}) {\n  !props.renderClone ?  true ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : 0 : void 0;\n}, function hasNoPlaceholder({\n  getPlaceholderRef\n}) {\n  !!getPlaceholderRef() ?  true ? invariant(false, 'Expected virtual list to not have a placeholder') : 0 : void 0;\n}];\nfunction useValidation(args) {\n  useDevSetupWarning(() => {\n    runChecks(args, shared);\n    if (args.props.mode === 'standard') {\n      runChecks(args, standard);\n    }\n    if (args.props.mode === 'virtual') {\n      runChecks(args, virtual);\n    }\n  });\n}\n\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      isVisible: Boolean(this.props.on),\n      data: this.props.on,\n      animate: this.props.shouldAnimate && this.props.on ? 'open' : 'none'\n    };\n    this.onClose = () => {\n      if (this.state.animate !== 'close') {\n        return;\n      }\n      this.setState({\n        isVisible: false\n      });\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (!props.shouldAnimate) {\n      return {\n        isVisible: Boolean(props.on),\n        data: props.on,\n        animate: 'none'\n      };\n    }\n    if (props.on) {\n      return {\n        isVisible: true,\n        data: props.on,\n        animate: 'open'\n      };\n    }\n    if (state.isVisible) {\n      return {\n        isVisible: true,\n        data: state.data,\n        animate: 'close'\n      };\n    }\n    return {\n      isVisible: false,\n      animate: 'close',\n      data: null\n    };\n  }\n  render() {\n    if (!this.state.isVisible) {\n      return null;\n    }\n    const provided = {\n      onClose: this.onClose,\n      data: this.state.data,\n      animate: this.state.animate\n    };\n    return this.props.children(provided);\n  }\n}\n\nconst Droppable = props => {\n  const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n  !appContext ?  true ? invariant(false, 'Could not find app context') : 0 : void 0;\n  const {\n    contextId,\n    isMovementAllowed\n  } = appContext;\n  const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    children,\n    droppableId,\n    type,\n    mode,\n    direction,\n    ignoreContainerClipping,\n    isDropDisabled,\n    isCombineEnabled,\n    snapshot,\n    useClone,\n    updateViewportMaxScroll,\n    getContainerForClone\n  } = props;\n  const getDroppableRef = useCallback(() => droppableRef.current, []);\n  const setDroppableRef = useCallback((value = null) => {\n    droppableRef.current = value;\n  }, []);\n  const getPlaceholderRef = useCallback(() => placeholderRef.current, []);\n  const setPlaceholderRef = useCallback((value = null) => {\n    placeholderRef.current = value;\n  }, []);\n  useValidation({\n    props,\n    getDroppableRef,\n    getPlaceholderRef\n  });\n  const onPlaceholderTransitionEnd = useCallback(() => {\n    if (isMovementAllowed()) {\n      updateViewportMaxScroll({\n        maxScroll: getMaxWindowScroll()\n      });\n    }\n  }, [isMovementAllowed, updateViewportMaxScroll]);\n  useDroppablePublisher({\n    droppableId,\n    type,\n    mode,\n    direction,\n    isDropDisabled,\n    isCombineEnabled,\n    ignoreContainerClipping,\n    getDroppableRef\n  });\n  const placeholder = useMemo(() => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n    on: props.placeholder,\n    shouldAnimate: props.shouldAnimatePlaceholder\n  }, ({\n    onClose,\n    data,\n    animate\n  }) => react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n    placeholder: data,\n    onClose: onClose,\n    innerRef: setPlaceholderRef,\n    animate: animate,\n    contextId: contextId,\n    onTransitionEnd: onPlaceholderTransitionEnd\n  })), [contextId, onPlaceholderTransitionEnd, props.placeholder, props.shouldAnimatePlaceholder, setPlaceholderRef]);\n  const provided = useMemo(() => ({\n    innerRef: setDroppableRef,\n    placeholder,\n    droppableProps: {\n      'data-rfd-droppable-id': droppableId,\n      'data-rfd-droppable-context-id': contextId\n    }\n  }), [contextId, droppableId, placeholder, setDroppableRef]);\n  const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n  const droppableContext = useMemo(() => ({\n    droppableId,\n    type,\n    isUsingCloneFor\n  }), [droppableId, isUsingCloneFor, type]);\n  function getClone() {\n    if (!useClone) {\n      return null;\n    }\n    const {\n      dragging,\n      render\n    } = useClone;\n    const node = react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n      draggableId: dragging.draggableId,\n      index: dragging.source.index,\n      isClone: true,\n      isEnabled: true,\n      shouldRespectForcePress: false,\n      canDragInteractiveElements: true\n    }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));\n    return react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n    value: droppableContext\n  }, children(provided, snapshot), getClone());\n};\n\nfunction getBody() {\n  !document.body ?  true ? invariant(false, 'document.body is not ready') : 0 : void 0;\n  return document.body;\n}\nconst defaultProps = {\n  mode: 'standard',\n  type: 'DEFAULT',\n  direction: 'vertical',\n  isDropDisabled: false,\n  isCombineEnabled: false,\n  ignoreContainerClipping: false,\n  renderClone: null,\n  getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = ownProps => {\n  let mergedProps = {\n    ...ownProps\n  };\n  let defaultPropKey;\n  for (defaultPropKey in defaultProps) {\n    if (ownProps[defaultPropKey] === undefined) {\n      mergedProps = {\n        ...mergedProps,\n        [defaultPropKey]: defaultProps[defaultPropKey]\n      };\n    }\n  }\n  return mergedProps;\n};\nconst isMatchingType = (type, critical) => type === critical.droppable.type;\nconst getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = () => {\n  const idleWithAnimation = {\n    placeholder: null,\n    shouldAnimatePlaceholder: true,\n    snapshot: {\n      isDraggingOver: false,\n      draggingOverWith: null,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: false\n    },\n    useClone: null\n  };\n  const idleWithoutAnimation = {\n    ...idleWithAnimation,\n    shouldAnimatePlaceholder: false\n  };\n  const getDraggableRubric = memoizeOne(descriptor => ({\n    draggableId: descriptor.id,\n    type: descriptor.type,\n    source: {\n      index: descriptor.index,\n      droppableId: descriptor.droppableId\n    }\n  }));\n  const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {\n    const draggableId = dragging.descriptor.id;\n    const isHome = dragging.descriptor.droppableId === id;\n    if (isHome) {\n      const useClone = renderClone ? {\n        render: renderClone,\n        dragging: getDraggableRubric(dragging.descriptor)\n      } : null;\n      const snapshot = {\n        isDraggingOver: isDraggingOverForConsumer,\n        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n        draggingFromThisWith: draggableId,\n        isUsingPlaceholder: true\n      };\n      return {\n        placeholder: dragging.placeholder,\n        shouldAnimatePlaceholder: false,\n        snapshot,\n        useClone\n      };\n    }\n    if (!isEnabled) {\n      return idleWithoutAnimation;\n    }\n    if (!isDraggingOverForImpact) {\n      return idleWithAnimation;\n    }\n    const snapshot = {\n      isDraggingOver: isDraggingOverForConsumer,\n      draggingOverWith: draggableId,\n      draggingFromThisWith: null,\n      isUsingPlaceholder: true\n    };\n    return {\n      placeholder: dragging.placeholder,\n      shouldAnimatePlaceholder: true,\n      snapshot,\n      useClone: null\n    };\n  });\n  const selector = (state, ownProps) => {\n    const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n    const id = ownPropsWithDefaultProps.droppableId;\n    const type = ownPropsWithDefaultProps.type;\n    const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n    const renderClone = ownPropsWithDefaultProps.renderClone;\n    if (isDragging(state)) {\n      const critical = state.critical;\n      if (!isMatchingType(type, critical)) {\n        return idleWithoutAnimation;\n      }\n      const dragging = getDraggable(critical, state.dimensions);\n      const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n    }\n    if (state.phase === 'DROP_ANIMATING') {\n      const completed = state.completed;\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n      const dragging = getDraggable(completed.critical, state.dimensions);\n      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n    }\n    if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {\n      const completed = state.completed;\n      if (!isMatchingType(type, completed.critical)) {\n        return idleWithoutAnimation;\n      }\n      const wasOver = whatIsDraggedOver(completed.impact) === id;\n      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === 'COMBINE');\n      const isHome = completed.critical.droppable.id === id;\n      if (wasOver) {\n        return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n      }\n      if (isHome) {\n        return idleWithAnimation;\n      }\n      return idleWithoutAnimation;\n    }\n    return idleWithoutAnimation;\n  };\n  return selector;\n};\nconst mapDispatchToProps = {\n  updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {\n  return {\n    ...attachDefaultPropsToOwnProps(ownProps),\n    ...stateProps,\n    ...dispatchProps\n  };\n}, {\n  context: StoreContext,\n  areStatePropsEqual: isStrictEqual\n})(Droppable);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RjtBQUN4QztBQUNtRDtBQUNuRDtBQUNxRDtBQUN0RTtBQUMyQjs7QUFFMUQsdUJBQXVCLGFBQW9CO0FBQzNDLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBLGlGQUFpRixrQkFBa0Isa0JBQWtCLHVDQUF1QztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEscUJBQXFCLGFBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLFNBQVMsSUFBSSxjQUFjO0FBQ3pEO0FBQ0E7O0FBRUEsNEJBQTRCLHdEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQSxXQUFXLENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGNBQWM7QUFDZCxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLCtCQUErQjtBQUMvQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsK0NBQVE7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsNkNBQU07QUFDM0Isb0JBQW9CLDZDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGlCQUFpQixzREFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUFxQyxpQkFBaUIsQ0FBVztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBcUMsOERBQThELENBQVc7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQU8sQ0FBQyxxREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLEtBQXFDLG1GQUFtRixDQUFXO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEsS0FBcUMsaUJBQWlCLENBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QixxREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQyxnRUFBZ0UsQ0FBVztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBcUMsdUVBQXVFLENBQVc7QUFDNUosd0NBQXdDLEtBQXFDLDBGQUEwRixDQUFXO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFxQyxvRkFBb0YsQ0FBVztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBcUMsOEdBQThHLENBQVc7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw4Q0FBOEMsc0RBQU87O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUNBQXFDLEtBQXFDLGlCQUFpQixDQUFXO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxLQUFxQywwRUFBMEUsQ0FBVztBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1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Z0IsS0FBcUMsa0VBQWtFLENBQVc7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXFDLHFGQUFxRixDQUFXO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQXFDLGtGQUFrRixDQUFXO0FBQzFLO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FB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O0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFxQyxxR0FBcUcsQ0FBVztBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHVCQUF1QixLQUFxQyx3Q0FBd0MsQ0FBVztBQUMvRztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsQ0FBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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R0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsMEJBQTBCLDZDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMsS0FBcUMsb0VBQW9FLENBQVc7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQXFDLGtGQUFrRixDQUFXO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQXFDLGlCQUFpQixDQUFXO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBTTtBQUN6QiwwQkFBMEIsNkNBQU07QUFDaEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQyxLQUFxQyx3REFBd0QsV0FBVyxLQUFLLENBQVc7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxvQ0FBb0MsS0FBcUMsb0VBQW9FLENBQVc7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFxQyxpRkFBaUYsQ0FBZ0I7QUFDbk0sS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsc0RBQU87O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUJBQXFCLElBQUksVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUMsK0NBQStDLENBQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUMsa0RBQWtELENBQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0IsSUFBSSxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUMsdURBQXVELENBQU07QUFDdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBLFdBQVcsQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyxnREFBZ0QsWUFBWSxLQUFLLENBQU07QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyx3REFBd0QsWUFBWSxLQUFLLENBQU07QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNENBQTRDLE1BQU0sS0FBSyxDQUFXO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTztBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQVM7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMERBQW1CLENBQUMsdURBQWM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQU87QUFDbEM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQW1CLG1CQUFtQiw4RUFBUSxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLGlCQUFpQixDQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQXFDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxDQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFxQztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLENBQU07QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTTtBQUMxQixpQkFBaUIsd0RBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQyw2Q0FBTTtBQUN2QztBQUNBLGdDQUFnQyxLQUFxQyw4REFBOEQsQ0FBVztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkNBQTZDLG9EQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFxQyx1RUFBdUUsQ0FBVztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUMsS0FBcUMsOEVBQThFLENBQVc7QUFDL0o7QUFDQTtBQUNBLFdBQVcsS0FBcUMsZ0VBQWdFLENBQVc7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQXFDLHlHQUF5RyxDQUFXO0FBQ3RMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUMsOERBQThELENBQVc7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXFDLDZEQUE2RCxDQUFXO0FBQzdIO0FBQ0EsZUFBZSxLQUFxQyw4RUFBOEUsQ0FBVztBQUM3STtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLDJGQUEyRixDQUFNO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4REFBOEQsK0NBQVE7QUFDdEUsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDBEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixpREFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUIsS0FBcUMsaUVBQWlFLENBQVc7QUFDeEksNkNBQTZDLEtBQXFDLCtFQUErRSx5QkFBeUIsTUFBTSxDQUFXO0FBQzNNLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxxQ0FBcUMsS0FBcUMsMERBQTBELENBQVc7QUFDL0ksdUNBQXVDLEtBQXFDLDREQUE0RCxDQUFXO0FBQ25KLDhDQUE4QyxLQUFxQyxtRUFBbUUsQ0FBVztBQUNqSyxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFxQztBQUN2Qyw2Q0FBNkMsa0JBQWtCO0FBQy9EOztBQUVBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSxTQUFTLENBQU07QUFDZixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUIsS0FBcUMsOEZBQThGLENBQVc7QUFDckssQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELDBCQUEwQixLQUFxQyx5RUFBeUUsQ0FBVztBQUNuSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDJCQUEyQiw0REFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CLGdCQUFnQixLQUFxQyxvREFBb0QsQ0FBVztBQUNwSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLDZDQUFNO0FBQzdCLHlCQUF5Qiw2Q0FBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MsMERBQW1CO0FBQ3ZEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxLQUFLLDBEQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsMERBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDZEQUFxQjtBQUNoQztBQUNBLFNBQVMsMERBQW1CO0FBQzVCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsbUJBQW1CLEtBQXFDLG9EQUFvRCxDQUFXO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFNEkiLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN0aW50cm9vc3QvRG9jdW1lbnRzL3NpdGVzL3l1c3Rib2FyZC9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmUkMSwgY29tcG9zZSwgYXBwbHlNaWRkbGV3YXJlLCBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGdldFJlY3QsIGV4cGFuZCwgb2Zmc2V0LCB3aXRoU2Nyb2xsLCBjYWxjdWxhdGVCb3gsIGdldEJveCwgY3JlYXRlQm94IH0gZnJvbSAnY3NzLWJveC1tb2RlbCc7XG5pbXBvcnQgcmFmU2NoZCBmcm9tICdyYWYtc2NoZCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiQxID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmNvbnN0IHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuY29uc3QgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbmNvbnN0IGNsZWFuJDIgPSB2YWx1ZSA9PiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xuY29uc3QgZ2V0RGV2TWVzc2FnZSA9IG1lc3NhZ2UgPT4gY2xlYW4kMihgXG4gICVjQGhlbGxvLXBhbmdlYS9kbmRcblxuICAlYyR7Y2xlYW4kMihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50IG9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuYCk7XG5jb25zdCBnZXRGb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZSA9PiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuMmVtOyBmb250LXdlaWdodDogYm9sZDsnLCAnbGluZS1oZWlnaHQ6IDEuNScsICdjb2xvcjogIzcyMzg3NDsnXTtcbmNvbnN0IGlzRGlzYWJsZWRGbGFnID0gJ19fQGhlbGxvLXBhbmdlYS9kbmQtZGlzYWJsZS1kZXYtd2FybmluZ3MnO1xuZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzUHJvZHVjdGlvbiQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbaXNEaXNhYmxlZEZsYWddKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGVbdHlwZV0oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG59XG5jb25zdCB3YXJuaW5nID0gbG9nLmJpbmQobnVsbCwgJ3dhcm4nKTtcbmNvbnN0IGVycm9yID0gbG9nLmJpbmQobnVsbCwgJ2Vycm9yJyk7XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoc2hhcmVkLCBmcm9tQmluZGluZykge1xuICByZXR1cm4ge1xuICAgIC4uLnNoYXJlZCxcbiAgICAuLi5mcm9tQmluZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhlbCwgYmluZGluZ3MsIHNoYXJlZE9wdGlvbnMpIHtcbiAgY29uc3QgdW5iaW5kaW5ncyA9IGJpbmRpbmdzLm1hcChiaW5kaW5nID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhzaGFyZWRPcHRpb25zLCBiaW5kaW5nLm9wdGlvbnMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICB1bmJpbmRpbmdzLmZvckVhY2godW5iaW5kID0+IHtcbiAgICAgIHVuYmluZCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3QgcHJlZml4JDEgPSAnSW52YXJpYW50IGZhaWxlZCc7XG5jbGFzcyBSYmRJbnZhcmlhbnQgZXh0ZW5kcyBFcnJvciB7fVxuUmJkSW52YXJpYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgIHRocm93IG5ldyBSYmRJbnZhcmlhbnQocHJlZml4JDEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYmRJbnZhcmlhbnQoYCR7cHJlZml4JDF9OiAke21lc3NhZ2UgfHwgJyd9YCk7XG4gIH1cbn1cblxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy51bmJpbmQgPSBub29wJDI7XG4gICAgdGhpcy5vbldpbmRvd0Vycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5nZXRDYWxsYmFja3MoKTtcbiAgICAgIGlmIChjYWxsYmFja3MuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIGNhbGxiYWNrcy50cnlBYm9ydCgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW4gZXJyb3Igd2FzIGNhdWdodCBieSBvdXIgd2luZG93ICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgd2hpbGUgYSBkcmFnIHdhcyBvY2N1cnJpbmcuXG4gICAgICAgIFRoZSBhY3RpdmUgZHJhZyBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnIgPSBldmVudC5lcnJvcjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSYmRJbnZhcmlhbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIEFwcENhbGxiYWNrcyBpbiA8RXJyb3JCb3VuZGFyeS8+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3M7XG4gICAgfTtcbiAgICB0aGlzLnNldENhbGxiYWNrcyA9IGNhbGxiYWNrcyA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICBldmVudE5hbWU6ICdlcnJvcicsXG4gICAgICBmbjogdGhpcy5vbldpbmRvd0Vycm9yXG4gICAgfV0pO1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSYmRJbnZhcmlhbnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zZXRDYWxsYmFja3MpO1xuICB9XG59XG5cbmNvbnN0IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IGBcbiAgUHJlc3Mgc3BhY2UgYmFyIHRvIHN0YXJ0IGEgZHJhZy5cbiAgV2hlbiBkcmFnZ2luZyB5b3UgY2FuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpdGVtIGFyb3VuZCBhbmQgZXNjYXBlIHRvIGNhbmNlbC5cbiAgU29tZSBzY3JlZW4gcmVhZGVycyBtYXkgcmVxdWlyZSB5b3UgdG8gYmUgaW4gZm9jdXMgbW9kZSBvciB0byB1c2UgeW91ciBwYXNzIHRocm91Z2gga2V5XG5gO1xuY29uc3QgcG9zaXRpb24gPSBpbmRleCA9PiBpbmRleCArIDE7XG5jb25zdCBvbkRyYWdTdGFydCA9IHN0YXJ0ID0+IGBcbiAgWW91IGhhdmUgbGlmdGVkIGFuIGl0ZW0gaW4gcG9zaXRpb24gJHtwb3NpdGlvbihzdGFydC5zb3VyY2UuaW5kZXgpfVxuYDtcbmNvbnN0IHdpdGhMb2NhdGlvbiA9IChzb3VyY2UsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGlzSW5Ib21lTGlzdCA9IHNvdXJjZS5kcm9wcGFibGVJZCA9PT0gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbihzb3VyY2UuaW5kZXgpO1xuICBjb25zdCBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uKGRlc3RpbmF0aW9uLmluZGV4KTtcbiAgaWYgKGlzSW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBtb3ZlZCB0aGUgaXRlbSBmcm9tIHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn1cbiAgICAgIHRvIHBvc2l0aW9uICR7ZW5kUG9zaXRpb259XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgIGluIGxpc3QgJHtzb3VyY2UuZHJvcHBhYmxlSWR9XG4gICAgdG8gbGlzdCAke2Rlc3RpbmF0aW9uLmRyb3BwYWJsZUlkfVxuICAgIGluIHBvc2l0aW9uICR7ZW5kUG9zaXRpb259XG4gIGA7XG59O1xuY29uc3Qgd2l0aENvbWJpbmUgPSAoaWQsIHNvdXJjZSwgY29tYmluZSkgPT4ge1xuICBjb25zdCBpbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBjb21iaW5lLmRyb3BwYWJsZUlkO1xuICBpZiAoaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaGFzIGJlZW4gY29tYmluZWQgd2l0aCAke2NvbWJpbmUuZHJhZ2dhYmxlSWR9YDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgVGhlIGl0ZW0gJHtpZH1cbiAgICAgIGluIGxpc3QgJHtzb3VyY2UuZHJvcHBhYmxlSWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1cbiAgICAgIGluIGxpc3QgJHtjb21iaW5lLmRyb3BwYWJsZUlkfVxuICAgIGA7XG59O1xuY29uc3Qgb25EcmFnVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgY29uc3QgbG9jYXRpb24gPSB1cGRhdGUuZGVzdGluYXRpb247XG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiB3aXRoTG9jYXRpb24odXBkYXRlLnNvdXJjZSwgbG9jYXRpb24pO1xuICB9XG4gIGNvbnN0IGNvbWJpbmUgPSB1cGRhdGUuY29tYmluZTtcbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gd2l0aENvbWJpbmUodXBkYXRlLmRyYWdnYWJsZUlkLCB1cGRhdGUuc291cmNlLCBjb21iaW5lKTtcbiAgfVxuICByZXR1cm4gJ1lvdSBhcmUgb3ZlciBhbiBhcmVhIHRoYXQgY2Fubm90IGJlIGRyb3BwZWQgb24nO1xufTtcbmNvbnN0IHJldHVybmVkVG9TdGFydCA9IHNvdXJjZSA9PiBgXG4gIFRoZSBpdGVtIGhhcyByZXR1cm5lZCB0byBpdHMgc3RhcnRpbmcgcG9zaXRpb25cbiAgb2YgJHtwb3NpdGlvbihzb3VyY2UuaW5kZXgpfVxuYDtcbmNvbnN0IG9uRHJhZ0VuZCA9IHJlc3VsdCA9PiB7XG4gIGlmIChyZXN1bHQucmVhc29uID09PSAnQ0FOQ0VMJykge1xuICAgIHJldHVybiBgXG4gICAgICBNb3ZlbWVudCBjYW5jZWxsZWQuXG4gICAgICAke3JldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKX1cbiAgICBgO1xuICB9XG4gIGNvbnN0IGxvY2F0aW9uID0gcmVzdWx0LmRlc3RpbmF0aW9uO1xuICBjb25zdCBjb21iaW5lID0gcmVzdWx0LmNvbWJpbmU7XG4gIGlmIChsb2NhdGlvbikge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoTG9jYXRpb24ocmVzdWx0LnNvdXJjZSwgbG9jYXRpb24pfVxuICAgIGA7XG4gIH1cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gYFxuICAgICAgWW91IGhhdmUgZHJvcHBlZCB0aGUgaXRlbS5cbiAgICAgICR7d2l0aENvbWJpbmUocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuc291cmNlLCBjb21iaW5lKX1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgVGhlIGl0ZW0gaGFzIGJlZW4gZHJvcHBlZCB3aGlsZSBub3Qgb3ZlciBhIGRyb3AgYXJlYS5cbiAgICAke3JldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKX1cbiAgYDtcbn07XG5jb25zdCBwcmVzZXQgPSB7XG4gIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgb25EcmFnU3RhcnQsXG4gIG9uRHJhZ1VwZGF0ZSxcbiAgb25EcmFnRW5kXG59O1xuXG5mdW5jdGlvbiBpc0VxdWFsJDIoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZmlyc3QpICYmIE51bWJlci5pc05hTihzZWNvbmQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gIGlmIChuZXdJbnB1dHMubGVuZ3RoICE9PSBsYXN0SW5wdXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNFcXVhbCQyKG5ld0lucHV0c1tpXSwgbGFzdElucHV0c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8oZ2V0UmVzdWx0LCBpbnB1dHMpIHtcbiAgY29uc3QgaW5pdGlhbCA9IHVzZVN0YXRlKCgpID0+ICh7XG4gICAgaW5wdXRzLFxuICAgIHJlc3VsdDogZ2V0UmVzdWx0KClcbiAgfSkpWzBdO1xuICBjb25zdCBpc0ZpcnN0UnVuID0gdXNlUmVmKHRydWUpO1xuICBjb25zdCBjb21taXR0ZWQgPSB1c2VSZWYoaW5pdGlhbCk7XG4gIGNvbnN0IHVzZUNhY2hlID0gaXNGaXJzdFJ1bi5jdXJyZW50IHx8IEJvb2xlYW4oaW5wdXRzICYmIGNvbW1pdHRlZC5jdXJyZW50LmlucHV0cyAmJiBhcmVJbnB1dHNFcXVhbChpbnB1dHMsIGNvbW1pdHRlZC5jdXJyZW50LmlucHV0cykpO1xuICBjb25zdCBjYWNoZSA9IHVzZUNhY2hlID8gY29tbWl0dGVkLmN1cnJlbnQgOiB7XG4gICAgaW5wdXRzLFxuICAgIHJlc3VsdDogZ2V0UmVzdWx0KClcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0ZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBjb21taXR0ZWQuY3VycmVudCA9IGNhY2hlO1xuICB9LCBbY2FjaGVdKTtcbiAgcmV0dXJuIGNhY2hlLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBpbnB1dHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGlucHV0cyk7XG59XG5cbmNvbnN0IG9yaWdpbiA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbmNvbnN0IGFkZCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggKyBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgKyBwb2ludDIueVxufSk7XG5jb25zdCBzdWJ0cmFjdCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxufSk7XG5jb25zdCBpc0VxdWFsJDEgPSAocG9pbnQxLCBwb2ludDIpID0+IHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG5jb25zdCBuZWdhdGUgPSBwb2ludCA9PiAoe1xuICB4OiBwb2ludC54ICE9PSAwID8gLXBvaW50LnggOiAwLFxuICB5OiBwb2ludC55ICE9PSAwID8gLXBvaW50LnkgOiAwXG59KTtcbmNvbnN0IHBhdGNoID0gKGxpbmUsIHZhbHVlLCBvdGhlclZhbHVlID0gMCkgPT4ge1xuICBpZiAobGluZSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZhbHVlLFxuICAgICAgeTogb3RoZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBvdGhlclZhbHVlLFxuICAgIHk6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAocG9pbnQxLCBwb2ludDIpID0+IE1hdGguc3FydCgocG9pbnQyLnggLSBwb2ludDEueCkgKiogMiArIChwb2ludDIueSAtIHBvaW50MS55KSAqKiAyKTtcbmNvbnN0IGNsb3Nlc3QkMSA9ICh0YXJnZXQsIHBvaW50cykgPT4gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBkaXN0YW5jZSh0YXJnZXQsIHBvaW50KSkpO1xuY29uc3QgYXBwbHkgPSBmbiA9PiBwb2ludCA9PiAoe1xuICB4OiBmbihwb2ludC54KSxcbiAgeTogZm4ocG9pbnQueSlcbn0pO1xuXG52YXIgZXhlY3V0ZUNsaXAgPSAoZnJhbWUsIHN1YmplY3QpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBNYXRoLm1heChzdWJqZWN0LnRvcCwgZnJhbWUudG9wKSxcbiAgICByaWdodDogTWF0aC5taW4oc3ViamVjdC5yaWdodCwgZnJhbWUucmlnaHQpLFxuICAgIGJvdHRvbTogTWF0aC5taW4oc3ViamVjdC5ib3R0b20sIGZyYW1lLmJvdHRvbSksXG4gICAgbGVmdDogTWF0aC5tYXgoc3ViamVjdC5sZWZ0LCBmcmFtZS5sZWZ0KVxuICB9KTtcbiAgaWYgKHJlc3VsdC53aWR0aCA8PSAwIHx8IHJlc3VsdC5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBvZmZzZXRCeVBvc2l0aW9uID0gKHNwYWNpbmcsIHBvaW50KSA9PiAoe1xuICB0b3A6IHNwYWNpbmcudG9wICsgcG9pbnQueSxcbiAgbGVmdDogc3BhY2luZy5sZWZ0ICsgcG9pbnQueCxcbiAgYm90dG9tOiBzcGFjaW5nLmJvdHRvbSArIHBvaW50LnksXG4gIHJpZ2h0OiBzcGFjaW5nLnJpZ2h0ICsgcG9pbnQueFxufSk7XG5jb25zdCBnZXRDb3JuZXJzID0gc3BhY2luZyA9PiBbe1xuICB4OiBzcGFjaW5nLmxlZnQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcucmlnaHQsXG4gIHk6IHNwYWNpbmcudG9wXG59LCB7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy5ib3R0b21cbn1dO1xuY29uc3Qgbm9TcGFjaW5nID0ge1xuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDBcbn07XG5cbmNvbnN0IHNjcm9sbCQxID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcbmNvbnN0IGluY3JlYXNlID0gKHRhcmdldCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKSA9PiB7XG4gIGlmICh3aXRoUGxhY2Vob2xkZXIgJiYgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIFtheGlzLmVuZF06IHRhcmdldFtheGlzLmVuZF0gKyB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnlbYXhpcy5saW5lXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCBjbGlwID0gKHRhcmdldCwgZnJhbWUpID0+IHtcbiAgaWYgKGZyYW1lICYmIGZyYW1lLnNob3VsZENsaXBTdWJqZWN0KSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVDbGlwKGZyYW1lLnBhZ2VNYXJnaW5Cb3gsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGdldFJlY3QodGFyZ2V0KTtcbn07XG52YXIgZ2V0U3ViamVjdCA9ICh7XG4gIHBhZ2UsXG4gIHdpdGhQbGFjZWhvbGRlcixcbiAgYXhpcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGwkMShwYWdlLm1hcmdpbkJveCwgZnJhbWUpO1xuICBjb25zdCBpbmNyZWFzZWQgPSBpbmNyZWFzZShzY3JvbGxlZCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKTtcbiAgY29uc3QgY2xpcHBlZCA9IGNsaXAoaW5jcmVhc2VkLCBmcmFtZSk7XG4gIHJldHVybiB7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXIsXG4gICAgYWN0aXZlOiBjbGlwcGVkXG4gIH07XG59O1xuXG52YXIgc2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgbmV3U2Nyb2xsKSA9PiB7XG4gICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBzY3JvbGxhYmxlID0gZHJvcHBhYmxlLmZyYW1lO1xuICBjb25zdCBzY3JvbGxEaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsKTtcbiAgY29uc3Qgc2Nyb2xsRGlzcGxhY2VtZW50ID0gbmVnYXRlKHNjcm9sbERpZmYpO1xuICBjb25zdCBmcmFtZSA9IHtcbiAgICAuLi5zY3JvbGxhYmxlLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IHNjcm9sbERpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogc2Nyb2xsRGlzcGxhY2VtZW50XG4gICAgICB9LFxuICAgICAgbWF4OiBzY3JvbGxhYmxlLnNjcm9sbC5tYXhcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwgPSBhcmVJbnB1dHNFcXVhbCkge1xuICBsZXQgY2FjaGUgPSBudWxsO1xuICBmdW5jdGlvbiBtZW1vaXplZCguLi5uZXdBcmdzKSB7XG4gICAgaWYgKGNhY2hlICYmIGNhY2hlLmxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgY2FjaGUubGFzdEFyZ3MpKSB7XG4gICAgICByZXR1cm4gY2FjaGUubGFzdFJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgIGNhY2hlID0ge1xuICAgICAgbGFzdFJlc3VsdCxcbiAgICAgIGxhc3RBcmdzOiBuZXdBcmdzLFxuICAgICAgbGFzdFRoaXM6IHRoaXNcbiAgICB9O1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9XG4gIG1lbW9pemVkLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY2FjaGUgPSBudWxsO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbmNvbnN0IHRvRHJvcHBhYmxlTWFwID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IGRyb3BwYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTWFwID0gbWVtb2l6ZU9uZShkcmFnZ2FibGVzID0+IGRyYWdnYWJsZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICBwcmV2aW91c1tjdXJyZW50LmRlc2NyaXB0b3IuaWRdID0gY3VycmVudDtcbiAgcmV0dXJuIHByZXZpb3VzO1xufSwge30pKTtcbmNvbnN0IHRvRHJvcHBhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyb3BwYWJsZXMpKTtcbmNvbnN0IHRvRHJhZ2dhYmxlTGlzdCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBPYmplY3QudmFsdWVzKGRyYWdnYWJsZXMpKTtcblxudmFyIGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUgPSBtZW1vaXplT25lKChkcm9wcGFibGVJZCwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSB0b0RyYWdnYWJsZUxpc3QoZHJhZ2dhYmxlcykuZmlsdGVyKGRyYWdnYWJsZSA9PiBkcm9wcGFibGVJZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpLnNvcnQoKGEsIGIpID0+IGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuZGVzdGluYXRpb247XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cnlHZXRDb21iaW5lKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmNvbWJpbmU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCA9IG1lbW9pemVPbmUoKHJlbW92ZSwgbGlzdCkgPT4gbGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlc2NyaXB0b3IuaWQgIT09IHJlbW92ZS5kZXNjcmlwdG9yLmlkKSk7XG5cbnZhciBtb3ZlVG9OZXh0Q29tYmluZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIHByZXZpb3VzSW1wYWN0XG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24ocHJldmlvdXNJbXBhY3QpO1xuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW1wYWN0KHRhcmdldCkge1xuICAgIGNvbnN0IGF0ID0ge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogdGFyZ2V0LFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnByZXZpb3VzSW1wYWN0LFxuICAgICAgYXRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGFsbCA9IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZC5hbGw7XG4gIGNvbnN0IGNsb3Nlc3RJZCA9IGFsbC5sZW5ndGggPyBhbGxbMF0gOiBudWxsO1xuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3RJZCA/IGdldEltcGFjdChjbG9zZXN0SWQpIDogbnVsbDtcbiAgfVxuICBjb25zdCB3aXRob3V0RHJhZ2dhYmxlID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGlmICghY2xvc2VzdElkKSB7XG4gICAgaWYgKCF3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB3aXRob3V0RHJhZ2dhYmxlW3dpdGhvdXREcmFnZ2FibGUubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGdldEltcGFjdChsYXN0LmRlc2NyaXB0b3IuaWQpO1xuICB9XG4gIGNvbnN0IGluZGV4T2ZDbG9zZXN0ID0gd2l0aG91dERyYWdnYWJsZS5maW5kSW5kZXgoZCA9PiBkLmRlc2NyaXB0b3IuaWQgPT09IGNsb3Nlc3RJZCk7XG4gICEoaW5kZXhPZkNsb3Nlc3QgIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGRpc3BsYWNlZCBpdGVtIGluIHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSBpbmRleE9mQ2xvc2VzdCAtIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGJlZm9yZSA9IHdpdGhvdXREcmFnZ2FibGVbcHJvcG9zZWRJbmRleF07XG4gIHJldHVybiBnZXRJbXBhY3QoYmVmb3JlLmRlc2NyaXB0b3IuaWQpO1xufTtcblxudmFyIGlzSG9tZU9mID0gKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID0+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkO1xuXG5jb25zdCBub0Rpc3BsYWNlZEJ5ID0ge1xuICBwb2ludDogb3JpZ2luLFxuICB2YWx1ZTogMFxufTtcbmNvbnN0IGVtcHR5R3JvdXBzID0ge1xuICBpbnZpc2libGU6IHt9LFxuICB2aXNpYmxlOiB7fSxcbiAgYWxsOiBbXVxufTtcbmNvbnN0IG5vSW1wYWN0ID0ge1xuICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgYXQ6IG51bGxcbn07XG5cbnZhciBpc1dpdGhpbiA9IChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA9PiB2YWx1ZSA9PiBsb3dlckJvdW5kIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVwcGVyQm91bmQ7XG5cbnZhciBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIGlmIChpc0NvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSB8fCBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKTtcbiAgICBjb25zdCBpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkgPSBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSB8fCBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlDb250YWluZWQgPSBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseTtcbiAgICBpZiAoaXNQYXJ0aWFsbHlDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0JpZ2dlclZlcnRpY2FsbHkgPSBzdWJqZWN0LnRvcCA8IGZyYW1lLnRvcCAmJiBzdWJqZWN0LmJvdHRvbSA+IGZyYW1lLmJvdHRvbTtcbiAgICBjb25zdCBpc0JpZ2dlckhvcml6b250YWxseSA9IHN1YmplY3QubGVmdCA8IGZyYW1lLmxlZnQgJiYgc3ViamVjdC5yaWdodCA+IGZyYW1lLnJpZ2h0O1xuICAgIGNvbnN0IGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzQmlnZ2VySG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSB8fCBpc0JpZ2dlckhvcml6b250YWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5O1xuICAgIHJldHVybiBpc1RhcmdldEJpZ2dlck9uT25lQXhpcztcbiAgfTtcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gZnJhbWUgPT4ge1xuICBjb25zdCBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICBjb25zdCBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBzdWJqZWN0ID0+IHtcbiAgICBjb25zdCBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICByZXR1cm4gaXNDb250YWluZWQ7XG4gIH07XG59O1xuXG5jb25zdCB2ZXJ0aWNhbCA9IHtcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBsaW5lOiAneScsXG4gIGNyb3NzQXhpc0xpbmU6ICd4JyxcbiAgc3RhcnQ6ICd0b3AnLFxuICBlbmQ6ICdib3R0b20nLFxuICBzaXplOiAnaGVpZ2h0JyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICdsZWZ0JyxcbiAgY3Jvc3NBeGlzRW5kOiAncmlnaHQnLFxuICBjcm9zc0F4aXNTaXplOiAnd2lkdGgnXG59O1xuY29uc3QgaG9yaXpvbnRhbCA9IHtcbiAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIGxpbmU6ICd4JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3knLFxuICBzdGFydDogJ2xlZnQnLFxuICBlbmQ6ICdyaWdodCcsXG4gIHNpemU6ICd3aWR0aCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAndG9wJyxcbiAgY3Jvc3NBeGlzRW5kOiAnYm90dG9tJyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ2hlaWdodCdcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzID0gYXhpcyA9PiBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGlmIChheGlzID09PSB2ZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICB9O1xufTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlRGlzcGxhY2VkID0gKHRhcmdldCwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGVzdGluYXRpb24uZnJhbWUgPyBkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQgOiBvcmlnaW47XG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZGlzcGxhY2VtZW50KTtcbn07XG5jb25zdCBpc1Zpc2libGVJbkRyb3BwYWJsZSA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbihkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkodGFyZ2V0KTtcbn07XG5jb25zdCBpc1Zpc2libGVJblZpZXdwb3J0ID0gKHRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSA9PiBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbih2aWV3cG9ydCkodGFyZ2V0KTtcbmNvbnN0IGlzVmlzaWJsZSQxID0gKHtcbiAgdGFyZ2V0OiB0b0JlRGlzcGxhY2VkLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuXG59KSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlZFRhcmdldCA9IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPyBnZXREcm9wcGFibGVEaXNwbGFjZWQodG9CZURpc3BsYWNlZCwgZGVzdGluYXRpb24pIDogdG9CZURpc3BsYWNlZDtcbiAgcmV0dXJuIGlzVmlzaWJsZUluRHJvcHBhYmxlKGRpc3BsYWNlZFRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSAmJiBpc1Zpc2libGVJblZpZXdwb3J0KGRpc3BsYWNlZFRhcmdldCwgdmlld3BvcnQsIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKTtcbn07XG5jb25zdCBpc1BhcnRpYWxseVZpc2libGUgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG59KTtcbmNvbnN0IGlzVG90YWxseVZpc2libGVPbkF4aXMgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMoYXJncy5kZXN0aW5hdGlvbi5heGlzKVxufSk7XG5cbmNvbnN0IGdldFNob3VsZEFuaW1hdGUgPSAoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSkgPT4ge1xuICBpZiAodHlwZW9mIGZvcmNlU2hvdWxkQW5pbWF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW52aXNpYmxlLFxuICAgIHZpc2libGVcbiAgfSA9IGxhc3Q7XG4gIGlmIChpbnZpc2libGVbaWRdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzID0gdmlzaWJsZVtpZF07XG4gIHJldHVybiBwcmV2aW91cyA/IHByZXZpb3VzLnNob3VsZEFuaW1hdGUgOiB0cnVlO1xufTtcbmZ1bmN0aW9uIGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KSB7XG4gIGNvbnN0IG1hcmdpbkJveCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcbiAgY29uc3QgZXhwYW5kQnkgPSB7XG4gICAgdG9wOiBkaXNwbGFjZWRCeS5wb2ludC55LFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiBkaXNwbGFjZWRCeS5wb2ludC54XG4gIH07XG4gIHJldHVybiBnZXRSZWN0KGV4cGFuZChtYXJnaW5Cb3gsIGV4cGFuZEJ5KSk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICBhZnRlckRyYWdnaW5nLFxuICBkZXN0aW5hdGlvbixcbiAgZGlzcGxhY2VkQnksXG4gIHZpZXdwb3J0LFxuICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gIGxhc3Rcbn0pIHtcbiAgcmV0dXJuIGFmdGVyRHJhZ2dpbmcucmVkdWNlKGZ1bmN0aW9uIHByb2Nlc3MoZ3JvdXBzLCBkcmFnZ2FibGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSk7XG4gICAgY29uc3QgaWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZDtcbiAgICBncm91cHMuYWxsLnB1c2goaWQpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IGlzUGFydGlhbGx5VmlzaWJsZSh7XG4gICAgICB0YXJnZXQsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICBncm91cHMuaW52aXNpYmxlW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkQW5pbWF0ZShpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB7XG4gICAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgICBzaG91bGRBbmltYXRlXG4gICAgfTtcbiAgICBncm91cHMudmlzaWJsZVtpZF0gPSBkaXNwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfSwge1xuICAgIGFsbDogW10sXG4gICAgdmlzaWJsZToge30sXG4gICAgaW52aXNpYmxlOiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhPZkxhc3RJdGVtKGRyYWdnYWJsZXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFkcmFnZ2FibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGluZGV4T2ZMYXN0SXRlbSA9IGRyYWdnYWJsZXNbZHJhZ2dhYmxlcy5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICByZXR1cm4gb3B0aW9ucy5pbkhvbWVMaXN0ID8gaW5kZXhPZkxhc3RJdGVtIDogaW5kZXhPZkxhc3RJdGVtICsgMTtcbn1cbmZ1bmN0aW9uIGdvQXRFbmQoe1xuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgaW5Ib21lTGlzdCxcbiAgZGlzcGxhY2VkQnksXG4gIGRlc3RpbmF0aW9uXG59KSB7XG4gIGNvbnN0IG5ld0luZGV4ID0gZ2V0SW5kZXhPZkxhc3RJdGVtKGluc2lkZURlc3RpbmF0aW9uLCB7XG4gICAgaW5Ib21lTGlzdFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gIGRyYWdnYWJsZSxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGRlc3RpbmF0aW9uLFxuICB2aWV3cG9ydCxcbiAgZGlzcGxhY2VkQnksXG4gIGxhc3QsXG4gIGluZGV4LFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pIHtcbiAgY29uc3QgaW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbmQoaXRlbSA9PiBpdGVtLmRlc2NyaXB0b3IuaW5kZXggPT09IGluZGV4KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3Qgc2xpY2VGcm9tID0gaW5zaWRlRGVzdGluYXRpb24uaW5kZXhPZihtYXRjaCk7XG4gIGNvbnN0IGltcGFjdGVkID0gd2l0aG91dERyYWdnaW5nLnNsaWNlKHNsaWNlRnJvbSk7XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogaW1wYWN0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlSWQsIGFmdGVyQ3JpdGljYWwpIHtcbiAgcmV0dXJuIEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtkcmFnZ2FibGVJZF0pO1xufVxuXG52YXIgZnJvbUNvbWJpbmUgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGRlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGVzLFxuICBjb21iaW5lLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbWJpbmVJZCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gZHJhZ2dhYmxlc1tjb21iaW5lSWRdO1xuICBjb25zdCBjb21iaW5lV2l0aEluZGV4ID0gY29tYmluZVdpdGguZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZUlkLCBhZnRlckNyaXRpY2FsKTtcbiAgaWYgKGRpZENvbWJpbmVXaXRoU3RhcnRBZnRlckNyaXRpY2FsKSB7XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lV2l0aEluZGV4IC0gMTtcbiAgfVxuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggKyAxO1xuICB9XG4gIHJldHVybiBjb21iaW5lV2l0aEluZGV4O1xufTtcblxudmFyIGZyb21SZW9yZGVyID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBsb2NhdGlvblxufSkgPT4ge1xuICBpZiAoIWluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRJbmRleCA9IGxvY2F0aW9uLmluZGV4O1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaXNNb3ZpbmdGb3J3YXJkID8gY3VycmVudEluZGV4ICsgMSA6IGN1cnJlbnRJbmRleCAtIDE7XG4gIGNvbnN0IGZpcnN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvblswXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBsYXN0SW5kZXggPSBpbnNpZGVEZXN0aW5hdGlvbltpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggLSAxXS5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCB1cHBlckJvdW5kID0gaXNJbkhvbWVMaXN0ID8gbGFzdEluZGV4IDogbGFzdEluZGV4ICsgMTtcbiAgaWYgKHByb3Bvc2VkSW5kZXggPCBmaXJzdEluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHByb3Bvc2VkSW5kZXggPiB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHByb3Bvc2VkSW5kZXg7XG59O1xuXG52YXIgbW92ZVRvTmV4dEluZGV4ID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgd2FzQXQgPSBwcmV2aW91c0ltcGFjdC5hdDtcbiAgIXdhc0F0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IG1vdmUgaW4gZGlyZWN0aW9uIHdpdGhvdXQgcHJldmlvdXMgaW1wYWN0IGxvY2F0aW9uJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgaWYgKHdhc0F0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIGNvbnN0IG5ld0luZGV4ID0gZnJvbVJlb3JkZXIoe1xuICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgaXNJbkhvbWVMaXN0LFxuICAgICAgbG9jYXRpb246IHdhc0F0LmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb25cbiAgICB9KTtcbiAgICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG5ld0luZGV4ID0gZnJvbUNvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGNvbWJpbmU6IHdhc0F0LmNvbWJpbmUsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKG5ld0luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufTtcblxudmFyIGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCA9ICh7XG4gIGRpc3BsYWNlZCxcbiAgYWZ0ZXJDcml0aWNhbCxcbiAgY29tYmluZVdpdGgsXG4gIGRpc3BsYWNlZEJ5XG59KSA9PiB7XG4gIGNvbnN0IGlzRGlzcGxhY2VkID0gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtjb21iaW5lV2l0aF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtjb21iaW5lV2l0aF0pO1xuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNvbWJpbmVXaXRoLCBhZnRlckNyaXRpY2FsKSkge1xuICAgIHJldHVybiBpc0Rpc3BsYWNlZCA/IG9yaWdpbiA6IG5lZ2F0ZShkaXNwbGFjZWRCeS5wb2ludCk7XG4gIH1cbiAgcmV0dXJuIGlzRGlzcGxhY2VkID8gZGlzcGxhY2VkQnkucG9pbnQgOiBvcmlnaW47XG59O1xuXG52YXIgd2hlbkNvbWJpbmluZyA9ICh7XG4gIGFmdGVyQ3JpdGljYWwsXG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlc1xufSkgPT4ge1xuICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAhY29tYmluZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY2VudGVyID0gZHJhZ2dhYmxlc1tjb21iaW5lV2l0aF0ucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBkaXNwbGFjZUJ5ID0gZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50KHtcbiAgICBkaXNwbGFjZWQ6IGltcGFjdC5kaXNwbGFjZWQsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBjb21iaW5lV2l0aCxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5XG4gIH0pO1xuICByZXR1cm4gYWRkKGNlbnRlciwgZGlzcGxhY2VCeSk7XG59O1xuXG5jb25zdCBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLnN0YXJ0XSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG5jb25zdCBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciA9IChheGlzLCBib3gpID0+IGJveC5tYXJnaW5bYXhpcy5lbmRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciA9IChheGlzLCB0YXJnZXQsIGlzTW92aW5nKSA9PiB0YXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5tYXJnaW5bYXhpcy5jcm9zc0F4aXNTdGFydF0gKyBpc01vdmluZy5ib3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTaXplXSAvIDI7XG5jb25zdCBnb0FmdGVyID0gKHtcbiAgYXhpcyxcbiAgbW92ZVJlbGF0aXZlVG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLmVuZF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbmNvbnN0IGdvQmVmb3JlID0gKHtcbiAgYXhpcyxcbiAgbW92ZVJlbGF0aXZlVG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLnN0YXJ0XSAtIGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbmNvbnN0IGdvSW50b1N0YXJ0ID0gKHtcbiAgYXhpcyxcbiAgbW92ZUludG8sXG4gIGlzTW92aW5nXG59KSA9PiBwYXRjaChheGlzLmxpbmUsIG1vdmVJbnRvLmNvbnRlbnRCb3hbYXhpcy5zdGFydF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVJbnRvLmNvbnRlbnRCb3gsIGlzTW92aW5nKSk7XG5cbnZhciB3aGVuUmVvcmRlcmluZyA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZHJhZ2dhYmxlUGFnZSA9IGRyYWdnYWJsZS5wYWdlO1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdvSW50b1N0YXJ0KHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlSW50bzogZHJvcHBhYmxlLnBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnlcbiAgfSA9IGltcGFjdDtcbiAgY29uc3QgY2xvc2VzdEFmdGVyID0gZGlzcGxhY2VkLmFsbFswXTtcbiAgaWYgKGNsb3Nlc3RBZnRlcikge1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBkcmFnZ2FibGVzW2Nsb3Nlc3RBZnRlcl07XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjbG9zZXN0QWZ0ZXIsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgICBheGlzLFxuICAgICAgICBtb3ZlUmVsYXRpdmVUbzogY2xvc2VzdC5wYWdlLFxuICAgICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBvZmZzZXQoY2xvc2VzdC5wYWdlLCBkaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogd2l0aERpc3BsYWNlbWVudCxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdC5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVQYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIH1cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChsYXN0LmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgY29uc3QgcGFnZSA9IG9mZnNldChsYXN0LnBhZ2UsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSk7XG4gICAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiBwYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZ29BZnRlcih7XG4gICAgYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbGFzdC5wYWdlLFxuICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gIH0pO1xufTtcblxudmFyIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQgPSAoZHJvcHBhYmxlLCBwb2ludCkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICByZXR1cm4gYWRkKHBvaW50LCBmcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQpO1xufTtcblxuY29uc3QgZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHdoZW5SZW9yZGVyaW5nKHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHdoZW5Db21iaW5pbmcoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xudmFyIGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0ID0gYXJncyA9PiB7XG4gIGNvbnN0IHdpdGhvdXREaXNwbGFjZW1lbnQgPSBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50KGFyZ3MpO1xuICBjb25zdCBkcm9wcGFibGUgPSBhcmdzLmRyb3BwYWJsZTtcbiAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IGRyb3BwYWJsZSA/IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZHJvcHBhYmxlLCB3aXRob3V0RGlzcGxhY2VtZW50KSA6IHdpdGhvdXREaXNwbGFjZW1lbnQ7XG4gIHJldHVybiB3aXRoRGlzcGxhY2VtZW50O1xufTtcblxudmFyIHNjcm9sbFZpZXdwb3J0ID0gKHZpZXdwb3J0LCBuZXdTY3JvbGwpID0+IHtcbiAgY29uc3QgZGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBuZWdhdGUoZGlmZik7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBuZXdTY3JvbGwueSxcbiAgICBib3R0b206IG5ld1Njcm9sbC55ICsgdmlld3BvcnQuZnJhbWUuaGVpZ2h0LFxuICAgIGxlZnQ6IG5ld1Njcm9sbC54LFxuICAgIHJpZ2h0OiBuZXdTY3JvbGwueCArIHZpZXdwb3J0LmZyYW1lLndpZHRoXG4gIH0pO1xuICBjb25zdCB1cGRhdGVkID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBkaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVkO1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyQxKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG5mdW5jdGlvbiB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSBncm91cHNbaV0udmlzaWJsZVtpZF07XG4gICAgaWYgKGRpc3BsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgc3BlY3VsYXRpdmVseUluY3JlYXNlID0gKHtcbiAgaW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIG1heFNjcm9sbENoYW5nZVxufSkgPT4ge1xuICBjb25zdCBzY3JvbGxlZFZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQodmlld3BvcnQsIGFkZCh2aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSk7XG4gIGNvbnN0IHNjcm9sbGVkRHJvcHBhYmxlID0gZGVzdGluYXRpb24uZnJhbWUgPyBzY3JvbGxEcm9wcGFibGUoZGVzdGluYXRpb24sIGFkZChkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSkgOiBkZXN0aW5hdGlvbjtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IHdpdGhWaWV3cG9ydFNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyQxKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiBzY3JvbGxlZFZpZXdwb3J0LmZyYW1lLFxuICAgIGxhc3QsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgd2l0aERyb3BwYWJsZVNjcm9sbCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZzogZ2V0RHJhZ2dhYmxlcyQxKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbjogc2Nyb2xsZWREcm9wcGFibGUsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbnZpc2libGUgPSB7fTtcbiAgY29uc3QgdmlzaWJsZSA9IHt9O1xuICBjb25zdCBncm91cHMgPSBbbGFzdCwgd2l0aFZpZXdwb3J0U2Nyb2xsLCB3aXRoRHJvcHBhYmxlU2Nyb2xsXTtcbiAgbGFzdC5hbGwuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKTtcbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICB2aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52aXNpYmxlW2lkXSA9IHRydWU7XG4gIH0pO1xuICBjb25zdCBuZXdJbXBhY3QgPSB7XG4gICAgLi4uaW1wYWN0LFxuICAgIGRpc3BsYWNlZDoge1xuICAgICAgYWxsOiBsYXN0LmFsbCxcbiAgICAgIGludmlzaWJsZSxcbiAgICAgIHZpc2libGVcbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXdJbXBhY3Q7XG59O1xuXG52YXIgd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50ID0gKHZpZXdwb3J0LCBwb2ludCkgPT4gYWRkKHZpZXdwb3J0LnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCwgcG9pbnQpO1xuXG52YXIgZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlID0gd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50KHZpZXdwb3J0LCBwYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3Qod2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gYWRkKGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlciwgb2Zmc2V0KTtcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbiA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHZpZXdwb3J0LFxuICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICBvbmx5T25NYWluQXhpcyA9IGZhbHNlXG59KSA9PiB7XG4gIGNvbnN0IGNoYW5nZU5lZWRlZCA9IHN1YnRyYWN0KG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICBjb25zdCBzaGlmdGVkID0gb2Zmc2V0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIGNoYW5nZU5lZWRlZCk7XG4gIGNvbnN0IGFyZ3MgPSB7XG4gICAgdGFyZ2V0OiBzaGlmdGVkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIG9ubHlPbk1haW5BeGlzID8gaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyhhcmdzKSA6IGlzVG90YWxseVZpc2libGUoYXJncyk7XG59O1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBkcmFnZ2FibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGlzSW5Ib21lTGlzdCA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pO1xuICBjb25zdCBpbXBhY3QgPSBtb3ZlVG9OZXh0Q29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdFxuICB9KSB8fCBtb3ZlVG9OZXh0SW5kZXgoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBpc0luSG9tZUxpc3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gIH0pO1xuICBpZiAoaXNWaXNpYmxlSW5OZXdMb2NhdGlvbikge1xuICAgIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3QsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgZGlzdGFuY2UgPSBzdWJ0cmFjdChwYWdlQm9yZGVyQm94Q2VudGVyLCBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICBjb25zdCBjYXV0aW91cyA9IHNwZWN1bGF0aXZlbHlJbmNyZWFzZSh7XG4gICAgaW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbWF4U2Nyb2xsQ2hhbmdlOiBkaXN0YW5jZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb246IHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdDogY2F1dGlvdXMsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IGRpc3RhbmNlXG4gIH07XG59O1xuXG5jb25zdCBnZXRLbm93bkFjdGl2ZSA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IHJlY3QgPSBkcm9wcGFibGUuc3ViamVjdC5hY3RpdmU7XG4gICFyZWN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBjbGlwcGVkIGFyZWEgZnJvbSBkcm9wcGFibGUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gcmVjdDtcbn07XG52YXIgZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgc291cmNlLFxuICBkcm9wcGFibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCBhY3RpdmUgPSBzb3VyY2Uuc3ViamVjdC5hY3RpdmU7XG4gIGlmICghYWN0aXZlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYXhpcyA9IHNvdXJjZS5heGlzO1xuICBjb25zdCBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuc3RhcnRdLCBhY3RpdmVbYXhpcy5lbmRdKTtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZHJvcHBhYmxlID0+IGRyb3BwYWJsZSAhPT0gc291cmNlKS5maWx0ZXIoZHJvcHBhYmxlID0+IGRyb3BwYWJsZS5pc0VuYWJsZWQpLmZpbHRlcihkcm9wcGFibGUgPT4gQm9vbGVhbihkcm9wcGFibGUuc3ViamVjdC5hY3RpdmUpKS5maWx0ZXIoZHJvcHBhYmxlID0+IGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSh2aWV3cG9ydC5mcmFtZSkoZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKSkpLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gYWN0aXZlW2F4aXMuY3Jvc3NBeGlzRW5kXSA8IGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzRW5kXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzU3RhcnRdIDwgYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICB9KS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgICBjb25zdCBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG4gICAgY29uc3QgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0sIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQoYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQoYWN0aXZlW2F4aXMuZW5kXSk7XG4gIH0pLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGdldEtub3duQWN0aXZlKGEpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IHNlY29uZCA9IGdldEtub3duQWN0aXZlKGIpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG4gICAgcmV0dXJuIHNlY29uZCAtIGZpcnN0O1xuICB9KS5maWx0ZXIoKGRyb3BwYWJsZSwgaW5kZXgsIGFycmF5KSA9PiBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdID09PSBnZXRLbm93bkFjdGl2ZShhcnJheVswXSlbYXhpcy5jcm9zc0F4aXNTdGFydF0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF07XG4gIH1cbiAgY29uc3QgY29udGFpbnMgPSBjYW5kaWRhdGVzLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGlzV2l0aGluRHJvcHBhYmxlID0gaXNXaXRoaW4oZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLnN0YXJ0XSwgZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKVtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc1dpdGhpbkRyb3BwYWJsZShwYWdlQm9yZGVyQm94Q2VudGVyW2F4aXMubGluZV0pO1xuICB9KTtcbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjb250YWluc1swXTtcbiAgfVxuICBpZiAoY29udGFpbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjb250YWlucy5zb3J0KChhLCBiKSA9PiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdKVswXTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBjbG9zZXN0JDEocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShhKSkpO1xuICAgIGNvbnN0IHNlY29uZCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGIpKSk7XG4gICAgaWYgKGZpcnN0ICE9PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAtIHNlY29uZDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF07XG4gIH0pWzBdO1xufTtcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBzdWJ0cmFjdChvcmlnaW5hbCwgYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkgOiBvcmlnaW5hbDtcbn07XG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveCA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3g7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gb2Zmc2V0QnlQb3NpdGlvbihvcmlnaW5hbCwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKSA6IG9yaWdpbmFsO1xufTtcblxudmFyIGdldENsb3Nlc3REcmFnZ2FibGUgPSAoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICB2aWV3cG9ydCxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHNvcnRlZCA9IGluc2lkZURlc3RpbmF0aW9uLmZpbHRlcihkcmFnZ2FibGUgPT4gaXNUb3RhbGx5VmlzaWJsZSh7XG4gICAgdGFyZ2V0OiBnZXRDdXJyZW50UGFnZUJvcmRlckJveChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gIH0pKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZGlzdGFuY2VUb0EgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihhLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9CID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYiwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBpZiAoZGlzdGFuY2VUb0EgPCBkaXN0YW5jZVRvQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoZGlzdGFuY2VUb0IgPCBkaXN0YW5jZVRvQSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXg7XG4gIH0pO1xuICByZXR1cm4gc29ydGVkWzBdIHx8IG51bGw7XG59O1xuXG52YXIgZ2V0RGlzcGxhY2VkQnkgPSBtZW1vaXplT25lKGZ1bmN0aW9uIGdldERpc3BsYWNlZEJ5KGF4aXMsIGRpc3BsYWNlQnkpIHtcbiAgY29uc3QgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VCeVtheGlzLmxpbmVdO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBkaXNwbGFjZW1lbnQsXG4gICAgcG9pbnQ6IHBhdGNoKGF4aXMubGluZSwgZGlzcGxhY2VtZW50KVxuICB9O1xufSk7XG5cbmNvbnN0IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIgPSAoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgYXhpcyA9IGRyb3BwYWJsZS5heGlzO1xuICBpZiAoZHJvcHBhYmxlLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV0pO1xuICB9XG4gIGNvbnN0IGF2YWlsYWJsZVNwYWNlID0gZHJvcHBhYmxlLnN1YmplY3QucGFnZS5jb250ZW50Qm94W2F4aXMuc2l6ZV07XG4gIGNvbnN0IGluc2lkZURyb3BwYWJsZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBzcGFjZVVzZWQgPSBpbnNpZGVEcm9wcGFibGUucmVkdWNlKChzdW0sIGRpbWVuc2lvbikgPT4gc3VtICsgZGltZW5zaW9uLmNsaWVudC5tYXJnaW5Cb3hbYXhpcy5zaXplXSwgMCk7XG4gIGNvbnN0IHJlcXVpcmVkU3BhY2UgPSBzcGFjZVVzZWQgKyBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXTtcbiAgY29uc3QgbmVlZHNUb0dyb3dCeSA9IHJlcXVpcmVkU3BhY2UgLSBhdmFpbGFibGVTcGFjZTtcbiAgaWYgKG5lZWRzVG9Hcm93QnkgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG5lZWRzVG9Hcm93QnkpO1xufTtcbmNvbnN0IHdpdGhNYXhTY3JvbGwgPSAoZnJhbWUsIG1heCkgPT4gKHtcbiAgLi4uZnJhbWUsXG4gIHNjcm9sbDoge1xuICAgIC4uLmZyYW1lLnNjcm9sbCxcbiAgICBtYXhcbiAgfVxufSk7XG5jb25zdCBhZGRQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgISFpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgbm90IGFkZCBwbGFjZWhvbGRlciBzcGFjZSB0byBob21lIGxpc3QnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhIWRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBhZGQgcGxhY2Vob2xkZXIgc2l6ZSB0byBhIHN1YmplY3Qgd2hlbiBpdCBhbHJlYWR5IGhhcyBvbmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBwbGFjZWhvbGRlclNpemUgPSBnZXREaXNwbGFjZWRCeShkcm9wcGFibGUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpLnBvaW50O1xuICBjb25zdCByZXF1aXJlZEdyb3d0aCA9IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBhZGRlZCA9IHtcbiAgICBwbGFjZWhvbGRlclNpemUsXG4gICAgaW5jcmVhc2VkQnk6IHJlcXVpcmVkR3Jvd3RoLFxuICAgIG9sZEZyYW1lTWF4U2Nyb2xsOiBkcm9wcGFibGUuZnJhbWUgPyBkcm9wcGFibGUuZnJhbWUuc2Nyb2xsLm1heCA6IG51bGxcbiAgfTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogZHJvcHBhYmxlLmZyYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1heFNjcm9sbCA9IHJlcXVpcmVkR3Jvd3RoID8gYWRkKGZyYW1lLnNjcm9sbC5tYXgsIHJlcXVpcmVkR3Jvd3RoKSA6IGZyYW1lLnNjcm9sbC5tYXg7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuY29uc3QgcmVtb3ZlUGxhY2Vob2xkZXIgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBhZGRlZCA9IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcjtcbiAgIWFkZGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbW92ZSBwbGFjZWhvbGRlciBmb3JtIHN1YmplY3Qgd2hlbiB0aGVyZSB3YXMgbm9uZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgICAgZnJhbWU6IG51bGwsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdFxuICAgIH07XG4gIH1cbiAgY29uc3Qgb2xkTWF4U2Nyb2xsID0gYWRkZWQub2xkRnJhbWVNYXhTY3JvbGw7XG4gICFvbGRNYXhTY3JvbGwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcm9wcGFibGUgd2l0aCBmcmFtZSB0byBoYXZlIG9sZCBtYXggZnJhbWUgc2Nyb2xsIHdoZW4gcmVtb3ZpbmcgcGxhY2Vob2xkZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBuZXdGcmFtZSA9IHdpdGhNYXhTY3JvbGwoZnJhbWUsIG9sZE1heFNjcm9sbCk7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuXG52YXIgbW92ZVRvTmV3RHJvcHBhYmxlID0gKHtcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghbW92ZVJlbGF0aXZlVG8pIHtcbiAgICBpZiAoaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvcG9zZWQgPSB7XG4gICAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgICAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gICAgICBhdDoge1xuICAgICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgICAgaW1wYWN0OiBwcm9wb3NlZCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzLFxuICAgICAgYWZ0ZXJDcml0aWNhbFxuICAgIH0pO1xuICAgIGNvbnN0IHdpdGhQbGFjZWhvbGRlciA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID8gZGVzdGluYXRpb24gOiBhZGRQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgICBjb25zdCBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb246IHdpdGhQbGFjZWhvbGRlcixcbiAgICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA/IHByb3Bvc2VkIDogbnVsbDtcbiAgfVxuICBjb25zdCBpc0dvaW5nQmVmb3JlVGFyZ2V0ID0gQm9vbGVhbihwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSA8PSBtb3ZlUmVsYXRpdmVUby5wYWdlLmJvcmRlckJveC5jZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSk7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSAoKCkgPT4ge1xuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmluZGV4O1xuICAgIGlmIChtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuICAgIGlmIChpc0dvaW5nQmVmb3JlVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlVG8gKyAxO1xuICB9KSgpO1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBlbXB0eUdyb3VwcyxcbiAgICBpbmRleDogcHJvcG9zZWRJbmRleFxuICB9KTtcbn07XG5cbnZhciBtb3ZlQ3Jvc3NBeGlzID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIGRyYWdnYWJsZSxcbiAgaXNPdmVyLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgc291cmNlOiBpc092ZXIsXG4gICAgZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgbW92ZVJlbGF0aXZlVG8gPSBnZXRDbG9zZXN0RHJhZ2dhYmxlKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV3RHJvcHBhYmxlKHtcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgbW92ZVJlbGF0aXZlVG8sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgaWYgKCFpbXBhY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gIH07XG59O1xuXG52YXIgd2hhdElzRHJhZ2dlZE92ZXIgPSBpbXBhY3QgPT4ge1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gYXQuZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIGF0LmNvbWJpbmUuZHJvcHBhYmxlSWQ7XG59O1xuXG5jb25zdCBnZXREcm9wcGFibGVPdmVyJDEgPSAoaW1wYWN0LCBkcm9wcGFibGVzKSA9PiB7XG4gIGNvbnN0IGlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgcmV0dXJuIGlkID8gZHJvcHBhYmxlc1tpZF0gOiBudWxsO1xufTtcbnZhciBtb3ZlSW5EaXJlY3Rpb24gPSAoe1xuICBzdGF0ZSxcbiAgdHlwZVxufSkgPT4ge1xuICBjb25zdCBpc0FjdHVhbGx5T3ZlciA9IGdldERyb3BwYWJsZU92ZXIkMShzdGF0ZS5pbXBhY3QsIHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyk7XG4gIGNvbnN0IGlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQgPSBCb29sZWFuKGlzQWN0dWFsbHlPdmVyKTtcbiAgY29uc3QgaG9tZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICBjb25zdCBpc092ZXIgPSBpc0FjdHVhbGx5T3ZlciB8fCBob21lO1xuICBjb25zdCBkaXJlY3Rpb24gPSBpc092ZXIuYXhpcy5kaXJlY3Rpb247XG4gIGNvbnN0IGlzTW92aW5nT25NYWluQXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiAodHlwZSA9PT0gJ01PVkVfVVAnIHx8IHR5cGUgPT09ICdNT1ZFX0RPV04nKSB8fCBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAodHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnKTtcbiAgaWYgKGlzTW92aW5nT25NYWluQXhpcyAmJiAhaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGlzTW92aW5nRm9yd2FyZCA9IHR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJztcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gIHJldHVybiBpc01vdmluZ09uTWFpbkF4aXMgPyBtb3ZlVG9OZXh0UGxhY2Uoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBpc092ZXIsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb246IHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSkgOiBtb3ZlQ3Jvc3NBeGlzKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICBpc092ZXIsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORyc7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJ1bihwb2ludCkge1xuICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHBvaW50LnkpICYmIGlzV2l0aGluSG9yaXpvbnRhbChwb2ludC54KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzT3ZlcmxhcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBmaXJzdC5sZWZ0IDwgc2Vjb25kLnJpZ2h0ICYmIGZpcnN0LnJpZ2h0ID4gc2Vjb25kLmxlZnQgJiYgZmlyc3QudG9wIDwgc2Vjb25kLmJvdHRvbSAmJiBmaXJzdC5ib3R0b20gPiBzZWNvbmQudG9wO1xufVxuZnVuY3Rpb24gZ2V0RnVydGhlc3RBd2F5KHtcbiAgcGFnZUJvcmRlckJveCxcbiAgZHJhZ2dhYmxlLFxuICBjYW5kaWRhdGVzXG59KSB7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IHtcbiAgICBjb25zdCBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZXNcbn0pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgY29uc3QgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICBjb25zdCBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIGNvbnN0IGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG5jb25zdCBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IChyZWN0LCBwb2ludCkgPT4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKGRyb3BwYWJsZSwgYXJlYSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBhcmVhO1xuICB9XG4gIHJldHVybiBvZmZzZXRSZWN0QnlQb3NpdGlvbihhcmVhLCBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXRJc0Rpc3BsYWNlZCh7XG4gIGRpc3BsYWNlZCxcbiAgaWRcbn0pIHtcbiAgcmV0dXJuIEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbaWRdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbaWRdKTtcbn1cblxuZnVuY3Rpb24gYXRJbmRleCh7XG4gIGRyYWdnYWJsZSxcbiAgY2xvc2VzdCxcbiAgaW5Ib21lTGlzdFxufSkge1xuICBpZiAoIWNsb3Nlc3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWluSG9tZUxpc3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdC5kZXNjcmlwdG9yLmluZGV4O1xuICB9XG4gIGlmIChjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggPiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pbmRleCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggLSAxO1xuICB9XG4gIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG59XG52YXIgZ2V0UmVvcmRlckltcGFjdCA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbGFzdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pIHx8IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59O1xuXG5jb25zdCBjb21iaW5lVGhyZXNob2xkRGl2aXNvciA9IDQ7XG52YXIgZ2V0Q29tYmluZUltcGFjdCA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHRhcmdldFJlY3QsXG4gIHByZXZpb3VzSW1wYWN0LFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNvbWJpbmVXaXRoID0gd2l0aG91dERyYWdnaW5nLmZpbmQoY2hpbGQgPT4ge1xuICAgIGNvbnN0IGlkID0gY2hpbGQuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZC5wYWdlLmJvcmRlckJveDtcbiAgICBjb25zdCBjaGlsZFNpemUgPSBjaGlsZFJlY3RbYXhpcy5zaXplXTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBjaGlsZFNpemUgLyBjb21iaW5lVGhyZXNob2xkRGl2aXNvcjtcbiAgICBjb25zdCBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgY29uc3QgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxKSB7XG4gICAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVuZCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRFbmQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdIC0gZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gKyBkaXNwbGFjZW1lbnQgLSB0aHJlc2hvbGQ7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTdGFydCA+IGNoaWxkUmVjdFtheGlzLnN0YXJ0XSArIHRocmVzaG9sZCAmJiB0YXJnZXRTdGFydCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gIH0pO1xuICBpZiAoIWNvbWJpbmVXaXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGltcGFjdDtcbn07XG5cbnZhciBnZXREcmFnSW1wYWN0ID0gKHtcbiAgcGFnZU9mZnNldCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgcGFnZUJvcmRlckJveCA9IG9mZnNldFJlY3RCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgcGFnZU9mZnNldCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uSWQgPSBnZXREcm9wcGFibGVPdmVyKHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGVzXG4gIH0pO1xuICBpZiAoIWRlc3RpbmF0aW9uSWQpIHtcbiAgICByZXR1cm4gbm9JbXBhY3Q7XG4gIH1cbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xuXG52YXIgcGF0Y2hEcm9wcGFibGVNYXAgPSAoZHJvcHBhYmxlcywgdXBkYXRlZCkgPT4gKHtcbiAgLi4uZHJvcHBhYmxlcyxcbiAgW3VwZGF0ZWQuZGVzY3JpcHRvci5pZF06IHVwZGF0ZWRcbn0pO1xuXG5jb25zdCBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gKHtcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdCxcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBjb25zdCBsYXN0ID0gd2hhdElzRHJhZ2dlZE92ZXIocHJldmlvdXNJbXBhY3QpO1xuICBjb25zdCBub3cgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBpZiAobGFzdCA9PT0gbm93KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgbGFzdERyb3BwYWJsZSA9IGRyb3BwYWJsZXNbbGFzdF07XG4gIGlmICghbGFzdERyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWQgPSByZW1vdmVQbGFjZWhvbGRlcihsYXN0RHJvcHBhYmxlKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMsIHVwZGF0ZWQpO1xufTtcbnZhciByZWNvbXB1dGVQbGFjZWhvbGRlcnMgPSAoe1xuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICBpbXBhY3Rcbn0pID0+IHtcbiAgY29uc3QgY2xlYW5lZCA9IGNsZWFyVW51c2VkUGxhY2Vob2xkZXIoe1xuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIGltcGFjdCxcbiAgICBkcm9wcGFibGVzXG4gIH0pO1xuICBjb25zdCBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWlzT3Zlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcbiAgaWYgKGlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSkge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGlmIChkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBjb25zdCBwYXRjaGVkID0gYWRkUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoY2xlYW5lZCwgcGF0Y2hlZCk7XG59O1xuXG52YXIgdXBkYXRlID0gKHtcbiAgc3RhdGUsXG4gIGNsaWVudFNlbGVjdGlvbjogZm9yY2VkQ2xpZW50U2VsZWN0aW9uLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnQsXG4gIGltcGFjdDogZm9yY2VkSW1wYWN0LFxuICBzY3JvbGxKdW1wUmVxdWVzdFxufSkgPT4ge1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGlkID0+IGRyYWdnYWJsZXNbaWRdKTtcbn1cbnZhciByZWNvbXB1dGUgPSAoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgZm9yY2VTaG91bGRBbmltYXRlXG59KSA9PiB7XG4gIGNvbnN0IGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICBjb25zdCBhZnRlckRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlcyhsYXN0LmFsbCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgbGFzdFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkXG4gIH07XG59O1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG59O1xuXG52YXIgcmVmcmVzaFNuYXAgPSAoe1xuICBzdGF0ZSxcbiAgZGltZW5zaW9uczogZm9yY2VkRGltZW5zaW9ucyxcbiAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0XG59KSA9PiB7XG4gICEoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgbmVlZHNWaXNpYmlsaXR5Q2hlY2sgPSBzdGF0ZS5pbXBhY3Q7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IGRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIobmVlZHNWaXNpYmlsaXR5Q2hlY2spO1xuICAhaXNPdmVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBvdmVyIGEgZGVzdGluYXRpb24gaW4gU05BUCBtb3ZlbWVudCBtb2RlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGNvbnN0IGltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgaW1wYWN0OiBuZWVkc1Zpc2liaWxpdHlDaGVjayxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiB1cGRhdGUoe1xuICAgIGltcGFjdCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn07XG5cbnZhciBnZXRIb21lTG9jYXRpb24gPSBkZXNjcmlwdG9yID0+ICh7XG4gIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxufSk7XG5cbnZhciBnZXRMaWZ0RWZmZWN0ID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBob21lLFxuICBkcmFnZ2FibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGhvbWUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBpbnNpZGVIb21lID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShob21lLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCByYXdJbmRleCA9IGluc2lkZUhvbWUuaW5kZXhPZihkcmFnZ2FibGUpO1xuICAhKHJhd0luZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBkcmFnZ2FibGUgdG8gYmUgaW5zaWRlIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBpbnNpZGVIb21lLnNsaWNlKHJhd0luZGV4ICsgMSk7XG4gIGNvbnN0IGVmZmVjdGVkID0gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoKHByZXZpb3VzLCBpdGVtKSA9PiB7XG4gICAgcHJldmlvdXNbaXRlbS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG4gIGNvbnN0IGFmdGVyQ3JpdGljYWwgPSB7XG4gICAgaW5WaXJ0dWFsTGlzdDogaG9tZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBlZmZlY3RlZFxuICB9O1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbnVsbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IGdldEhvbWVMb2NhdGlvbihkcmFnZ2FibGUuZGVzY3JpcHRvcilcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfTtcbn07XG5cbnZhciBwYXRjaERpbWVuc2lvbk1hcCA9IChkaW1lbnNpb25zLCB1cGRhdGVkKSA9PiAoe1xuICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXM6IHBhdGNoRHJvcHBhYmxlTWFwKGRpbWVuc2lvbnMuZHJvcHBhYmxlcywgdXBkYXRlZClcbn0pO1xuXG5jb25zdCBzdGFydCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmlzaCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG9mZnNldERyYWdnYWJsZSA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgaW5pdGlhbFdpbmRvd1Njcm9sbFxufSkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBvZmZzZXQoZHJhZ2dhYmxlLmNsaWVudCwgb2Zmc2V0JDEpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIGluaXRpYWxXaW5kb3dTY3JvbGwpO1xuICBjb25zdCBtb3ZlZCA9IHtcbiAgICAuLi5kcmFnZ2FibGUsXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIC4uLmRyYWdnYWJsZS5wbGFjZWhvbGRlcixcbiAgICAgIGNsaWVudFxuICAgIH0sXG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgcmV0dXJuIG1vdmVkO1xufTtcblxudmFyIGdldEZyYW1lID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICFmcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIERyb3BwYWJsZSB0byBoYXZlIGEgZnJhbWUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gZnJhbWU7XG59O1xuXG52YXIgYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyA9ICh7XG4gIGFkZGl0aW9ucyxcbiAgdXBkYXRlZERyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENoYW5nZSA9IHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlO1xuICByZXR1cm4gYWRkaXRpb25zLm1hcChkcmFnZ2FibGUgPT4ge1xuICAgIGNvbnN0IGRyb3BwYWJsZUlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB1cGRhdGVkRHJvcHBhYmxlc1tkcm9wcGFibGVJZF07XG4gICAgY29uc3QgZnJhbWUgPSBnZXRGcmFtZShtb2RpZmllZCk7XG4gICAgY29uc3QgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWU7XG4gICAgY29uc3QgdG90YWxDaGFuZ2UgPSBhZGQod2luZG93U2Nyb2xsQ2hhbmdlLCBkcm9wcGFibGVTY3JvbGxDaGFuZ2UpO1xuICAgIGNvbnN0IG1vdmVkID0gb2Zmc2V0RHJhZ2dhYmxlKHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIG9mZnNldDogdG90YWxDaGFuZ2UsXG4gICAgICBpbml0aWFsV2luZG93U2Nyb2xsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbFxuICAgIH0pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfSk7XG59O1xuXG52YXIgcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwgPSAoe1xuICBzdGF0ZSxcbiAgcHVibGlzaGVkXG59KSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGNvbnN0IHdpdGhTY3JvbGxDaGFuZ2UgPSBwdWJsaXNoZWQubW9kaWZpZWQubWFwKHVwZGF0ZSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbdXBkYXRlLmRyb3BwYWJsZUlkXTtcbiAgICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbERyb3BwYWJsZShleGlzdGluZywgdXBkYXRlLnNjcm9sbCk7XG4gICAgcmV0dXJuIHNjcm9sbGVkO1xuICB9KTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHtcbiAgICAuLi5zdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgLi4udG9Ecm9wcGFibGVNYXAod2l0aFNjcm9sbENoYW5nZSlcbiAgfTtcbiAgY29uc3QgdXBkYXRlZEFkZGl0aW9ucyA9IHRvRHJhZ2dhYmxlTWFwKGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMoe1xuICAgIGFkZGl0aW9uczogcHVibGlzaGVkLmFkZGl0aW9ucyxcbiAgICB1cGRhdGVkRHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSkpO1xuICBjb25zdCBkcmFnZ2FibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAuLi51cGRhdGVkQWRkaXRpb25zXG4gIH07XG4gIHB1Ymxpc2hlZC5yZW1vdmFscy5mb3JFYWNoKGlkID0+IHtcbiAgICBkZWxldGUgZHJhZ2dhYmxlc1tpZF07XG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb25zID0ge1xuICAgIGRyb3BwYWJsZXMsXG4gICAgZHJhZ2dhYmxlc1xuICB9O1xuICBjb25zdCB3YXNPdmVySWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICBjb25zdCB3YXNPdmVyID0gd2FzT3ZlcklkID8gZGltZW5zaW9ucy5kcm9wcGFibGVzW3dhc092ZXJJZF0gOiBudWxsO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGhvbWUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IHByZXZpb3VzSW1wYWN0ID0gd2FzT3ZlciAmJiB3YXNPdmVyLmlzQ29tYmluZUVuYWJsZWQgPyBzdGF0ZS5pbXBhY3QgOiBvbkxpZnRJbXBhY3Q7XG4gIGNvbnN0IGltcGFjdCA9IGdldERyYWdJbXBhY3Qoe1xuICAgIHBhZ2VPZmZzZXQ6IHN0YXRlLmN1cnJlbnQucGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlOiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBmaW5pc2goKTtcbiAgY29uc3QgZHJhZ2dpbmdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICBpbXBhY3QsXG4gICAgb25MaWZ0SW1wYWN0LFxuICAgIGRpbWVuc2lvbnMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH07XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU3RhdGU7XG4gIH1cbiAgY29uc3QgZHJvcFBlbmRpbmcgPSB7XG4gICAgLi4uZHJhZ2dpbmdTdGF0ZSxcbiAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgcmVhc29uOiBzdGF0ZS5yZWFzb24sXG4gICAgaXNXYWl0aW5nOiBmYWxzZVxuICB9O1xuICByZXR1cm4gZHJvcFBlbmRpbmc7XG59O1xuXG5jb25zdCBpc1NuYXBwaW5nID0gc3RhdGUgPT4gc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCc7XG5jb25zdCBwb3N0RHJvcHBhYmxlQ2hhbmdlID0gKHN0YXRlLCB1cGRhdGVkLCBpc0VuYWJsZWRDaGFuZ2luZykgPT4ge1xuICBjb25zdCBkaW1lbnNpb25zID0gcGF0Y2hEaW1lbnNpb25NYXAoc3RhdGUuZGltZW5zaW9ucywgdXBkYXRlZCk7XG4gIGlmICghaXNTbmFwcGluZyhzdGF0ZSkgfHwgaXNFbmFibGVkQ2hhbmdpbmcpIHtcbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgZGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9uc1xuICB9KTtcbn07XG5mdW5jdGlvbiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSkge1xuICBpZiAoc3RhdGUuaXNEcmFnZ2luZyAmJiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBpZGxlJDIgPSB7XG4gIHBoYXNlOiAnSURMRScsXG4gIGNvbXBsZXRlZDogbnVsbCxcbiAgc2hvdWxkRmx1c2g6IGZhbHNlXG59O1xudmFyIHJlZHVjZXIgPSAoc3RhdGUgPSBpZGxlJDIsIGFjdGlvbikgPT4ge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaWRsZSQyLFxuICAgICAgc2hvdWxkRmx1c2g6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSU5JVElBTF9QVUJMSVNIIG11c3QgY29tZSBhZnRlciBhIElETEUgcGhhc2UnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgbW92ZW1lbnRNb2RlXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tjcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICAgIGNvbnN0IGhvbWUgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXNbY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgICBjb25zdCBjbGllbnQgPSB7XG4gICAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGJvcmRlckJveENlbnRlcjogZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLFxuICAgICAgb2Zmc2V0OiBvcmlnaW5cbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICBjbGllbnQsXG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNlbGVjdGlvbjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBvZmZzZXQ6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzV2luZG93U2Nyb2xsQWxsb3dlZCA9IHRvRHJvcHBhYmxlTGlzdChkaW1lbnNpb25zLmRyb3BwYWJsZXMpLmV2ZXJ5KGl0ZW0gPT4gIWl0ZW0uaXNGaXhlZE9uUGFnZSk7XG4gICAgY29uc3Qge1xuICAgICAgaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbFxuICAgIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGhvbWUsXG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgbW92ZW1lbnRNb2RlLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIGluaXRpYWwsXG4gICAgICBjdXJyZW50OiBpbml0aWFsLFxuICAgICAgaXNXaW5kb3dTY3JvbGxBbGxvd2VkLFxuICAgICAgaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCxcbiAgICAgIG9uTGlmdEltcGFjdDogaW1wYWN0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdDT0xMRUNUSU9OX1NUQVJUSU5HJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IGZyb20gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5leHBlY3RlZCAke2FjdGlvbi50eXBlfSByZWNlaXZlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcHVibGlzaGVkOiBhY3Rpb24ucGF5bG9hZFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkUnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgY2xpZW50OiBjbGllbnRTZWxlY3Rpb25cbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgaWYgKGlzRXF1YWwkMShjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdDogaXNTbmFwcGluZyhzdGF0ZSkgPyBzdGF0ZS5pbXBhY3QgOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9TQ1JPTEwnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKHRhcmdldCwgbmV3U2Nyb2xsKTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgc2Nyb2xsZWQsIGZhbHNlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICEodGFyZ2V0LmlzRW5hYmxlZCAhPT0gaXNFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzRW5hYmxlZCB0byAke1N0cmluZyhpc0VuYWJsZWQpfVxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgJHtTdHJpbmcodGFyZ2V0LmlzRW5hYmxlZCl9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcbiAgICAhdGFyZ2V0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiAke2lkfV0gdG8gdG9nZ2xlIGl0cyBpc0NvbWJpbmVFbmFibGVkIHN0YXRlYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAhKHRhcmdldC5pc0NvbWJpbmVFbmFibGVkICE9PSBpc0NvbWJpbmVFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFRyeWluZyB0byBzZXQgZHJvcHBhYmxlIGlzQ29tYmluZUVuYWJsZWQgdG8gJHtTdHJpbmcoaXNDb21iaW5lRW5hYmxlZCl9XG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSAke1N0cmluZyh0YXJnZXQuaXNDb21iaW5lRW5hYmxlZCl9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfQllfV0lORE9XX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbW92ZSBieSB3aW5kb3cgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICFzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdXaW5kb3cgc2Nyb2xsaW5nIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciBmaXhlZCBsaXN0cycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubmV3U2Nyb2xsO1xuICAgIGlmIChpc0VxdWFsJDEoc3RhdGUudmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsIG5ld1Njcm9sbCkpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQoc3RhdGUudmlld3BvcnQsIG5ld1Njcm9sbCk7XG4gICAgaWYgKGlzU25hcHBpbmcoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcpIHtcbiAgICBpZiAoIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBtYXhTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5tYXhTY3JvbGw7XG4gICAgaWYgKGlzRXF1YWwkMShtYXhTY3JvbGwsIHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5tYXgpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhNYXhTY3JvbGwgPSB7XG4gICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgIHNjcm9sbDoge1xuICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5zY3JvbGwsXG4gICAgICAgIG1heDogbWF4U2Nyb2xsXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICB2aWV3cG9ydDogd2l0aE1heFNjcm9sbFxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9VUCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9MRUZUJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfUklHSFQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gcmVjZWl2ZWQgd2hpbGUgbm90IGluIERSQUdHSU5HIHBoYXNlYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSBtb3ZlSW5EaXJlY3Rpb24oe1xuICAgICAgc3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgIH0pO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBpbXBhY3Q6IHJlc3VsdC5pbXBhY3QsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IHJlc3VsdC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogcmVzdWx0LnNjcm9sbEp1bXBSZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgbW92ZSBpbnRvIHRoZSBEUk9QX1BFTkRJTkcgcGhhc2UgZnJvbSB0aGUgQ09MTEVDVElORyBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICAgIGlzV2FpdGluZzogdHJ1ZSxcbiAgICAgIHJlYXNvblxuICAgIH07XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0XG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBhbmltYXRlIGRyb3AgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUk9QX0FOSU1BVElORycsXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb24sXG4gICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgZGltZW5zaW9uczogc3RhdGUuZGltZW5zaW9uc1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICByZXR1cm4ge1xuICAgICAgcGhhc2U6ICdJRExFJyxcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIHNob3VsZEZsdXNoOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuZnVuY3Rpb24gZ3VhcmQoYWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGFjdGlvbiBpbnN0YW5jZW9mIE9iamVjdCAmJiAndHlwZScgaW4gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBwcmVkaWNhdGU7XG59XG5jb25zdCBiZWZvcmVJbml0aWFsQ2FwdHVyZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGxpZnQkMSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0xJRlQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGluaXRpYWxQdWJsaXNoID0gYXJncyA9PiAoe1xuICB0eXBlOiAnSU5JVElBTF9QVUJMSVNIJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBwdWJsaXNoV2hpbGVEcmFnZ2luZyA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbGxlY3Rpb25TdGFydGluZyA9ICgpID0+ICh7XG4gIHR5cGU6ICdDT0xMRUNUSU9OX1NUQVJUSU5HJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlQnlXaW5kb3dTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVVcCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1VQJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlRG93biA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0RPV04nLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVSaWdodCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1JJR0hUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlTGVmdCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0xFRlQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGZsdXNoID0gKCkgPT4gKHtcbiAgdHlwZTogJ0ZMVVNIJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBhbmltYXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQU5JTUFURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29tcGxldGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9DT01QTEVURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1AnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BQZW5kaW5nID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9QRU5ESU5HJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wQW5pbWF0aW9uRmluaXNoZWQgPSAoKSA9PiAoe1xuICB0eXBlOiAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcblxuZnVuY3Rpb24gY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKSB7XG4gIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbmRleGVzID0gaW5zaWRlRGVzdGluYXRpb24ubWFwKGQgPT4gZC5kZXNjcmlwdG9yLmluZGV4KTtcbiAgY29uc3QgZXJyb3JzID0ge307XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBpbmRleGVzW2ldO1xuICAgIGNvbnN0IHByZXZpb3VzID0gaW5kZXhlc1tpIC0gMV07XG4gICAgaWYgKGN1cnJlbnQgIT09IHByZXZpb3VzICsgMSkge1xuICAgICAgZXJyb3JzW2N1cnJlbnRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZWQgPSBpbmRleGVzLm1hcChpbmRleCA9PiB7XG4gICAgY29uc3QgaGFzRXJyb3IgPSBCb29sZWFuKGVycm9yc1tpbmRleF0pO1xuICAgIHJldHVybiBoYXNFcnJvciA/IGBb8J+UpSR7aW5kZXh9XWAgOiBgJHtpbmRleH1gO1xuICB9KS5qb2luKCcsICcpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEZXRlY3RlZCBub24tY29uc2VjdXRpdmUgPERyYWdnYWJsZSAvPiBpbmRleGVzLlxuXG4gICAgKFRoaXMgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYnVncylcblxuICAgICR7Zm9ybWF0dGVkfVxuICBgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShjcml0aWNhbC5kcm9wcGFibGUuaWQsIGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyk7XG4gICAgY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG52YXIgbGlmdCA9IG1hcnNoYWwgPT4gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnTElGVCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIG1vdmVtZW50TW9kZVxuICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IGluaXRpYWwgPSBnZXRTdGF0ZSgpO1xuICBpZiAoaW5pdGlhbC5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWQ6IGluaXRpYWwuY29tcGxldGVkXG4gICAgfSkpO1xuICB9XG4gICEoZ2V0U3RhdGUoKS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UgdG8gc3RhcnQgYSBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgZGlzcGF0Y2goZmx1c2goKSk7XG4gIGRpc3BhdGNoKGJlZm9yZUluaXRpYWxDYXB0dXJlKHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgbW92ZW1lbnRNb2RlXG4gIH0pKTtcbiAgY29uc3Qgc2Nyb2xsT3B0aW9ucyA9IHtcbiAgICBzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHk6IG1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnXG4gIH07XG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgIHNjcm9sbE9wdGlvbnNcbiAgfTtcbiAgY29uc3Qge1xuICAgIGNyaXRpY2FsLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnRcbiAgfSA9IG1hcnNoYWwuc3RhcnRQdWJsaXNoaW5nKHJlcXVlc3QpO1xuICB2YWxpZGF0ZURpbWVuc2lvbnMoY3JpdGljYWwsIGRpbWVuc2lvbnMpO1xuICBkaXNwYXRjaChpbml0aWFsUHVibGlzaCh7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgbW92ZW1lbnRNb2RlLFxuICAgIHZpZXdwb3J0XG4gIH0pKTtcbn07XG5cbnZhciBzdHlsZSA9IG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICBtYXJzaGFsLmRyYWdnaW5nKCk7XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgbWFyc2hhbC5kcm9wcGluZyhhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbik7XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpKSB7XG4gICAgbWFyc2hhbC5yZXN0aW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufTtcblxuY29uc3QgY3VydmVzID0ge1xuICBvdXRPZlRoZVdheTogJ2N1YmljLWJlemllcigwLjIsIDAsIDAsIDEpJyxcbiAgZHJvcDogJ2N1YmljLWJlemllciguMiwxLC4xLDEpJ1xufTtcbmNvbnN0IGNvbWJpbmUgPSB7XG4gIG9wYWNpdHk6IHtcbiAgICBkcm9wOiAwLFxuICAgIGNvbWJpbmluZzogMC43XG4gIH0sXG4gIHNjYWxlOiB7XG4gICAgZHJvcDogMC43NVxuICB9XG59O1xuY29uc3QgdGltaW5ncyA9IHtcbiAgb3V0T2ZUaGVXYXk6IDAuMixcbiAgbWluRHJvcFRpbWU6IDAuMzMsXG4gIG1heERyb3BUaW1lOiAwLjU1XG59O1xuY29uc3Qgb3V0T2ZUaGVXYXlUaW1pbmcgPSBgJHt0aW1pbmdzLm91dE9mVGhlV2F5fXMgJHtjdXJ2ZXMub3V0T2ZUaGVXYXl9YDtcbmNvbnN0IHRyYW5zaXRpb25zID0ge1xuICBmbHVpZDogYG9wYWNpdHkgJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBzbmFwOiBgdHJhbnNmb3JtICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgZHJvcDogZHVyYXRpb24gPT4ge1xuICAgIGNvbnN0IHRpbWluZyA9IGAke2R1cmF0aW9ufXMgJHtjdXJ2ZXMuZHJvcH1gO1xuICAgIHJldHVybiBgdHJhbnNmb3JtICR7dGltaW5nfSwgb3BhY2l0eSAke3RpbWluZ31gO1xuICB9LFxuICBvdXRPZlRoZVdheTogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIHBsYWNlaG9sZGVyOiBgaGVpZ2h0ICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCB3aWR0aCAke291dE9mVGhlV2F5VGltaW5nfSwgbWFyZ2luICR7b3V0T2ZUaGVXYXlUaW1pbmd9YFxufTtcbmNvbnN0IG1vdmVUbyA9IG9mZnNldCA9PiBpc0VxdWFsJDEob2Zmc2V0LCBvcmlnaW4pID8gdW5kZWZpbmVkIDogYHRyYW5zbGF0ZSgke29mZnNldC54fXB4LCAke29mZnNldC55fXB4KWA7XG5jb25zdCB0cmFuc2Zvcm1zID0ge1xuICBtb3ZlVG8sXG4gIGRyb3A6IChvZmZzZXQsIGlzQ29tYmluaW5nKSA9PiB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gbW92ZVRvKG9mZnNldCk7XG4gICAgaWYgKCF0cmFuc2xhdGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2xhdGV9IHNjYWxlKCR7Y29tYmluZS5zY2FsZS5kcm9wfSlgO1xuICB9XG59O1xuXG5jb25zdCB7XG4gIG1pbkRyb3BUaW1lLFxuICBtYXhEcm9wVGltZVxufSA9IHRpbWluZ3M7XG5jb25zdCBkcm9wVGltZVJhbmdlID0gbWF4RHJvcFRpbWUgLSBtaW5Ecm9wVGltZTtcbmNvbnN0IG1heERyb3BUaW1lQXREaXN0YW5jZSA9IDE1MDA7XG5jb25zdCBjYW5jZWxEcm9wTW9kaWZpZXIgPSAwLjY7XG52YXIgZ2V0RHJvcER1cmF0aW9uID0gKHtcbiAgY3VycmVudCxcbiAgZGVzdGluYXRpb24sXG4gIHJlYXNvblxufSkgPT4ge1xuICBjb25zdCBkaXN0YW5jZSQxID0gZGlzdGFuY2UoY3VycmVudCwgZGVzdGluYXRpb24pO1xuICBpZiAoZGlzdGFuY2UkMSA8PSAwKSB7XG4gICAgcmV0dXJuIG1pbkRyb3BUaW1lO1xuICB9XG4gIGlmIChkaXN0YW5jZSQxID49IG1heERyb3BUaW1lQXREaXN0YW5jZSkge1xuICAgIHJldHVybiBtYXhEcm9wVGltZTtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlID0gZGlzdGFuY2UkMSAvIG1heERyb3BUaW1lQXREaXN0YW5jZTtcbiAgY29uc3QgZHVyYXRpb24gPSBtaW5Ecm9wVGltZSArIGRyb3BUaW1lUmFuZ2UgKiBwZXJjZW50YWdlO1xuICBjb25zdCB3aXRoRHVyYXRpb24gPSByZWFzb24gPT09ICdDQU5DRUwnID8gZHVyYXRpb24gKiBjYW5jZWxEcm9wTW9kaWZpZXIgOiBkdXJhdGlvbjtcbiAgcmV0dXJuIE51bWJlcih3aXRoRHVyYXRpb24udG9GaXhlZCgyKSk7XG59O1xuXG52YXIgZ2V0TmV3SG9tZUNsaWVudE9mZnNldCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkaW1lbnNpb25zLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcm9wcGFibGVJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlSWQgPyBkcm9wcGFibGVzW2Ryb3BwYWJsZUlkXSA6IG51bGw7XG4gIGNvbnN0IGhvbWUgPSBkcm9wcGFibGVzW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXTtcbiAgY29uc3QgbmV3Q2xpZW50Q2VudGVyID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uIHx8IGhvbWUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KG5ld0NsaWVudENlbnRlciwgZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbnZhciBnZXREcm9wSW1wYWN0ID0gKHtcbiAgZHJhZ2dhYmxlcyxcbiAgcmVhc29uLFxuICBsYXN0SW1wYWN0LFxuICBob21lLFxuICB2aWV3cG9ydCxcbiAgb25MaWZ0SW1wYWN0XG59KSA9PiB7XG4gIGlmICghbGFzdEltcGFjdC5hdCB8fCByZWFzb24gIT09ICdEUk9QJykge1xuICAgIGNvbnN0IHJlY29tcHV0ZWRIb21lSW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICAgIGRlc3RpbmF0aW9uOiBob21lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiByZWNvbXB1dGVkSG9tZUltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBpZiAobGFzdEltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW1wYWN0OiBsYXN0SW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY29uc3Qgd2l0aG91dE1vdmVtZW50ID0ge1xuICAgIC4uLmxhc3RJbXBhY3QsXG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3Vwc1xuICB9O1xuICByZXR1cm4ge1xuICAgIGltcGFjdDogd2l0aG91dE1vdmVtZW50LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgfTtcbn07XG5cbmNvbnN0IGRyb3BNaWRkbGV3YXJlID0gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICBkaXNwYXRjaChkcm9wUGVuZGluZyh7XG4gICAgICByZWFzb25cbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlzV2FpdGluZ0ZvckRyb3AgPSBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgJiYgc3RhdGUuaXNXYWl0aW5nO1xuICAhIWlzV2FpdGluZ0ZvckRyb3AgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERST1AgYWN0aW9uIG9jY3VycmVkIHdoaWxlIERST1BfUEVORElORyBhbmQgc3RpbGwgd2FpdGluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBkcm9wIGluIHBoYXNlOiAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3Qge1xuICAgIGltcGFjdCxcbiAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlXG4gIH0gPSBnZXREcm9wSW1wYWN0KHtcbiAgICByZWFzb24sXG4gICAgbGFzdEltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgb25MaWZ0SW1wYWN0OiBzdGF0ZS5vbkxpZnRJbXBhY3QsXG4gICAgaG9tZTogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF0sXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGRyYWdnYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1xuICB9KTtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KSA6IG51bGw7XG4gIGNvbnN0IGNvbWJpbmUgPSBkaWREcm9wSW5zaWRlRHJvcHBhYmxlID8gdHJ5R2V0Q29tYmluZShpbXBhY3QpIDogbnVsbDtcbiAgY29uc3Qgc291cmNlID0ge1xuICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXgsXG4gICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZFxuICB9O1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlLFxuICAgIHJlYXNvbixcbiAgICBtb2RlOiBzdGF0ZS5tb3ZlbWVudE1vZGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgY29tYmluZVxuICB9O1xuICBjb25zdCBuZXdIb21lQ2xpZW50T2Zmc2V0ID0gZ2V0TmV3SG9tZUNsaWVudE9mZnNldCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBjb21wbGV0ZWQgPSB7XG4gICAgY3JpdGljYWw6IHN0YXRlLmNyaXRpY2FsLFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWwsXG4gICAgcmVzdWx0LFxuICAgIGltcGFjdFxuICB9O1xuICBjb25zdCBpc0FuaW1hdGlvblJlcXVpcmVkID0gIWlzRXF1YWwkMShzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsIG5ld0hvbWVDbGllbnRPZmZzZXQpIHx8IEJvb2xlYW4ocmVzdWx0LmNvbWJpbmUpO1xuICBpZiAoIWlzQW5pbWF0aW9uUmVxdWlyZWQpIHtcbiAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgY29tcGxldGVkXG4gICAgfSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkcm9wRHVyYXRpb24gPSBnZXREcm9wRHVyYXRpb24oe1xuICAgIGN1cnJlbnQ6IHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCxcbiAgICBkZXN0aW5hdGlvbjogbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICByZWFzb25cbiAgfSk7XG4gIGNvbnN0IGFyZ3MgPSB7XG4gICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICBkcm9wRHVyYXRpb24sXG4gICAgY29tcGxldGVkXG4gIH07XG4gIGRpc3BhdGNoKGFuaW1hdGVEcm9wKGFyZ3MpKTtcbn07XG5cbnZhciBnZXRXaW5kb3dTY3JvbGwgPSAoKSA9PiAoe1xuICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJpbmRpbmcodXBkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnROYW1lOiAnc2Nyb2xsJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cgJiYgZXZlbnQudGFyZ2V0ICE9PSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICBvbldpbmRvd1Njcm9sbFxufSkge1xuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoKSB7XG4gICAgb25XaW5kb3dTY3JvbGwoZ2V0V2luZG93U2Nyb2xsKCkpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlZCA9IHJhZlNjaGQodXBkYXRlU2Nyb2xsKTtcbiAgY29uc3QgYmluZGluZyA9IGdldFdpbmRvd1Njcm9sbEJpbmRpbmcoc2NoZWR1bGVkKTtcbiAgbGV0IHVuYmluZCA9IG5vb3AkMjtcbiAgZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHVuYmluZCAhPT0gbm9vcCQyO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICEhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBhbHJlYWR5IGFjdGl2ZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIHNjcm9sbCBsaXN0ZW5lciB3aGVuIG5vdCBhY3RpdmUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHNjaGVkdWxlZC5jYW5jZWwoKTtcbiAgICB1bmJpbmQoKTtcbiAgICB1bmJpbmQgPSBub29wJDI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGlzQWN0aXZlXG4gIH07XG59XG5cbmNvbnN0IHNob3VsZFN0b3AkMSA9IGFjdGlvbiA9PiBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKTtcbmNvbnN0IHNjcm9sbExpc3RlbmVyID0gc3RvcmUgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IGdldFNjcm9sbExpc3RlbmVyKHtcbiAgICBvbldpbmRvd1Njcm9sbDogbmV3U2Nyb2xsID0+IHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKG1vdmVCeVdpbmRvd1Njcm9sbCh7XG4gICAgICAgIG5ld1Njcm9sbFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKCFsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgICBsaXN0ZW5lci5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBzaG91bGRTdG9wJDEoYWN0aW9uKSkge1xuICAgICAgbGlzdGVuZXIuc3RvcCgpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gIH07XG59O1xuXG52YXIgZ2V0RXhwaXJpbmdBbm5vdW5jZSA9IGFubm91bmNlID0+IHtcbiAgbGV0IHdhc0NhbGxlZCA9IGZhbHNlO1xuICBsZXQgaXNFeHBpcmVkID0gZmFsc2U7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlzRXhwaXJlZCA9IHRydWU7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdBbm5vdW5jZW1lbnQgYWxyZWFkeSBtYWRlLiBOb3QgbWFraW5nIGEgc2Vjb25kIGFubm91bmNlbWVudCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQW5ub3VuY2VtZW50cyBjYW5ub3QgYmUgbWFkZSBhc3luY2hyb25vdXNseS5cbiAgICAgICAgRGVmYXVsdCBtZXNzYWdlIGhhcyBhbHJlYWR5IGJlZW4gYW5ub3VuY2VkLlxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhc0NhbGxlZCA9IHRydWU7XG4gICAgYW5ub3VuY2UobWVzc2FnZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG4gIHJlc3VsdC53YXNDYWxsZWQgPSAoKSA9PiB3YXNDYWxsZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0QXN5bmNNYXJzaGFsID0gKCkgPT4ge1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGNvbnN0IGV4ZWN1dGUgPSB0aW1lcklkID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGVudHJpZXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50aW1lcklkID09PSB0aW1lcklkKTtcbiAgICAhKGluZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCB0aW1lcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgW2VudHJ5XSA9IGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBlbnRyeS5jYWxsYmFjaygpO1xuICB9O1xuICBjb25zdCBhZGQgPSBmbiA9PiB7XG4gICAgY29uc3QgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4gZXhlY3V0ZSh0aW1lcklkKSk7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICB0aW1lcklkLFxuICAgICAgY2FsbGJhY2s6IGZuXG4gICAgfTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNoYWxsb3cgPSBbLi4uZW50cmllc107XG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHNoYWxsb3cuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGltZXJJZCk7XG4gICAgICBlbnRyeS5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBmbHVzaFxuICB9O1xufTtcblxuY29uc3QgYXJlTG9jYXRpb25zRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkICYmIGZpcnN0LmluZGV4ID09PSBzZWNvbmQuaW5kZXg7XG59O1xuY29uc3QgaXNDb21iaW5lRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmaXJzdC5kcmFnZ2FibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZUlkICYmIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQ7XG59O1xuY29uc3QgaXNDcml0aWNhbEVxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0RyYWdnYWJsZUVxdWFsID0gZmlyc3QuZHJhZ2dhYmxlLmlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmlkICYmIGZpcnN0LmRyYWdnYWJsZS5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5kcm9wcGFibGVJZCAmJiBmaXJzdC5kcmFnZ2FibGUudHlwZSA9PT0gc2Vjb25kLmRyYWdnYWJsZS50eXBlICYmIGZpcnN0LmRyYWdnYWJsZS5pbmRleCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pbmRleDtcbiAgY29uc3QgaXNEcm9wcGFibGVFcXVhbCA9IGZpcnN0LmRyb3BwYWJsZS5pZCA9PT0gc2Vjb25kLmRyb3BwYWJsZS5pZCAmJiBmaXJzdC5kcm9wcGFibGUudHlwZSA9PT0gc2Vjb25kLmRyb3BwYWJsZS50eXBlO1xuICByZXR1cm4gaXNEcmFnZ2FibGVFcXVhbCAmJiBpc0Ryb3BwYWJsZUVxdWFsO1xufTtcblxuY29uc3Qgd2l0aFRpbWluZ3MgPSAoa2V5LCBmbikgPT4ge1xuICBzdGFydCgpO1xuICBmbigpO1xuICBmaW5pc2goKTtcbn07XG5jb25zdCBnZXREcmFnU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+ICh7XG4gIGRyYWdnYWJsZUlkOiBjcml0aWNhbC5kcmFnZ2FibGUuaWQsXG4gIHR5cGU6IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlLFxuICBzb3VyY2U6IHtcbiAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkLFxuICAgIGluZGV4OiBjcml0aWNhbC5kcmFnZ2FibGUuaW5kZXhcbiAgfSxcbiAgbW9kZVxufSk7XG5mdW5jdGlvbiBleGVjdXRlKHJlc3BvbmRlciwgZGF0YSwgYW5ub3VuY2UsIGdldERlZmF1bHRNZXNzYWdlKSB7XG4gIGlmICghcmVzcG9uZGVyKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWxsRXhwaXJlID0gZ2V0RXhwaXJpbmdBbm5vdW5jZShhbm5vdW5jZSk7XG4gIGNvbnN0IHByb3ZpZGVkID0ge1xuICAgIGFubm91bmNlOiB3aWxsRXhwaXJlXG4gIH07XG4gIHJlc3BvbmRlcihkYXRhLCBwcm92aWRlZCk7XG4gIGlmICghd2lsbEV4cGlyZS53YXNDYWxsZWQoKSkge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgfVxufVxudmFyIGdldFB1Ymxpc2hlciA9IChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBhc3luY01hcnNoYWwgPSBnZXRBc3luY01hcnNoYWwoKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgYmVmb3JlQ2FwdHVyZSA9IChkcmFnZ2FibGVJZCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZUNhcHR1cmUgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVDYXB0dXJlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVDYXB0dXJlO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHtcbiAgICAgICAgICBkcmFnZ2FibGVJZCxcbiAgICAgICAgICBtb2RlXG4gICAgICAgIH07XG4gICAgICAgIGZuKGJlZm9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGJlZm9yZVN0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlRHJhZ1N0YXJ0JywgKCkgPT4ge1xuICAgICAgY29uc3QgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVEcmFnU3RhcnQ7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZGF0YSA9IGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFzdENyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIGxhc3RMb2NhdGlvbjogZGF0YS5zb3VyY2UsXG4gICAgICBsYXN0Q29tYmluZTogbnVsbFxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZCgoKSA9PiB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnU3RhcnQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdTdGFydCwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdTdGFydCkpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGUgPSAoY3JpdGljYWwsIGltcGFjdCkgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24oaW1wYWN0KTtcbiAgICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ01vdmUgd2hlbiBvbkRyYWdTdGFydCBoYXMgbm90IGJlZW4gY2FsbGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNDcml0aWNhbENoYW5nZWQgPSAhaXNDcml0aWNhbEVxdWFsKGNyaXRpY2FsLCBkcmFnZ2luZy5sYXN0Q3JpdGljYWwpO1xuICAgIGlmIChoYXNDcml0aWNhbENoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDcml0aWNhbCA9IGNyaXRpY2FsO1xuICAgIH1cbiAgICBjb25zdCBoYXNMb2NhdGlvbkNoYW5nZWQgPSAhYXJlTG9jYXRpb25zRXF1YWwoZHJhZ2dpbmcubGFzdExvY2F0aW9uLCBsb2NhdGlvbik7XG4gICAgaWYgKGhhc0xvY2F0aW9uQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGhhc0dyb3VwaW5nQ2hhbmdlZCA9ICFpc0NvbWJpbmVFcXVhbChkcmFnZ2luZy5sYXN0Q29tYmluZSwgY29tYmluZSk7XG4gICAgaWYgKGhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cbiAgICBpZiAoIWhhc0NyaXRpY2FsQ2hhbmdlZCAmJiAhaGFzTG9jYXRpb25DaGFuZ2VkICYmICFoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChjcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksXG4gICAgICBjb21iaW5lLFxuICAgICAgZGVzdGluYXRpb246IGxvY2F0aW9uXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdVcGRhdGUnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdVcGRhdGUsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQub25EcmFnVXBkYXRlKSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IGZsdXNoIHJlc3BvbmRlcnMgd2hpbGUgZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGFzeW5jTWFyc2hhbC5mbHVzaCgpO1xuICB9O1xuICBjb25zdCBkcm9wID0gcmVzdWx0ID0+IHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdFbmQgd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBvbkRyYWdTdGFydCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdFbmQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdFbmQsIHJlc3VsdCwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdFbmQpKTtcbiAgfTtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAuLi5nZXREcmFnU3RhcnQoZHJhZ2dpbmcubGFzdENyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmU6IG51bGwsXG4gICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgIHJlYXNvbjogJ0NBTkNFTCdcbiAgICB9O1xuICAgIGRyb3AocmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVDYXB0dXJlLFxuICAgIGJlZm9yZVN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIHVwZGF0ZSxcbiAgICBmbHVzaCxcbiAgICBkcm9wLFxuICAgIGFib3J0XG4gIH07XG59O1xuXG52YXIgcmVzcG9uZGVycyA9IChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkgPT4ge1xuICBjb25zdCBwdWJsaXNoZXIgPSBnZXRQdWJsaXNoZXIoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpO1xuICByZXR1cm4gc3RvcmUgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChndWFyZChhY3Rpb24sICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJykpIHtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVDYXB0dXJlKGFjdGlvbi5wYXlsb2FkLmRyYWdnYWJsZUlkLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gYWN0aW9uLnBheWxvYWQuY3JpdGljYWw7XG4gICAgICBwdWJsaXNoZXIuYmVmb3JlU3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBwdWJsaXNoZXIuc3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBwdWJsaXNoZXIuZmx1c2goKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIHB1Ymxpc2hlci5kcm9wKHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSkge1xuICAgICAgcHVibGlzaGVyLmFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHB1Ymxpc2hlci51cGRhdGUoc3RhdGUuY3JpdGljYWwsIHN0YXRlLmltcGFjdCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZpbmlzaE1pZGRsZXdhcmUgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSkge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAhKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5pc2ggYSBkcm9wIGFuaW1hdGluZyB3aGVuIG5vIGRyb3AgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgc3RvcmUuZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICBjb21wbGV0ZWQ6IHN0YXRlLmNvbXBsZXRlZFxuICB9KSk7XG59O1xuXG5jb25zdCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUgPSBzdG9yZSA9PiB7XG4gIGxldCB1bmJpbmQgPSBudWxsO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodW5iaW5kKSB7XG4gICAgICB1bmJpbmQoKTtcbiAgICAgIHVuYmluZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykpIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoIWd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbHVzaERyb3BBbmltYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcEFuaW1hdGlvbkZpbmlzaGVkKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gICAgfSk7XG4gIH07XG59O1xuXG52YXIgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIgPSBtYXJzaGFsID0+ICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdGTFVTSCcpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpKSB7XG4gICAgbWFyc2hhbC5zdG9wUHVibGlzaGluZygpO1xuICB9XG4gIG5leHQoYWN0aW9uKTtcbn07XG5cbnZhciBmb2N1cyA9IG1hcnNoYWwgPT4ge1xuICBsZXQgaXNXYXRjaGluZyA9IGZhbHNlO1xuICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IHRydWU7XG4gICAgICBtYXJzaGFsLnRyeVJlY29yZEZvY3VzKGFjdGlvbi5wYXlsb2FkLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoIWlzV2F0Y2hpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGlmIChyZXN1bHQuY29tYmluZSkge1xuICAgICAgICBtYXJzaGFsLnRyeVNoaWZ0UmVjb3JkKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQpO1xuICAgICAgfVxuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IHNob3VsZFN0b3AgPSBhY3Rpb24gPT4gZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0RST1BfQU5JTUFURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJyk7XG52YXIgYXV0b1Njcm9sbCA9IGF1dG9TY3JvbGxlciA9PiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChzaG91bGRTdG9wKGFjdGlvbikpIHtcbiAgICBhdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHBoYXNlIHRvIGJlIERSQUdHSU5HIGFmdGVyIElOSVRJQUxfUFVCTElTSCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgYXV0b1Njcm9sbGVyLnN0YXJ0KHN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xuICBhdXRvU2Nyb2xsZXIuc2Nyb2xsKHN0b3JlLmdldFN0YXRlKCkpO1xufTtcblxuY29uc3QgcGVuZGluZ0Ryb3AgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIG5leHQoYWN0aW9uKTtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcG9zdEFjdGlvblN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5waGFzZSAhPT0gJ0RST1BfUEVORElORycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5pc1dhaXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcmUuZGlzcGF0Y2goZHJvcCh7XG4gICAgcmVhc29uOiBwb3N0QWN0aW9uU3RhdGUucmVhc29uXG4gIH0pKTtcbn07XG5cbmNvbnN0IGNvbXBvc2VFbmhhbmNlcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fKHtcbiAgbmFtZTogJ0BoZWxsby1wYW5nZWEvZG5kJ1xufSkgOiBjb21wb3NlO1xudmFyIGNyZWF0ZVN0b3JlID0gKHtcbiAgZGltZW5zaW9uTWFyc2hhbCxcbiAgZm9jdXNNYXJzaGFsLFxuICBzdHlsZU1hcnNoYWwsXG4gIGdldFJlc3BvbmRlcnMsXG4gIGFubm91bmNlLFxuICBhdXRvU2Nyb2xsZXJcbn0pID0+IGNyZWF0ZVN0b3JlJDEocmVkdWNlciwgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoc3R5bGUoc3R5bGVNYXJzaGFsKSwgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIoZGltZW5zaW9uTWFyc2hhbCksIGxpZnQoZGltZW5zaW9uTWFyc2hhbCksIGRyb3BNaWRkbGV3YXJlLCBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSwgZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlLCBwZW5kaW5nRHJvcCwgYXV0b1Njcm9sbChhdXRvU2Nyb2xsZXIpLCBzY3JvbGxMaXN0ZW5lciwgZm9jdXMoZm9jdXNNYXJzaGFsKSwgcmVzcG9uZGVycyhnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkpKSk7XG5cbmNvbnN0IGNsZWFuJDEgPSAoKSA9PiAoe1xuICBhZGRpdGlvbnM6IHt9LFxuICByZW1vdmFsczoge30sXG4gIG1vZGlmaWVkOiB7fVxufSk7XG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoZXIoe1xuICByZWdpc3RyeSxcbiAgY2FsbGJhY2tzXG59KSB7XG4gIGxldCBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGNvbnN0IGNvbGxlY3QgPSAoKSA9PiB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZygpO1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICBzdGFydCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZGRpdGlvbnMsXG4gICAgICAgIHJlbW92YWxzLFxuICAgICAgICBtb2RpZmllZFxuICAgICAgfSA9IHN0YWdpbmc7XG4gICAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGlkID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGlkKS5nZXREaW1lbnNpb24ob3JpZ2luKSkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhtb2RpZmllZCkubWFwKGlkID0+IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5yZW1vdmFsc1tpZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLnJlbW92YWxzW2lkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgc3RhZ2luZy5yZW1vdmFsc1tkZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgZnJhbWVJZCA9IG51bGw7XG4gICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgcmVtb3ZlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxudmFyIGdldE1heFNjcm9sbCA9ICh7XG4gIHNjcm9sbEhlaWdodCxcbiAgc2Nyb2xsV2lkdGgsXG4gIGhlaWdodCxcbiAgd2lkdGhcbn0pID0+IHtcbiAgY29uc3QgbWF4U2Nyb2xsID0gc3VidHJhY3Qoe1xuICAgIHg6IHNjcm9sbFdpZHRoLFxuICAgIHk6IHNjcm9sbEhlaWdodFxuICB9LCB7XG4gICAgeDogd2lkdGgsXG4gICAgeTogaGVpZ2h0XG4gIH0pO1xuICBjb25zdCBhZGp1c3RlZE1heFNjcm9sbCA9IHtcbiAgICB4OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueCksXG4gICAgeTogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLnkpXG4gIH07XG4gIHJldHVybiBhZGp1c3RlZE1heFNjcm9sbDtcbn07XG5cbnZhciBnZXREb2N1bWVudEVsZW1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWRvYyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59O1xuXG52YXIgZ2V0TWF4V2luZG93U2Nyb2xsID0gKCkgPT4ge1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICBzY3JvbGxIZWlnaHQ6IGRvYy5zY3JvbGxIZWlnaHQsXG4gICAgc2Nyb2xsV2lkdGg6IGRvYy5zY3JvbGxXaWR0aCxcbiAgICB3aWR0aDogZG9jLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZG9jLmNsaWVudEhlaWdodFxuICB9KTtcbiAgcmV0dXJuIG1heFNjcm9sbDtcbn07XG5cbnZhciBnZXRWaWV3cG9ydCA9ICgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKCk7XG4gIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCB0b3AgPSBzY3JvbGwueTtcbiAgY29uc3QgbGVmdCA9IHNjcm9sbC54O1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgY29uc3Qgd2lkdGggPSBkb2MuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGRvYy5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tXG4gIH0pO1xuICBjb25zdCB2aWV3cG9ydCA9IHtcbiAgICBmcmFtZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHNjcm9sbCxcbiAgICAgIGN1cnJlbnQ6IHNjcm9sbCxcbiAgICAgIG1heDogbWF4U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IG9yaWdpblxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufTtcblxudmFyIGdldEluaXRpYWxQdWJsaXNoID0gKHtcbiAgY3JpdGljYWwsXG4gIHNjcm9sbE9wdGlvbnMsXG4gIHJlZ2lzdHJ5XG59KSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQoKTtcbiAgY29uc3Qgd2luZG93U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIGNvbnN0IGhvbWUgPSBjcml0aWNhbC5kcm9wcGFibGU7XG4gIGNvbnN0IGRyb3BwYWJsZXMgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmNhbGxiYWNrcy5nZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCh3aW5kb3dTY3JvbGwsIHNjcm9sbE9wdGlvbnMpKTtcbiAgY29uc3QgZHJhZ2dhYmxlcyA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRBbGxCeVR5cGUoY3JpdGljYWwuZHJhZ2dhYmxlLnR5cGUpLm1hcChlbnRyeSA9PiBlbnRyeS5nZXREaW1lbnNpb24od2luZG93U2Nyb2xsKSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJhZ2dhYmxlczogdG9EcmFnZ2FibGVNYXAoZHJhZ2dhYmxlcyksXG4gICAgZHJvcHBhYmxlczogdG9Ecm9wcGFibGVNYXAoZHJvcHBhYmxlcylcbiAgfTtcbiAgZmluaXNoKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkaW1lbnNpb25zLFxuICAgIGNyaXRpY2FsLFxuICAgIHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZW50cnkpIHtcbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnaW5nLmlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICBpZiAoaG9tZS5kZXNjcmlwdG9yLm1vZGUgIT09ICd2aXJ0dWFsJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgWW91IGFyZSBhdHRlbXB0aW5nIHRvIGFkZCBvciByZW1vdmUgYSBEcmFnZ2FibGUgW2lkOiAke2VudHJ5LmRlc2NyaXB0b3IuaWR9XVxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cblxuICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL3BhdHRlcm5zL3ZpcnR1YWwtbGlzdHMubWRcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgY3JlYXRlRGltZW5zaW9uTWFyc2hhbCA9IChyZWdpc3RyeSwgY2FsbGJhY2tzKSA9PiB7XG4gIGxldCBjb2xsZWN0aW9uID0gbnVsbDtcbiAgY29uc3QgcHVibGlzaGVyID0gY3JlYXRlUHVibGlzaGVyKHtcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIHB1Ymxpc2g6IGNhbGxiYWNrcy5wdWJsaXNoV2hpbGVEcmFnZ2luZyxcbiAgICAgIGNvbGxlY3Rpb25TdGFydGluZzogY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZ1xuICAgIH0sXG4gICAgcmVnaXN0cnlcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCA9IChpZCwgaXNFbmFibGVkKSA9PiB7XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSBpcyBlbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlICR7aWR9IGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gKGlkLCBpc0NvbWJpbmVFbmFibGVkKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQoe1xuICAgICAgaWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IChpZCwgbmV3U2Nyb2xsKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgdGhlIHNjcm9sbCBvbiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVTY3JvbGwoe1xuICAgICAgaWQsXG4gICAgICBuZXdTY3JvbGxcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsRHJvcHBhYmxlID0gKGlkLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoaWQpLmNhbGxiYWNrcy5zY3JvbGwoY2hhbmdlKTtcbiAgfTtcbiAgY29uc3Qgc3RvcFB1Ymxpc2hpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHB1Ymxpc2hlci5zdG9wKCk7XG4gICAgY29uc3QgaG9tZSA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJvcHBhYmxlO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5mb3JFYWNoKGVudHJ5ID0+IGVudHJ5LmNhbGxiYWNrcy5kcmFnU3RvcHBlZCgpKTtcbiAgICBjb2xsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgY29sbGVjdGlvbiA9IG51bGw7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZXIgPSBldmVudCA9PiB7XG4gICAgIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgb25seSBiZSBzdWJzY3JpYmVkIHdoZW4gYSBjb2xsZWN0aW9uIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ0FERElUSU9OJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLmFkZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAnUkVNT1ZBTCcpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5yZW1vdmUoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRQdWJsaXNoaW5nID0gcmVxdWVzdCA9PiB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKHJlcXVlc3QuZHJhZ2dhYmxlSWQpO1xuICAgIGNvbnN0IGhvbWUgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKTtcbiAgICBjb25zdCBjcml0aWNhbCA9IHtcbiAgICAgIGRyYWdnYWJsZTogZW50cnkuZGVzY3JpcHRvcixcbiAgICAgIGRyb3BwYWJsZTogaG9tZS5kZXNjcmlwdG9yXG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHJlZ2lzdHJ5LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgY3JpdGljYWwsXG4gICAgICB1bnN1YnNjcmliZVxuICAgIH07XG4gICAgcmV0dXJuIGdldEluaXRpYWxQdWJsaXNoKHtcbiAgICAgIGNyaXRpY2FsLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBzY3JvbGxPcHRpb25zOiByZXF1ZXN0LnNjcm9sbE9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgbWFyc2hhbCA9IHtcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHN0YXJ0UHVibGlzaGluZyxcbiAgICBzdG9wUHVibGlzaGluZ1xuICB9O1xuICByZXR1cm4gbWFyc2hhbDtcbn07XG5cbnZhciBjYW5TdGFydERyYWcgPSAoc3RhdGUsIGlkKSA9PiB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHN0YXRlLnBoYXNlICE9PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkID09PSBpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUuY29tcGxldGVkLnJlc3VsdC5yZWFzb24gPT09ICdEUk9QJztcbn07XG5cbnZhciBzY3JvbGxXaW5kb3cgPSBjaGFuZ2UgPT4ge1xuICB3aW5kb3cuc2Nyb2xsQnkoY2hhbmdlLngsIGNoYW5nZS55KTtcbn07XG5cbmNvbnN0IGdldFNjcm9sbGFibGVEcm9wcGFibGVzID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZHJvcHBhYmxlID0+IHtcbiAgaWYgKCFkcm9wcGFibGUuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZHJvcHBhYmxlLmZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSkpO1xuY29uc3QgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIgPSAodGFyZ2V0LCBkcm9wcGFibGVzKSA9PiB7XG4gIGNvbnN0IG1heWJlID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMoZHJvcHBhYmxlcykuZmluZChkcm9wcGFibGUgPT4ge1xuICAgICFkcm9wcGFibGUuZnJhbWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHJlc3VsdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KSB8fCBudWxsO1xuICByZXR1cm4gbWF5YmU7XG59O1xudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKHtcbiAgY2VudGVyLFxuICBkZXN0aW5hdGlvbixcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uXTtcbiAgICBpZiAoIWRpbWVuc2lvbi5mcmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH1cbiAgY29uc3QgZGltZW5zaW9uID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIoY2VudGVyLCBkcm9wcGFibGVzKTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmNvbnN0IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zID0ge1xuICBzdGFydEZyb21QZXJjZW50YWdlOiAwLjI1LFxuICBtYXhTY3JvbGxBdFBlcmNlbnRhZ2U6IDAuMDUsXG4gIG1heFBpeGVsU2Nyb2xsOiAyOCxcbiAgZWFzZTogcGVyY2VudGFnZSA9PiBwZXJjZW50YWdlICoqIDIsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgc3RvcERhbXBlbmluZ0F0OiAxMjAwLFxuICAgIGFjY2VsZXJhdGVBdDogMzYwXG4gIH0sXG4gIGRpc2FibGVkOiBmYWxzZVxufTtcblxudmFyIGdldERpc3RhbmNlVGhyZXNob2xkcyA9IChjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBzdGFydFNjcm9sbGluZ0Zyb20gPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGF1dG9TY3JvbGxlck9wdGlvbnMuc3RhcnRGcm9tUGVyY2VudGFnZTtcbiAgY29uc3QgbWF4U2Nyb2xsVmFsdWVBdCA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhTY3JvbGxBdFBlcmNlbnRhZ2U7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSB7XG4gICAgc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIG1heFNjcm9sbFZhbHVlQXRcbiAgfTtcbiAgcmV0dXJuIHRocmVzaG9sZHM7XG59O1xuXG52YXIgZ2V0UGVyY2VudGFnZSA9ICh7XG4gIHN0YXJ0T2ZSYW5nZSxcbiAgZW5kT2ZSYW5nZSxcbiAgY3VycmVudFxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IGVuZE9mUmFuZ2UgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRGV0ZWN0ZWQgZGlzdGFuY2UgcmFuZ2Ugb2YgMCBpbiB0aGUgZmx1aWQgYXV0byBzY3JvbGxlclxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxuICAgICAgTm90IGFsbG93aW5nIGFuIGF1dG8gc2Nyb2xsXG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICBjb25zdCBwZXJjZW50YWdlID0gY3VycmVudEluUmFuZ2UgLyByYW5nZTtcbiAgcmV0dXJuIHBlcmNlbnRhZ2U7XG59O1xuXG52YXIgbWluU2Nyb2xsID0gMTtcblxudmFyIGdldFZhbHVlRnJvbURpc3RhbmNlID0gKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMpID0+IHtcbiAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgaWYgKGRpc3RhbmNlVG9FZGdlID4gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPD0gdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0KSB7XG4gICAgcmV0dXJuIGF1dG9TY3JvbGxlck9wdGlvbnMubWF4UGl4ZWxTY3JvbGw7XG4gIH1cbiAgaWYgKGRpc3RhbmNlVG9FZGdlID09PSB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cbiAgY29uc3QgcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0ID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQsXG4gICAgZW5kT2ZSYW5nZTogdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgY3VycmVudDogZGlzdGFuY2VUb0VkZ2VcbiAgfSk7XG4gIGNvbnN0IHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tID0gMSAtIHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdDtcbiAgY29uc3Qgc2Nyb2xsID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbCAqIGF1dG9TY3JvbGxlck9wdGlvbnMuZWFzZShwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn07XG5cbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9IChwcm9wb3NlZFNjcm9sbCwgZHJhZ1N0YXJ0VGltZSwgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBhY2NlbGVyYXRlQXQgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLmFjY2VsZXJhdGVBdDtcbiAgY29uc3Qgc3RvcEF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5zdG9wRGFtcGVuaW5nQXQ7XG4gIGNvbnN0IHN0YXJ0T2ZSYW5nZSA9IGRyYWdTdGFydFRpbWU7XG4gIGNvbnN0IGVuZE9mUmFuZ2UgPSBzdG9wQXQ7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJ1blRpbWUgPSBub3cgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChydW5UaW1lID49IHN0b3BBdCkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAocnVuVGltZSA8IGFjY2VsZXJhdGVBdCkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cbiAgY29uc3QgYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IGFjY2VsZXJhdGVBdCxcbiAgICBlbmRPZlJhbmdlLFxuICAgIGN1cnJlbnQ6IHJ1blRpbWVcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbCA9IHByb3Bvc2VkU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufTtcblxudmFyIGdldFZhbHVlID0gKHtcbiAgZGlzdGFuY2VUb0VkZ2UsXG4gIHRocmVzaG9sZHMsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0VmFsdWVGcm9tRGlzdGFuY2UoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFzaG91bGRVc2VUaW1lRGFtcGVuaW5nKSB7XG4gICAgcmV0dXJuIHNjcm9sbDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoZGFtcGVuVmFsdWVCeVRpbWUoc2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSwgbWluU2Nyb2xsKTtcbn07XG5cbnZhciBnZXRTY3JvbGxPbkF4aXMgPSAoe1xuICBjb250YWluZXIsXG4gIGRpc3RhbmNlVG9FZGdlcyxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgYXhpcyxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCB0aHJlc2hvbGRzID0gZ2V0RGlzdGFuY2VUaHJlc2hvbGRzKGNvbnRhaW5lciwgYXhpcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyk7XG4gIGNvbnN0IGlzQ2xvc2VyVG9FbmQgPSBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdIDwgZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdO1xuICBpZiAoaXNDbG9zZXJUb0VuZCkge1xuICAgIHJldHVybiBnZXRWYWx1ZSh7XG4gICAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuZW5kXSxcbiAgICAgIHRocmVzaG9sZHMsXG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLTEgKiBnZXRWYWx1ZSh7XG4gICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XSxcbiAgICB0aHJlc2hvbGRzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xufTtcblxudmFyIGFkanVzdEZvclNpemVMaW1pdHMgPSAoe1xuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIHByb3Bvc2VkU2Nyb2xsXG59KSA9PiB7XG4gIGNvbnN0IGlzVG9vQmlnVmVydGljYWxseSA9IHN1YmplY3QuaGVpZ2h0ID4gY29udGFpbmVyLmhlaWdodDtcbiAgY29uc3QgaXNUb29CaWdIb3Jpem9udGFsbHkgPSBzdWJqZWN0LndpZHRoID4gY29udGFpbmVyLndpZHRoO1xuICBpZiAoIWlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmICFpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKGlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmIGlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogaXNUb29CaWdIb3Jpem9udGFsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueCxcbiAgICB5OiBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueVxuICB9O1xufTtcblxuY29uc3QgY2xlYW4gPSBhcHBseSh2YWx1ZSA9PiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG52YXIgZ2V0U2Nyb2xsJDEgPSAoe1xuICBkcmFnU3RhcnRUaW1lLFxuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBkaXN0YW5jZVRvRWRnZXMgPSB7XG4gICAgdG9wOiBjZW50ZXIueSAtIGNvbnRhaW5lci50b3AsXG4gICAgcmlnaHQ6IGNvbnRhaW5lci5yaWdodCAtIGNlbnRlci54LFxuICAgIGJvdHRvbTogY29udGFpbmVyLmJvdHRvbSAtIGNlbnRlci55LFxuICAgIGxlZnQ6IGNlbnRlci54IC0gY29udGFpbmVyLmxlZnRcbiAgfTtcbiAgY29uc3QgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IHZlcnRpY2FsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyLFxuICAgIGRpc3RhbmNlVG9FZGdlcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGF4aXM6IGhvcml6b250YWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCByZXF1aXJlZCA9IGNsZWFuKHtcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIGlmIChpc0VxdWFsJDEocmVxdWlyZWQsIG9yaWdpbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaW1pdGVkID0gYWRqdXN0Rm9yU2l6ZUxpbWl0cyh7XG4gICAgY29udGFpbmVyLFxuICAgIHN1YmplY3QsXG4gICAgcHJvcG9zZWRTY3JvbGw6IHJlcXVpcmVkXG4gIH0pO1xuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaXNFcXVhbCQxKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn07XG5cbmNvbnN0IHNtYWxsZXN0U2lnbmVkID0gYXBwbHkodmFsdWUgPT4ge1xuICBpZiAodmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufSk7XG5jb25zdCBnZXRPdmVybGFwID0gKCgpID0+IHtcbiAgY29uc3QgZ2V0UmVtYWluZGVyID0gKHRhcmdldCwgbWF4KSA9PiB7XG4gICAgaWYgKHRhcmdldCA8IDApIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgLSBtYXg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICByZXR1cm4gKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbCA9IGFkZChjdXJyZW50LCBjaGFuZ2UpO1xuICAgIGNvbnN0IG92ZXJsYXAgPSB7XG4gICAgICB4OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLngsIG1heC54KSxcbiAgICAgIHk6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueSwgbWF4LnkpXG4gICAgfTtcbiAgICBpZiAoaXNFcXVhbCQxKG92ZXJsYXAsIG9yaWdpbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxhcDtcbiAgfTtcbn0pKCk7XG5jb25zdCBjYW5QYXJ0aWFsbHlTY3JvbGwgPSAoe1xuICBtYXg6IHJhd01heCxcbiAgY3VycmVudCxcbiAgY2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IG1heCA9IHtcbiAgICB4OiBNYXRoLm1heChjdXJyZW50LngsIHJhd01heC54KSxcbiAgICB5OiBNYXRoLm1heChjdXJyZW50LnksIHJhd01heC55KVxuICB9O1xuICBjb25zdCBzbWFsbGVzdENoYW5nZSA9IHNtYWxsZXN0U2lnbmVkKGNoYW5nZSk7XG4gIGNvbnN0IG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXgsXG4gICAgY3VycmVudCxcbiAgICBjaGFuZ2U6IHNtYWxsZXN0Q2hhbmdlXG4gIH0pO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueSAhPT0gMCAmJiBvdmVybGFwLnkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY2FuU2Nyb2xsV2luZG93ID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IGNhblBhcnRpYWxseVNjcm9sbCh7XG4gIGN1cnJlbnQ6IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LFxuICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gIGNoYW5nZVxufSk7XG5jb25zdCBnZXRXaW5kb3dPdmVybGFwID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICBjb25zdCBjdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgY2FuU2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlcmxhcCA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9ICh7XG4gIHZpZXdwb3J0LFxuICBzdWJqZWN0LFxuICBjZW50ZXIsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsJDEoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiB2aWV3cG9ydC5mcmFtZSxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn07XG5cbnZhciBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSAoe1xuICBkcm9wcGFibGUsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNjcm9sbCA9IGdldFNjcm9sbCQxKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogZnJhbWUucGFnZU1hcmdpbkJveCxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59O1xuXG52YXIgc2Nyb2xsID0gKHtcbiAgc3RhdGUsXG4gIGRyYWdTdGFydFRpbWUsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNlbnRlciA9IHN0YXRlLmN1cnJlbnQucGFnZS5ib3JkZXJCb3hDZW50ZXI7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBzdWJqZWN0ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICBpZiAoc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCBjaGFuZ2UgPSBnZXRXaW5kb3dTY3JvbGxDaGFuZ2Uoe1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc3ViamVjdCxcbiAgICAgIGNlbnRlcixcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlKHtcbiAgICBjZW50ZXIsXG4gICAgZGVzdGluYXRpb246IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCksXG4gICAgZHJvcHBhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGFuZ2UgPSBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2Uoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgaWYgKGNoYW5nZSkge1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUZsdWlkU2Nyb2xsZXIgPSAoe1xuICBzY3JvbGxXaW5kb3csXG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHNjaGVkdWxlV2luZG93U2Nyb2xsID0gcmFmU2NoZChzY3JvbGxXaW5kb3cpO1xuICBjb25zdCBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCA9IHJhZlNjaGQoc2Nyb2xsRHJvcHBhYmxlKTtcbiAgbGV0IGRyYWdnaW5nID0gbnVsbDtcbiAgY29uc3QgdHJ5U2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmbHVpZCBzY3JvbGwgaWYgbm90IGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZHJhZ1N0YXJ0VGltZVxuICAgIH0gPSBkcmFnZ2luZztcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBzY3JvbGxXaW5kb3c6IHNjaGVkdWxlV2luZG93U2Nyb2xsLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCQxID0gc3RhdGUgPT4ge1xuICAgIHN0YXJ0KCk7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBhdXRvIHNjcm9sbGluZyB3aGVuIGFscmVhZHkgc3RhcnRlZCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHdhc1Njcm9sbE5lZWRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGZha2VTY3JvbGxDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdhc1Njcm9sbE5lZWRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBkcmFnU3RhcnRUaW1lOiAwLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogZmFsc2UsXG4gICAgICBzY3JvbGxXaW5kb3c6IGZha2VTY3JvbGxDYWxsYmFjayxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICAgIGRyYWdnaW5nID0ge1xuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHdhc1Njcm9sbE5lZWRlZFxuICAgIH07XG4gICAgZmluaXNoKCk7XG4gICAgaWYgKHdhc1Njcm9sbE5lZWRlZCkge1xuICAgICAgdHJ5U2Nyb2xsKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVdpbmRvd1Njcm9sbC5jYW5jZWwoKTtcbiAgICBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbC5jYW5jZWwoKTtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0JDEsXG4gICAgc3RvcCxcbiAgICBzY3JvbGw6IHRyeVNjcm9sbFxuICB9O1xufTtcblxudmFyIGNyZWF0ZUp1bXBTY3JvbGxlciA9ICh7XG4gIG1vdmUsXG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgc2Nyb2xsV2luZG93XG59KSA9PiB7XG4gIGNvbnN0IG1vdmVCeU9mZnNldCA9IChzdGF0ZSwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYWRkKHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbiwgb2Zmc2V0KTtcbiAgICBtb3ZlKHtcbiAgICAgIGNsaWVudFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwID0gZ2V0RHJvcHBhYmxlT3ZlcmxhcChkcm9wcGFibGUsIGNoYW5nZSk7XG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG4gIGNvbnN0IHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4gPSAoaXNXaW5kb3dTY3JvbGxBbGxvd2VkLCB2aWV3cG9ydCwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFpc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGlmICghY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwID0gZ2V0V2luZG93T3ZlcmxhcCh2aWV3cG9ydCwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbFdpbmRvdyh3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBzdWJ0cmFjdChjaGFuZ2UsIHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIHJldHVybiByZW1haW5kZXI7XG4gIH07XG4gIGNvbnN0IGp1bXBTY3JvbGxlciA9IHN0YXRlID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3Q7XG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAhZGVzdGluYXRpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcGVyZm9ybSBhIGp1bXAgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZGVzdGluYXRpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyb3BwYWJsZVJlbWFpbmRlciA9IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4oc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2Rlc3RpbmF0aW9uXSwgcmVxdWVzdCk7XG4gICAgaWYgKCFkcm9wcGFibGVSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCB3aW5kb3dSZW1haW5kZXIgPSBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGRyb3BwYWJsZVJlbWFpbmRlcik7XG4gICAgaWYgKCF3aW5kb3dSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW92ZUJ5T2Zmc2V0KHN0YXRlLCB3aW5kb3dSZW1haW5kZXIpO1xuICB9O1xuICByZXR1cm4ganVtcFNjcm9sbGVyO1xufTtcblxudmFyIGNyZWF0ZUF1dG9TY3JvbGxlciA9ICh7XG4gIHNjcm9sbERyb3BwYWJsZSxcbiAgc2Nyb2xsV2luZG93LFxuICBtb3ZlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGZsdWlkU2Nyb2xsZXIgPSBjcmVhdGVGbHVpZFNjcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGp1bXBTY3JvbGwgPSBjcmVhdGVKdW1wU2Nyb2xsZXIoe1xuICAgIG1vdmUsXG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZVxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gICAgaWYgKGF1dG9TY3JvbGxlck9wdGlvbnMuZGlzYWJsZWQgfHwgc3RhdGUucGhhc2UgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ0ZMVUlEJykge1xuICAgICAgZmx1aWRTY3JvbGxlci5zY3JvbGwoc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGp1bXBTY3JvbGwoc3RhdGUpO1xuICB9O1xuICBjb25zdCBzY3JvbGxlciA9IHtcbiAgICBzY3JvbGwsXG4gICAgc3RhcnQ6IGZsdWlkU2Nyb2xsZXIuc3RhcnQsXG4gICAgc3RvcDogZmx1aWRTY3JvbGxlci5zdG9wXG4gIH07XG4gIHJldHVybiBzY3JvbGxlcjtcbn07XG5cbmNvbnN0IHByZWZpeCA9ICdkYXRhLXJmZCc7XG5jb25zdCBkcmFnSGFuZGxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZy1oYW5kbGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgZHJhZ2dhYmxlSWQ6IGAke2Jhc2V9LWRyYWdnYWJsZS1pZGAsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyYWdnYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyYWdnYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBkcm9wcGFibGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcm9wcGFibGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYCxcbiAgICBpZDogYCR7YmFzZX0taWRgXG4gIH07XG59KSgpO1xuY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0ge1xuICBjb250ZXh0SWQ6IGAke3ByZWZpeH0tc2Nyb2xsLWNvbnRhaW5lci1jb250ZXh0LWlkYFxufTtcblxuY29uc3QgbWFrZUdldFNlbGVjdG9yID0gY29udGV4dCA9PiBhdHRyaWJ1dGUgPT4gYFske2F0dHJpYnV0ZX09XCIke2NvbnRleHR9XCJdYDtcbmNvbnN0IGdldFN0eWxlcyA9IChydWxlcywgcHJvcGVydHkpID0+IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgY29uc3QgdmFsdWUgPSBydWxlLnN0eWxlc1twcm9wZXJ0eV07XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGAke3J1bGUuc2VsZWN0b3J9IHsgJHt2YWx1ZX0gfWA7XG59KS5qb2luKCcgJyk7XG5jb25zdCBub1BvaW50ZXJFdmVudHMgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbnZhciBnZXRTdHlsZXMkMSA9IGNvbnRleHRJZCA9PiB7XG4gIGNvbnN0IGdldFNlbGVjdG9yID0gbWFrZUdldFNlbGVjdG9yKGNvbnRleHRJZCk7XG4gIGNvbnN0IGRyYWdIYW5kbGUkMSA9ICgoKSA9PiB7XG4gICAgY29uc3QgZ3JhYkN1cnNvciA9IGBcbiAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xuICAgICAgY3Vyc29yOiBncmFiO1xuICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnSGFuZGxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgYWx3YXlzOiBgXG4gICAgICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgYCxcbiAgICAgICAgcmVzdGluZzogZ3JhYkN1cnNvcixcbiAgICAgICAgZHJhZ2dpbmc6IG5vUG9pbnRlckV2ZW50cyxcbiAgICAgICAgZHJvcEFuaW1hdGluZzogZ3JhYkN1cnNvclxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gYFxuICAgICAgdHJhbnNpdGlvbjogJHt0cmFuc2l0aW9ucy5vdXRPZlRoZVdheX07XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdnYWJsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGRyYWdnaW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiB0cmFuc2l0aW9uLFxuICAgICAgICB1c2VyQ2FuY2VsOiB0cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJvcHBhYmxlJDEgPSB7XG4gICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyb3BwYWJsZS5jb250ZXh0SWQpLFxuICAgIHN0eWxlczoge1xuICAgICAgYWx3YXlzOiBgb3ZlcmZsb3ctYW5jaG9yOiBub25lO2BcbiAgICB9XG4gIH07XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGRyYWdnaW5nOiBgXG4gICAgICAgIGN1cnNvcjogZ3JhYmJpbmc7XG4gICAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgb3ZlcmZsb3ctYW5jaG9yOiBub25lO1xuICAgICAgYFxuICAgIH1cbiAgfTtcbiAgY29uc3QgcnVsZXMgPSBbZHJhZ2dhYmxlJDEsIGRyYWdIYW5kbGUkMSwgZHJvcHBhYmxlJDEsIGJvZHldO1xuICByZXR1cm4ge1xuICAgIGFsd2F5czogZ2V0U3R5bGVzKHJ1bGVzLCAnYWx3YXlzJyksXG4gICAgcmVzdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAncmVzdGluZycpLFxuICAgIGRyYWdnaW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcmFnZ2luZycpLFxuICAgIGRyb3BBbmltYXRpbmc6IGdldFN0eWxlcyhydWxlcywgJ2Ryb3BBbmltYXRpbmcnKSxcbiAgICB1c2VyQ2FuY2VsOiBnZXRTdHlsZXMocnVsZXMsICd1c2VyQ2FuY2VsJylcbiAgfTtcbn07XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5jb25zdCBnZXRIZWFkID0gKCkgPT4ge1xuICBjb25zdCBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAhaGVhZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIHRoZSBoZWFkIHRvIGFwcGVuZCBhIHN0eWxlIHRvJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGhlYWQ7XG59O1xuY29uc3QgY3JlYXRlU3R5bGVFbCA9IG5vbmNlID0+IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBpZiAobm9uY2UpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICByZXR1cm4gZWw7XG59O1xuZnVuY3Rpb24gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlTWVtbygoKSA9PiBnZXRTdHlsZXMkMShjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IGFsd2F5c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZHluYW1pY1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0RHluYW1pY1N0eWxlID0gdXNlQ2FsbGJhY2sobWVtb2l6ZU9uZShwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBkeW5hbWljUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSksIFtdKTtcbiAgY29uc3Qgc2V0QWx3YXlzU3R5bGUgPSB1c2VDYWxsYmFjayhwcm9wb3NlZCA9PiB7XG4gICAgY29uc3QgZWwgPSBhbHdheXNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICEoIWFsd2F5c1JlZi5jdXJyZW50ICYmICFkeW5hbWljUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnc3R5bGUgZWxlbWVudHMgYWxyZWFkeSBtb3VudGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbHdheXMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBjb25zdCBkeW5hbWljID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgYWx3YXlzUmVmLmN1cnJlbnQgPSBhbHdheXM7XG4gICAgZHluYW1pY1JlZi5jdXJyZW50ID0gZHluYW1pYztcbiAgICBhbHdheXMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tYWx3YXlzYCwgY29udGV4dElkKTtcbiAgICBkeW5hbWljLnNldEF0dHJpYnV0ZShgJHtwcmVmaXh9LWR5bmFtaWNgLCBjb250ZXh0SWQpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChhbHdheXMpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChkeW5hbWljKTtcbiAgICBzZXRBbHdheXNTdHlsZShzdHlsZXMuYWx3YXlzKTtcbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByZW1vdmUgPSByZWYgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICFjdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHVubW91bnQgcmVmIGFzIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICByZW1vdmUoYWx3YXlzUmVmKTtcbiAgICAgIHJlbW92ZShkeW5hbWljUmVmKTtcbiAgICB9O1xuICB9LCBbbm9uY2UsIHNldEFsd2F5c1N0eWxlLCBzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5hbHdheXMsIHN0eWxlcy5yZXN0aW5nLCBjb250ZXh0SWRdKTtcbiAgY29uc3QgZHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyYWdnaW5nKSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyYWdnaW5nXSk7XG4gIGNvbnN0IGRyb3BwaW5nID0gdXNlQ2FsbGJhY2socmVhc29uID0+IHtcbiAgICBpZiAocmVhc29uID09PSAnRFJPUCcpIHtcbiAgICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJvcEFuaW1hdGluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMudXNlckNhbmNlbCk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcm9wQW5pbWF0aW5nLCBzdHlsZXMudXNlckNhbmNlbF0pO1xuICBjb25zdCByZXN0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZHluYW1pY1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5yZXN0aW5nXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dpbmcsXG4gICAgZHJvcHBpbmcsXG4gICAgcmVzdGluZ1xuICB9KSwgW2RyYWdnaW5nLCBkcm9wcGluZywgcmVzdGluZ10pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChwYXJlbnROb2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxudmFyIGdldFdpbmRvd0Zyb21FbCA9IGVsID0+IHtcbiAgaWYgKGVsICYmIGVsLm93bmVyRG9jdW1lbnQgJiYgZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9XG4gIHJldHVybiB3aW5kb3c7XG59O1xuXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KGVsKSB7XG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIGdldFdpbmRvd0Zyb21FbChlbCkuSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgZHJhZ2dhYmxlSWQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGlmICghcG9zc2libGUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgYW55IGRyYWcgaGFuZGxlcyBpbiB0aGUgY29udGV4dCBcIiR7Y29udGV4dElkfVwiYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWcgaGFuZGxlIHdpdGggaWQgXCIke2RyYWdnYWJsZUlkfVwiIGFzIG5vIGhhbmRsZSB3aXRoIGEgbWF0Y2hpbmcgaWQgd2FzIGZvdW5kYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGhhbmRsZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdkcmFnIGhhbmRsZSBuZWVkcyB0byBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICBjb25zdCBlbnRyaWVzUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcmVjb3JkUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9jdXMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGlkLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICAgIGVudHJpZXNSZWYuY3VycmVudFtpZF0gPSBlbnRyeTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZW50cmllc1tpZF07XG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgdHJ5R2l2ZUZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5R2l2ZUZvY3VzKHRyeUdpdmVGb2N1c1RvKSB7XG4gICAgY29uc3QgaGFuZGxlID0gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCB0cnlHaXZlRm9jdXNUbyk7XG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGhhbmRsZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCB0cnlTaGlmdFJlY29yZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVNoaWZ0UmVjb3JkKHByZXZpb3VzLCByZWRpcmVjdFRvKSB7XG4gICAgaWYgKHJlY29yZFJlZi5jdXJyZW50ID09PSBwcmV2aW91cykge1xuICAgICAgcmVjb3JkUmVmLmN1cnJlbnQgPSByZWRpcmVjdFRvO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZFJlZi5jdXJyZW50O1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICB0cnlHaXZlRm9jdXMocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3RyeUdpdmVGb2N1c10pO1xuICBjb25zdCB0cnlSZWNvcmRGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlY29yZEZvY3VzKGlkKSB7XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGNvbnN0IGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9jdXNlZC5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCkgIT09IGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhckZyYW1lT25Vbm1vdW50KCkge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGZyYW1lSWQgPSByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZ2lzdGVyLFxuICAgIHRyeVJlY29yZEZvY3VzLFxuICAgIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLFxuICAgIHRyeVNoaWZ0UmVjb3JkXG4gIH0pLCBbcmVnaXN0ZXIsIHRyeVJlY29yZEZvY3VzLCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCwgdHJ5U2hpZnRSZWNvcmRdKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdHJ5KCkge1xuICBjb25zdCBlbnRyaWVzID0ge1xuICAgIGRyYWdnYWJsZXM6IHt9LFxuICAgIGRyb3BwYWJsZXM6IHt9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gW107XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYikge1xuICAgIHN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYik7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoKSB7XG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGNiID0+IGNiKGV2ZW50KSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGVudHJpZXMuZHJhZ2dhYmxlc1tpZF0gfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kRHJhZ2dhYmxlQnlJZChpZCk7XG4gICAgIWVudHJ5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgZHJhZ2dhYmxlIGVudHJ5IHdpdGggaWQgWyR7aWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnQURESVRJT04nLFxuICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoZW50cnksIGxhc3QpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC51bmlxdWVJZCAhPT0gZW50cnkudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyYWdnYWJsZUJ5SWQoZHJhZ2dhYmxlSWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2RyYWdnYWJsZUlkXTtcbiAgICAgIGlmIChlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0pIHtcbiAgICAgICAgbm90aWZ5KHtcbiAgICAgICAgICB0eXBlOiAnUkVNT1ZBTCcsXG4gICAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJhZ2dhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyYWdnYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcmFnZ2FibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcmFnZ2FibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBmaW5kRHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyb3BwYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJvcHBhYmxlQnlJZChpZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZERyb3BwYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIGRyb3BwYWJsZSBlbnRyeSB3aXRoIGlkIFske2lkfV1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBjb25zdCBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgIH0sXG4gICAgdW5yZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGZpbmREcm9wcGFibGVCeUlkKGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdO1xuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJvcHBhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyb3BwYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcm9wcGFibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBjbGVhbigpIHtcbiAgICBlbnRyaWVzLmRyYWdnYWJsZXMgPSB7fTtcbiAgICBlbnRyaWVzLmRyb3BwYWJsZXMgPSB7fTtcbiAgICBzdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlLFxuICAgIGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICBjb25zdCByZWdpc3RyeSA9IHVzZU1lbW8oY3JlYXRlUmVnaXN0cnksIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHJlZ2lzdHJ5LmNsZWFuKCk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5XSk7XG4gIHJldHVybiByZWdpc3RyeTtcbn1cblxudmFyIFN0b3JlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBnZXRCb2R5RWxlbWVudCA9ICgpID0+IHtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICFib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuYm9keScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBib2R5O1xufTtcblxuY29uc3QgdmlzdWFsbHlIaWRkZW4gPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB3aWR0aDogJzFweCcsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBib3JkZXI6ICcwJyxcbiAgcGFkZGluZzogJzAnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgJ2NsaXAtcGF0aCc6ICdpbnNldCgxMDAlKSdcbn07XG5cbmNvbnN0IGdldElkID0gY29udGV4dElkID0+IGByZmQtYW5ub3VuY2VtZW50LSR7Y29udGV4dElkfWA7XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRJZChjb250ZXh0SWQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIF9leHRlbmRzKGVsLnN0eWxlLCB2aXN1YWxseUhpZGRlbik7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gICAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbCA9PT0gcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtpZF0pO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUNhbGxiYWNrKG1lc3NhZ2UgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgQSBzY3JlZW4gcmVhZGVyIG1lc3NhZ2Ugd2FzIHRyeWluZyB0byBiZSBhbm5vdW5jZWQgYnV0IGl0IHdhcyB1bmFibGUgdG8gZG8gc28uXG4gICAgICBUaGlzIGNhbiBvY2N1ciBpZiB5b3UgdW5tb3VudCB5b3VyIDxEcmFnRHJvcENvbnRleHQgLz4gaW4geW91ciBvbkRyYWdFbmQuXG4gICAgICBDb25zaWRlciBjYWxsaW5nIHByb3ZpZGVkLmFubm91bmNlKCkgYmVmb3JlIHRoZSB1bm1vdW50IHNvIHRoYXQgdGhlIGluc3RydWN0aW9uIHdpbGxcbiAgICAgIG5vdCBiZSBsb3N0IGZvciB1c2VycyByZWx5aW5nIG9uIGEgc2NyZWVuIHJlYWRlci5cblxuICAgICAgTWVzc2FnZSBub3QgcGFzc2VkIHRvIHNjcmVlbiByZWFkZXI6XG5cbiAgICAgIFwiJHttZXNzYWdlfVwiXG4gICAgYCkgOiB2b2lkIDA7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGFubm91bmNlO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgc2VwYXJhdG9yOiAnOjonXG59O1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQocHJlZml4LCBvcHRpb25zID0gZGVmYXVsdHMpIHtcbiAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBgJHtwcmVmaXh9JHtvcHRpb25zLnNlcGFyYXRvcn0ke2lkfWAsIFtvcHRpb25zLnNlcGFyYXRvciwgcHJlZml4LCBpZF0pO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50SWQoe1xuICBjb250ZXh0SWQsXG4gIHVuaXF1ZUlkXG59KSB7XG4gIHJldHVybiBgcmZkLWhpZGRlbi10ZXh0LSR7Y29udGV4dElkfS0ke3VuaXF1ZUlkfWA7XG59XG5mdW5jdGlvbiB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gIGNvbnRleHRJZCxcbiAgdGV4dFxufSkge1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdoaWRkZW4tdGV4dCcsIHtcbiAgICBzZXBhcmF0b3I6ICctJ1xuICB9KTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGdldEVsZW1lbnRJZCh7XG4gICAgY29udGV4dElkLFxuICAgIHVuaXF1ZUlkXG4gIH0pLCBbdW5pcXVlSWQsIGNvbnRleHRJZF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5pZCA9IGlkO1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGdldEJvZHlFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gICAgICBpZiAoYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lkLCB0ZXh0XSk7XG4gIHJldHVybiBpZDtcbn1cblxudmFyIEFwcENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgcGVlckRlcGVuZGVuY2llcyA9IHtcblx0cmVhY3Q6IFwiXjE4LjAuMCB8fCBeMTkuMC4wXCJ9O1xuXG5jb25zdCBzZW12ZXIgPSAvKFxcZCspXFwuKFxcZCspXFwuKFxcZCspLztcbmNvbnN0IGdldFZlcnNpb24gPSB2YWx1ZSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHNlbXZlci5leGVjKHZhbHVlKTtcbiAgIShyZXN1bHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBVbmFibGUgdG8gcGFyc2UgUmVhY3QgdmVyc2lvbiAke3ZhbHVlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IG1ham9yID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gIGNvbnN0IG1pbm9yID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gIGNvbnN0IHBhdGNoID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gIHJldHVybiB7XG4gICAgbWFqb3IsXG4gICAgbWlub3IsXG4gICAgcGF0Y2gsXG4gICAgcmF3OiB2YWx1ZVxuICB9O1xufTtcbmNvbnN0IGlzU2F0aXNmaWVkID0gKGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgaWYgKGFjdHVhbC5tYWpvciA+IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFjdHVhbC5tYWpvciA8IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhY3R1YWwubWlub3IgPiBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWlub3IgPCBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYWN0dWFsLnBhdGNoID49IGV4cGVjdGVkLnBhdGNoO1xufTtcbnZhciBjaGVja1JlYWN0VmVyc2lvbiA9IChwZWVyRGVwVmFsdWUsIGFjdHVhbFZhbHVlKSA9PiB7XG4gIGNvbnN0IHBlZXJEZXAgPSBnZXRWZXJzaW9uKHBlZXJEZXBWYWx1ZSk7XG4gIGNvbnN0IGFjdHVhbCA9IGdldFZlcnNpb24oYWN0dWFsVmFsdWUpO1xuICBpZiAoaXNTYXRpc2ZpZWQocGVlckRlcCwgYWN0dWFsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBSZWFjdCB2ZXJzaW9uOiBbJHthY3R1YWwucmF3fV1cbiAgICBkb2VzIG5vdCBzYXRpc2Z5IGV4cGVjdGVkIHBlZXIgZGVwZW5kZW5jeSB2ZXJzaW9uOiBbJHtwZWVyRGVwLnJhd31dXG5cbiAgICBUaGlzIGNhbiByZXN1bHQgaW4gcnVuIHRpbWUgYnVncywgYW5kIGV2ZW4gZmF0YWwgY3Jhc2hlc1xuICBgKSA6IHZvaWQgMDtcbn07XG5cbmNvbnN0IHN1ZmZpeCA9IGBcbiAgV2UgZXhwZWN0IGEgaHRtbDUgZG9jdHlwZTogPCFkb2N0eXBlIGh0bWw+XG4gIFRoaXMgaXMgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYnJvd3NlciBsYXlvdXQgYW5kIG1lYXN1cmVtZW50XG5cbiAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL2RvY3R5cGUubWRcbmA7XG52YXIgY2hlY2tEb2N0eXBlID0gZG9jID0+IHtcbiAgY29uc3QgZG9jdHlwZSA9IGRvYy5kb2N0eXBlO1xuICBpZiAoIWRvY3R5cGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIE5vIDwhZG9jdHlwZSBodG1sPiBmb3VuZC5cblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkb2N0eXBlLm5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gZm91bmQ6ICgke2RvY3R5cGUubmFtZX0pXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG4gIGlmIChkb2N0eXBlLnB1YmxpY0lkICE9PSAnJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IHB1YmxpY0lkIGZvdW5kOiAoJHtkb2N0eXBlLnB1YmxpY0lkfSlcbiAgICAgIEEgaHRtbDUgZG9jdHlwZSBkb2VzIG5vdCBoYXZlIGEgcHVibGljSWRcblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVzZURldih1c2VIb29rKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdXNlSG9vaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZURldlNldHVwV2FybmluZyhmbiwgaW5wdXRzKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKGBcbiAgICAgICAgICBBIHNldHVwIHByb2JsZW0gd2FzIGVuY291bnRlcmVkLlxuXG4gICAgICAgICAgPiAke2UubWVzc2FnZX1cbiAgICAgICAgYCk7XG4gICAgICB9XG4gICAgfSwgaW5wdXRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCkge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgIGNoZWNrUmVhY3RWZXJzaW9uKHBlZXJEZXBlbmRlbmNpZXMucmVhY3QsIFJlYWN0LnZlcnNpb24pO1xuICAgIGNoZWNrRG9jdHlwZShkb2N1bWVudCk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXMoY3VycmVudCkge1xuICBjb25zdCByZWYgPSB1c2VSZWYoY3VycmVudCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgbG9jayA9IG51bGw7XG4gIGZ1bmN0aW9uIGlzQ2xhaW1lZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiBpc0FjdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbG9jaztcbiAgfVxuICBmdW5jdGlvbiBjbGFpbShhYmFuZG9uKSB7XG4gICAgISFsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNsYWltIGxvY2sgYXMgaXQgaXMgYWxyZWFkeSBjbGFpbWVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdMb2NrID0ge1xuICAgICAgYWJhbmRvblxuICAgIH07XG4gICAgbG9jayA9IG5ld0xvY2s7XG4gICAgcmV0dXJuIG5ld0xvY2s7XG4gIH1cbiAgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCByZWxlYXNlIGxvY2sgd2hlbiB0aGVyZSBpcyBubyBsb2NrJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBsb2NrID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0cnlBYmFuZG9uKCkge1xuICAgIGlmIChsb2NrKSB7XG4gICAgICBsb2NrLmFiYW5kb24oKTtcbiAgICAgIHJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0NsYWltZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgY2xhaW0sXG4gICAgcmVsZWFzZSxcbiAgICB0cnlBYmFuZG9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ2dpbmcoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmlzRHJhZ2dpbmc7XG59XG5cbmNvbnN0IHRhYiA9IDk7XG5jb25zdCBlbnRlciA9IDEzO1xuY29uc3QgZXNjYXBlID0gMjc7XG5jb25zdCBzcGFjZSA9IDMyO1xuY29uc3QgcGFnZVVwID0gMzM7XG5jb25zdCBwYWdlRG93biA9IDM0O1xuY29uc3QgZW5kID0gMzU7XG5jb25zdCBob21lID0gMzY7XG5jb25zdCBhcnJvd0xlZnQgPSAzNztcbmNvbnN0IGFycm93VXAgPSAzODtcbmNvbnN0IGFycm93UmlnaHQgPSAzOTtcbmNvbnN0IGFycm93RG93biA9IDQwO1xuXG5jb25zdCBwcmV2ZW50ZWRLZXlzID0ge1xuICBbZW50ZXJdOiB0cnVlLFxuICBbdGFiXTogdHJ1ZVxufTtcbnZhciBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMgPSBldmVudCA9PiB7XG4gIGlmIChwcmV2ZW50ZWRLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuY29uc3Qgc3VwcG9ydGVkRXZlbnROYW1lID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCBjYW5kaWRhdGVzID0gW2Jhc2UsIGBtcyR7YmFzZX1gLCBgd2Via2l0JHtiYXNlfWAsIGBtb3oke2Jhc2V9YCwgYG8ke2Jhc2V9YF07XG4gIGNvbnN0IHN1cHBvcnRlZCA9IGNhbmRpZGF0ZXMuZmluZChldmVudE5hbWUgPT4gYG9uJHtldmVudE5hbWV9YCBpbiBkb2N1bWVudCk7XG4gIHJldHVybiBzdXBwb3J0ZWQgfHwgYmFzZTtcbn0pKCk7XG5cbmNvbnN0IHByaW1hcnlCdXR0b24gPSAwO1xuY29uc3Qgc2xvcHB5Q2xpY2tUaHJlc2hvbGQgPSA1O1xuZnVuY3Rpb24gaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkKG9yaWdpbmFsLCBjdXJyZW50KSB7XG4gIHJldHVybiBNYXRoLmFicyhjdXJyZW50LnggLSBvcmlnaW5hbC54KSA+PSBzbG9wcHlDbGlja1RocmVzaG9sZCB8fCBNYXRoLmFicyhjdXJyZW50LnkgLSBvcmlnaW5hbC55KSA+PSBzbG9wcHlDbGlja1RocmVzaG9sZDtcbn1cbmNvbnN0IGlkbGUkMSA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xuZnVuY3Rpb24gZ2V0Q2FwdHVyZUJpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBjb21wbGV0ZWQsXG4gIGdldFBoYXNlLFxuICBzZXRQaGFzZVxufSkge1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdtb3VzZW1vdmUnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJ1dHRvbixcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgaWYgKGJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBiZSBJRExFJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHBlbmRpbmcgPSBwaGFzZS5wb2ludDtcbiAgICAgIGlmICghaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkKHBlbmRpbmcsIHBvaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBvaW50KTtcbiAgICAgIHNldFBoYXNlKHtcbiAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgYWN0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46ICgpID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgaWYgKHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSkge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlTW91c2VTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKGlkbGUkMSk7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDIpO1xuICBjb25zdCBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb25zID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICB9KTtcbiAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH07XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAnd2Via2l0bW91c2Vmb3JjZXdpbGxiZWdpbicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gYXBpLmZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlKGlkKTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWFwaS5jYW5HZXRMb2NrKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGxpc3RlbkZvckNhcHR1cmUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBpZGxlJDE7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG4gIGNvbnN0IGNhbmNlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmNhbmNlbCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgY29uc3QgYmluZENhcHR1cmluZ0V2ZW50cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGJpbmRDYXB0dXJpbmdFdmVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYmluZGluZ3MgPSBnZXRDYXB0dXJlQmluZGluZ3Moe1xuICAgICAgY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2U6ICgpID0+IHBoYXNlUmVmLmN1cnJlbnQsXG4gICAgICBzZXRQaGFzZTogcGhhc2UgPT4ge1xuICAgICAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgYmluZGluZ3MsIG9wdGlvbnMpO1xuICB9LCBbY2FuY2VsLCBzdG9wXSk7XG4gIGNvbnN0IHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShwaGFzZVJlZi5jdXJyZW50LnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSB7XG4gICAgICB0eXBlOiAnUEVORElORycsXG4gICAgICBwb2ludCxcbiAgICAgIGFjdGlvbnNcbiAgICB9O1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHNdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5jb25zdCBzY3JvbGxKdW1wS2V5cyA9IHtcbiAgW3BhZ2VEb3duXTogdHJ1ZSxcbiAgW3BhZ2VVcF06IHRydWUsXG4gIFtob21lXTogdHJ1ZSxcbiAgW2VuZF06IHRydWVcbn07XG5mdW5jdGlvbiBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApIHtcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmNhbmNlbCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuZHJvcCgpO1xuICB9XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gc3BhY2UpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZHJvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dEb3duKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZURvd24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93VXApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlVXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93UmlnaHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlUmlnaHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93TGVmdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVMZWZ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxKdW1wS2V5c1tldmVudC5rZXlDb2RlXSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoc3RhcnQnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2hlZWwnLFxuICAgIGZuOiBjYW5jZWwsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VLZXlib2FyZFNlbnNvcihhcGkpIHtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMSk7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IHNwYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVEcmFnID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICB9KTtcbiAgICAgIGlmICghcHJlRHJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IGlzQ2FwdHVyaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBwcmVEcmFnLnNuYXBMaWZ0KCk7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgIWlzQ2FwdHVyaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgY2FwdHVyaW5nIGEga2V5Ym9hcmQgZHJhZyB3aGVuIG5vdCBjYXB0dXJpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgICBpc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgICB9XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlTdGFydENhcHR1cmUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlXSk7XG59XG5cbmNvbnN0IGlkbGUgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmNvbnN0IHRpbWVGb3JMb25nUHJlc3MgPSAxMjA7XG5jb25zdCBmb3JjZVByZXNzVGhyZXNob2xkID0gMC4xNTtcbmZ1bmN0aW9uIGdldFdpbmRvd0JpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBnZXRQaGFzZVxufSkge1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdvcmllbnRhdGlvbmNoYW5nZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjb250ZXh0bWVudScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgY29tcGxldGVkLFxuICBnZXRQaGFzZVxufSkge1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICd0b3VjaG1vdmUnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBoYXNlLmhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZW5kJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGNhbmNlbCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGZvcmNlY2hhbmdlJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgIShwaGFzZS50eXBlICE9PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNGb3JjZVByZXNzID0gdG91Y2guZm9yY2UgPj0gZm9yY2VQcmVzc1RocmVzaG9sZDtcbiAgICAgIGlmICghaXNGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZFJlc3BlY3QgPSBwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNwZWN0KSB7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgaWYgKHBoYXNlLmhhc01vdmVkKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZVRvdWNoU2Vuc29yKGFwaSkge1xuICBjb25zdCBwaGFzZVJlZiA9IHVzZVJlZihpZGxlKTtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMik7XG4gIGNvbnN0IGdldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gZ2V0UGhhc2UoKSB7XG4gICAgcmV0dXJuIHBoYXNlUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzZXRQaGFzZShwaGFzZSkge1xuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgfSwgW10pO1xuICBjb25zdCBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoc3RhcnQnLFxuICAgIGZuOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuICAgICAgaWYgKCFkcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb25zID0gYXBpLnRyeUdldExvY2soZHJhZ2dhYmxlSWQsIHN0b3AsIHtcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICB9KTtcbiAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSB0b3VjaDtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGxpc3RlbkZvckNhcHR1cmUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3VycmVudC5sb25nUHJlc3NUaW1lcklkKTtcbiAgICB9XG4gICAgc2V0UGhhc2UoaWRsZSk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICBjb25zdCBjYW5jZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgcGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIHN0b3AoKTtcbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIGNvbnN0IGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZVxuICAgIH07XG4gICAgY29uc3QgdW5iaW5kVGFyZ2V0ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldEhhbmRsZUJpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bmJpbmRXaW5kb3cgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0V2luZG93QmluZGluZ3MoYXJncyksIG9wdGlvbnMpO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgICAgdW5iaW5kVGFyZ2V0KCk7XG4gICAgICB1bmJpbmRXaW5kb3coKTtcbiAgICB9O1xuICB9LCBbY2FuY2VsLCBnZXRQaGFzZSwgc3RvcF0pO1xuICBjb25zdCBzdGFydERyYWdnaW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnREcmFnZ2luZygpIHtcbiAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHN0YXJ0IGRyYWdnaW5nIGZyb20gcGhhc2UgJHtwaGFzZS50eXBlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBoYXNlLnBvaW50KTtcbiAgICBzZXRQaGFzZSh7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGhhc01vdmVkOiBmYWxzZVxuICAgIH0pO1xuICB9LCBbZ2V0UGhhc2UsIHNldFBoYXNlXSk7XG4gIGNvbnN0IHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShnZXRQaGFzZSgpLnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGxvbmdQcmVzc1RpbWVySWQgPSBzZXRUaW1lb3V0KHN0YXJ0RHJhZ2dpbmcsIHRpbWVGb3JMb25nUHJlc3MpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50LFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGxvbmdQcmVzc1RpbWVySWRcbiAgICB9KTtcbiAgICBiaW5kQ2FwdHVyaW5nRXZlbnRzKCk7XG4gIH0sIFtiaW5kQ2FwdHVyaW5nRXZlbnRzLCBnZXRQaGFzZSwgc2V0UGhhc2UsIHN0YXJ0RHJhZ2dpbmddKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjbGVhclRpbWVvdXQocGhhc2UubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgICAgIHNldFBoYXNlKGlkbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtnZXRQaGFzZSwgbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiB3ZWJraXRIYWNrKCkge1xuICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICAgIGZuOiAoKSA9PiB7fSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGVTZW5zb3JIb29rcyhzZW5zb3JIb29rcykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzUmVmID0gdXNlUHJldmlvdXMoc2Vuc29ySG9va3MpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKHByZXZpb3VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSBzZW5zb3JIb29rcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNoYW5nZSB0aGUgYW1vdW50IG9mIHNlbnNvciBob29rcyBhZnRlciBtb3VudGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGludGVyYWN0aXZlVGFnTmFtZXMgPSBbJ2lucHV0JywgJ2J1dHRvbicsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3ZpZGVvJywgJ2F1ZGlvJ107XG5mdW5jdGlvbiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudCkge1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc0FuSW50ZXJhY3RpdmVUYWcgPSBpbnRlcmFjdGl2ZVRhZ05hbWVzLmluY2x1ZGVzKGN1cnJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKGhhc0FuSW50ZXJhY3RpdmVUYWcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGUgPSBjdXJyZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gIGlmIChhdHRyaWJ1dGUgPT09ICd0cnVlJyB8fCBhdHRyaWJ1dGUgPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQucGFyZW50RWxlbWVudCk7XG59XG5mdW5jdGlvbiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCBldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgdGFyZ2V0KTtcbn1cblxudmFyIGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uID0gZWwgPT4gZ2V0UmVjdChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkuY2VudGVyO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5FbGVtZW50O1xufVxuXG5jb25zdCBzdXBwb3J0ZWRNYXRjaGVzTmFtZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSAnbWF0Y2hlcyc7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtiYXNlLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJ107XG4gIGNvbnN0IHZhbHVlID0gY2FuZGlkYXRlcy5maW5kKG5hbWUgPT4gbmFtZSBpbiBFbGVtZW50LnByb3RvdHlwZSk7XG4gIHJldHVybiB2YWx1ZSB8fCBiYXNlO1xufSkoKTtcbmZ1bmN0aW9uIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZWxbc3VwcG9ydGVkTWF0Y2hlc05hbWVdKHNlbGVjdG9yKSkge1xuICAgIHJldHVybiBlbDtcbiAgfVxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLnBhcmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwsIHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoY29udGV4dElkKSB7XG4gIHJldHVybiBgWyR7ZHJhZ0hhbmRsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2V2ZW50LnRhcmdldCBtdXN0IGJlIGEgRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29udGV4dElkKTtcbiAgY29uc3QgaGFuZGxlID0gY2xvc2VzdCh0YXJnZXQsIHNlbGVjdG9yKTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG11c3QgYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCkge1xuICBjb25zdCBoYW5kbGUgPSBmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCk7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZS5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtkcmFnZ2FibGUuY29udGV4dElkfT1cIiR7Y29udGV4dElkfVwiXWA7XG4gIGNvbnN0IHBvc3NpYmxlID0gcXVlcnlTZWxlY3RvckFsbChkb2N1bWVudCwgc2VsZWN0b3IpO1xuICBjb25zdCBkcmFnZ2FibGUkMSA9IHBvc3NpYmxlLmZpbmQoZWwgPT4ge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLmlkKSA9PT0gZHJhZ2dhYmxlSWQ7XG4gIH0pO1xuICBpZiAoIWRyYWdnYWJsZSQxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFpc0h0bWxFbGVtZW50KGRyYWdnYWJsZSQxKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0RyYWdnYWJsZSBlbGVtZW50IGlzIG5vdCBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGRyYWdnYWJsZSQxO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gaXNBY3RpdmUoe1xuICBleHBlY3RlZCxcbiAgcGhhc2UsXG4gIGlzTG9ja0FjdGl2ZSxcbiAgc2hvdWxkV2FyblxufSkge1xuICBpZiAoIWlzTG9ja0FjdGl2ZSgpKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBzZW5zb3Igbm8gbG9uZ2VyIGhhcyBhbiBhY3Rpb24gbG9jay5cblxuICAgICAgICBUaXBzOlxuXG4gICAgICAgIC0gVGhyb3cgYXdheSB5b3VyIGFjdGlvbiBoYW5kbGVycyB3aGVuIGZvcmNlU3RvcCgpIGlzIGNhbGxlZFxuICAgICAgICAtIENoZWNrIGFjdGlvbnMuaXNBY3RpdmUoKSBpZiB5b3UgcmVhbGx5IG5lZWQgdG9cbiAgICAgIGApIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV4cGVjdGVkICE9PSBwaGFzZSkge1xuICAgIGlmIChzaG91bGRXYXJuKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgICAgQ2Fubm90IHBlcmZvcm0gYWN0aW9uLlxuICAgICAgICBUaGUgYWN0aW9ucyB5b3UgdXNlZCBiZWxvbmcgdG8gYW4gb3V0ZGF0ZWQgcGhhc2VcblxuICAgICAgICBDdXJyZW50IHBoYXNlOiAke2V4cGVjdGVkfVxuICAgICAgICBZb3UgY2FsbGVkIGFuIGFjdGlvbiBmcm9tIG91dGRhdGVkIHBoYXNlOiAke3BoYXNlfVxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBEbyBub3QgdXNlIHByZURyYWdBY3Rpb25zIGFjdGlvbnMgYWZ0ZXIgY2FsbGluZyBwcmVEcmFnQWN0aW9ucy5saWZ0KClcbiAgICAgIGApIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5TdGFydCh7XG4gIGxvY2tBUEksXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgZHJhZ2dhYmxlSWRcbn0pIHtcbiAgaWYgKGxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIHdpdGggaWQ6ICR7ZHJhZ2dhYmxlSWR9YCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZW50cnkub3B0aW9ucy5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFjYW5TdGFydERyYWcoc3RvcmUuZ2V0U3RhdGUoKSwgZHJhZ2dhYmxlSWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdHJ5U3RhcnQoe1xuICBsb2NrQVBJLFxuICBjb250ZXh0SWQsXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgZHJhZ2dhYmxlSWQsXG4gIGZvcmNlU2Vuc29yU3RvcCxcbiAgc291cmNlRXZlbnRcbn0pIHtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSBjYW5TdGFydCh7XG4gICAgbG9ja0FQSSxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBkcmFnZ2FibGVJZFxuICB9KTtcbiAgaWYgKCFzaG91bGRTdGFydCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoZHJhZ2dhYmxlSWQpO1xuICBjb25zdCBlbCA9IGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBlbnRyeS5kZXNjcmlwdG9yLmlkKTtcbiAgaWYgKCFlbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSBlbGVtZW50IHdpdGggaWQ6ICR7ZHJhZ2dhYmxlSWR9YCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNvdXJjZUV2ZW50ICYmICFlbnRyeS5vcHRpb25zLmNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzICYmIGlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudChlbCwgc291cmNlRXZlbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jayA9IGxvY2tBUEkuY2xhaW0oZm9yY2VTZW5zb3JTdG9wIHx8IG5vb3AkMik7XG4gIGxldCBwaGFzZSA9ICdQUkVfRFJBRyc7XG4gIGZ1bmN0aW9uIGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCkge1xuICAgIHJldHVybiBlbnRyeS5vcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzO1xuICB9XG4gIGZ1bmN0aW9uIGlzTG9ja0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gbG9ja0FQSS5pc0FjdGl2ZShsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiB0cnlEaXNwYXRjaChleHBlY3RlZCwgZ2V0QWN0aW9uKSB7XG4gICAgaWYgKGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGdldEFjdGlvbigpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcgPSB0cnlEaXNwYXRjaC5iaW5kKG51bGwsICdEUkFHR0lORycpO1xuICBmdW5jdGlvbiBsaWZ0KGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICAgIHBoYXNlID0gJ0NPTVBMRVRFRCc7XG4gICAgfVxuICAgIGlmIChwaGFzZSAhPT0gJ1BSRV9EUkFHJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbGlmdCBpbiBwaGFzZSAke3BoYXNlfWApIDogaW52YXJpYW50KCkgO1xuICAgIH1cbiAgICBzdG9yZS5kaXNwYXRjaChsaWZ0JDEoYXJncy5saWZ0QWN0aW9uQXJncykpO1xuICAgIHBoYXNlID0gJ0RSQUdHSU5HJztcbiAgICBmdW5jdGlvbiBmaW5pc2gocmVhc29uLCBvcHRpb25zID0ge1xuICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IGZhbHNlXG4gICAgfSkge1xuICAgICAgYXJncy5jbGVhbnVwKCk7XG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRCbG9ja05leHRDbGljaykge1xuICAgICAgICBjb25zdCB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgICAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgICAgICAgZm46IHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgICAgc2V0VGltZW91dCh1bmJpbmQpO1xuICAgICAgfVxuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgICBleHBlY3RlZDogJ0RSQUdHSU5HJyxcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgZHJvcDogb3B0aW9ucyA9PiBmaW5pc2goJ0RST1AnLCBvcHRpb25zKSxcbiAgICAgIGNhbmNlbDogb3B0aW9ucyA9PiBmaW5pc2goJ0NBTkNFTCcsIG9wdGlvbnMpLFxuICAgICAgLi4uYXJncy5hY3Rpb25zXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmbHVpZExpZnQoY2xpZW50U2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbW92ZSQxID0gcmFmU2NoZChjbGllbnQgPT4ge1xuICAgICAgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcoKCkgPT4gbW92ZSh7XG4gICAgICAgIGNsaWVudFxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFwaSA9IGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ0ZMVUlEJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6ICgpID0+IG1vdmUkMS5jYW5jZWwoKSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgbW92ZTogbW92ZSQxXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFwaSxcbiAgICAgIG1vdmU6IG1vdmUkMVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc25hcExpZnQoKSB7XG4gICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgIG1vdmVVcDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVVwKSxcbiAgICAgIG1vdmVSaWdodDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVJpZ2h0KSxcbiAgICAgIG1vdmVEb3duOiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlRG93biksXG4gICAgICBtb3ZlTGVmdDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZUxlZnQpXG4gICAgfTtcbiAgICByZXR1cm4gbGlmdCh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbjogZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24oZWwpLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdTTkFQJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IG5vb3AkMixcbiAgICAgIGFjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFByZURyYWcoKSB7XG4gICAgY29uc3Qgc2hvdWxkUmVsZWFzZSA9IGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiAnUFJFX0RSQUcnLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFJlbGVhc2UpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwcmVEcmFnID0ge1xuICAgIGlzQWN0aXZlOiAoKSA9PiBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICB9KSxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgZmx1aWRMaWZ0LFxuICAgIHNuYXBMaWZ0LFxuICAgIGFib3J0OiBhYm9ydFByZURyYWdcbiAgfTtcbiAgcmV0dXJuIHByZURyYWc7XG59XG5jb25zdCBkZWZhdWx0U2Vuc29ycyA9IFt1c2VNb3VzZVNlbnNvciwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZVRvdWNoU2Vuc29yXTtcbmZ1bmN0aW9uIHVzZVNlbnNvck1hcnNoYWwoe1xuICBjb250ZXh0SWQsXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgY3VzdG9tU2Vuc29ycyxcbiAgZW5hYmxlRGVmYXVsdFNlbnNvcnNcbn0pIHtcbiAgY29uc3QgdXNlU2Vuc29ycyA9IFsuLi4oZW5hYmxlRGVmYXVsdFNlbnNvcnMgPyBkZWZhdWx0U2Vuc29ycyA6IFtdKSwgLi4uKGN1c3RvbVNlbnNvcnMgfHwgW10pXTtcbiAgY29uc3QgbG9ja0FQSSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZSgpKVswXTtcbiAgY29uc3QgdHJ5QWJhbmRvbkxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCkge1xuICAgIGlmIChpc0RyYWdnaW5nKHByZXZpb3VzKSAmJiAhaXNEcmFnZ2luZyhjdXJyZW50KSkge1xuICAgICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgfVxuICB9LCBbbG9ja0FQSV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIGxpc3RlblRvU3RvcmUoKSB7XG4gICAgbGV0IHByZXZpb3VzID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtsb2NrQVBJLCBzdG9yZSwgdHJ5QWJhbmRvbkxvY2tdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2tBUEkudHJ5QWJhbmRvbjtcbiAgfSwgW2xvY2tBUEkudHJ5QWJhbmRvbl0pO1xuICBjb25zdCBjYW5HZXRMb2NrID0gdXNlQ2FsbGJhY2soZHJhZ2dhYmxlSWQgPT4ge1xuICAgIHJldHVybiBjYW5TdGFydCh7XG4gICAgICBsb2NrQVBJLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBzdG9yZSxcbiAgICAgIGRyYWdnYWJsZUlkXG4gICAgfSk7XG4gIH0sIFtsb2NrQVBJLCByZWdpc3RyeSwgc3RvcmVdKTtcbiAgY29uc3QgdHJ5R2V0TG9jayA9IHVzZUNhbGxiYWNrKChkcmFnZ2FibGVJZCwgZm9yY2VTdG9wLCBvcHRpb25zKSA9PiB0cnlTdGFydCh7XG4gICAgbG9ja0FQSSxcbiAgICByZWdpc3RyeSxcbiAgICBjb250ZXh0SWQsXG4gICAgc3RvcmUsXG4gICAgZHJhZ2dhYmxlSWQsXG4gICAgZm9yY2VTZW5zb3JTdG9wOiBmb3JjZVN0b3AgfHwgbnVsbCxcbiAgICBzb3VyY2VFdmVudDogb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZUV2ZW50ID8gb3B0aW9ucy5zb3VyY2VFdmVudCA6IG51bGxcbiAgfSksIFtjb250ZXh0SWQsIGxvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICBjb25zdCBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4gdHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpLCBbY29udGV4dElkXSk7XG4gIGNvbnN0IGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlID0gdXNlQ2FsbGJhY2soaWQgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGlkKTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeS5vcHRpb25zIDogbnVsbDtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICBjb25zdCB0cnlSZWxlYXNlTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlbGVhc2VMb2NrKCkge1xuICAgIGlmICghbG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcbiAgICBpZiAoc3RvcmUuZ2V0U3RhdGUoKS5waGFzZSAhPT0gJ0lETEUnKSB7XG4gICAgICBzdG9yZS5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtsb2NrQVBJLCBzdG9yZV0pO1xuICBjb25zdCBpc0xvY2tDbGFpbWVkID0gdXNlQ2FsbGJhY2soKCkgPT4gbG9ja0FQSS5pc0NsYWltZWQoKSwgW2xvY2tBUEldKTtcbiAgY29uc3QgYXBpID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGNhbkdldExvY2ssXG4gICAgdHJ5R2V0TG9jayxcbiAgICBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkLFxuICAgIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLFxuICAgIHRyeVJlbGVhc2VMb2NrLFxuICAgIGlzTG9ja0NsYWltZWRcbiAgfSksIFtjYW5HZXRMb2NrLCB0cnlHZXRMb2NrLCBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkLCBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSwgdHJ5UmVsZWFzZUxvY2ssIGlzTG9ja0NsYWltZWRdKTtcbiAgdXNlVmFsaWRhdGVTZW5zb3JIb29rcyh1c2VTZW5zb3JzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2VTZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdXNlU2Vuc29yc1tpXShhcGkpO1xuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVJlc3BvbmRlcnMgPSBwcm9wcyA9PiAoe1xuICBvbkJlZm9yZUNhcHR1cmU6IHQgPT4ge1xuICAgIGNvbnN0IG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAocHJvcHMub25CZWZvcmVDYXB0dXJlKSB7XG4gICAgICAgIHByb3BzLm9uQmVmb3JlQ2FwdHVyZSh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZsdXNoU3luYyhvbkJlZm9yZUNhcHVyZUNhbGxiYWNrKTtcbiAgfSxcbiAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZVxufSk7XG5jb25zdCBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zID0gcHJvcHMgPT4gKHtcbiAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIC4uLnByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnMsXG4gIGR1cmF0aW9uRGFtcGVuaW5nOiB7XG4gICAgLi4uZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcsXG4gICAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFN0b3JlKGxhenlSZWYpIHtcbiAgIWxhenlSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHN0b3JlIGZyb20gbGF6eSByZWYnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gbGF6eVJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gQXBwKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgc2V0Q2FsbGJhY2tzLFxuICAgIHNlbnNvcnMsXG4gICAgbm9uY2UsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgbGF6eVN0b3JlUmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VTdGFydHVwVmFsaWRhdGlvbigpO1xuICBjb25zdCBsYXN0UHJvcHNSZWYgPSB1c2VQcmV2aW91cyhwcm9wcyk7XG4gIGNvbnN0IGdldFJlc3BvbmRlcnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlc3BvbmRlcnMobGFzdFByb3BzUmVmLmN1cnJlbnQpO1xuICB9LCBbbGFzdFByb3BzUmVmXSk7XG4gIGNvbnN0IGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUF1dG9TY3JvbGxlck9wdGlvbnMobGFzdFByb3BzUmVmLmN1cnJlbnQpO1xuICB9LCBbbGFzdFByb3BzUmVmXSk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQW5ub3VuY2VyKGNvbnRleHRJZCk7XG4gIGNvbnN0IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkID0gdXNlSGlkZGVuVGV4dEVsZW1lbnQoe1xuICAgIGNvbnRleHRJZCxcbiAgICB0ZXh0OiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHN0eWxlTWFyc2hhbCA9IHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKTtcbiAgY29uc3QgbGF6eURpc3BhdGNoID0gdXNlQ2FsbGJhY2soYWN0aW9uID0+IHtcbiAgICBnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmRpc3BhdGNoKGFjdGlvbik7XG4gIH0sIFtdKTtcbiAgY29uc3QgbWFyc2hhbENhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4gYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICBwdWJsaXNoV2hpbGVEcmFnZ2luZyxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkLFxuICAgIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQsXG4gICAgY29sbGVjdGlvblN0YXJ0aW5nXG4gIH0sIGxhenlEaXNwYXRjaCksIFtsYXp5RGlzcGF0Y2hdKTtcbiAgY29uc3QgcmVnaXN0cnkgPSB1c2VSZWdpc3RyeSgpO1xuICBjb25zdCBkaW1lbnNpb25NYXJzaGFsID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZURpbWVuc2lvbk1hcnNoYWwocmVnaXN0cnksIG1hcnNoYWxDYWxsYmFja3MpO1xuICB9LCBbcmVnaXN0cnksIG1hcnNoYWxDYWxsYmFja3NdKTtcbiAgY29uc3QgYXV0b1Njcm9sbGVyID0gdXNlTWVtbygoKSA9PiBjcmVhdGVBdXRvU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGU6IGRpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnMsXG4gICAgLi4uYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICAgIG1vdmVcbiAgICB9LCBsYXp5RGlzcGF0Y2gpXG4gIH0pLCBbZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGUsIGxhenlEaXNwYXRjaCwgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc10pO1xuICBjb25zdCBmb2N1c01hcnNoYWwgPSB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKTtcbiAgY29uc3Qgc3RvcmUgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZVN0b3JlKHtcbiAgICBhbm5vdW5jZSxcbiAgICBhdXRvU2Nyb2xsZXIsXG4gICAgZGltZW5zaW9uTWFyc2hhbCxcbiAgICBmb2N1c01hcnNoYWwsXG4gICAgZ2V0UmVzcG9uZGVycyxcbiAgICBzdHlsZU1hcnNoYWxcbiAgfSksIFthbm5vdW5jZSwgYXV0b1Njcm9sbGVyLCBkaW1lbnNpb25NYXJzaGFsLCBmb2N1c01hcnNoYWwsIGdldFJlc3BvbmRlcnMsIHN0eWxlTWFyc2hhbF0pO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChsYXp5U3RvcmVSZWYuY3VycmVudCAmJiBsYXp5U3RvcmVSZWYuY3VycmVudCAhPT0gc3RvcmUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ3VuZXhwZWN0ZWQgc3RvcmUgY2hhbmdlJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGxhenlTdG9yZVJlZi5jdXJyZW50ID0gc3RvcmU7XG4gIGNvbnN0IHRyeVJlc2V0U3RvcmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGdldFN0b3JlKGxhenlTdG9yZVJlZik7XG4gICAgY29uc3Qgc3RhdGUgPSBjdXJyZW50LmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIGN1cnJlbnQuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGlzRHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmlzRHJhZ2dpbmc7XG4gIH0sIFtdKTtcbiAgY29uc3QgYXBwQ2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmcsXG4gICAgdHJ5QWJvcnQ6IHRyeVJlc2V0U3RvcmVcbiAgfSksIFtpc0RyYWdnaW5nLCB0cnlSZXNldFN0b3JlXSk7XG4gIHNldENhbGxiYWNrcyhhcHBDYWxsYmFja3MpO1xuICBjb25zdCBnZXRDYW5MaWZ0ID0gdXNlQ2FsbGJhY2soaWQgPT4gY2FuU3RhcnREcmFnKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSwgaWQpLCBbXSk7XG4gIGNvbnN0IGdldElzTW92ZW1lbnRBbGxvd2VkID0gdXNlQ2FsbGJhY2soKCkgPT4gaXNNb3ZlbWVudEFsbG93ZWQoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpKSwgW10pO1xuICBjb25zdCBhcHBDb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIG1hcnNoYWw6IGRpbWVuc2lvbk1hcnNoYWwsXG4gICAgZm9jdXM6IGZvY3VzTWFyc2hhbCxcbiAgICBjb250ZXh0SWQsXG4gICAgY2FuTGlmdDogZ2V0Q2FuTGlmdCxcbiAgICBpc01vdmVtZW50QWxsb3dlZDogZ2V0SXNNb3ZlbWVudEFsbG93ZWQsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgcmVnaXN0cnlcbiAgfSksIFtjb250ZXh0SWQsIGRpbWVuc2lvbk1hcnNoYWwsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBmb2N1c01hcnNoYWwsIGdldENhbkxpZnQsIGdldElzTW92ZW1lbnRBbGxvd2VkLCByZWdpc3RyeV0pO1xuICB1c2VTZW5zb3JNYXJzaGFsKHtcbiAgICBjb250ZXh0SWQsXG4gICAgc3RvcmUsXG4gICAgcmVnaXN0cnksXG4gICAgY3VzdG9tU2Vuc29yczogc2Vuc29ycyB8fCBudWxsLFxuICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzOiBwcm9wcy5lbmFibGVEZWZhdWx0U2Vuc29ycyAhPT0gZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHRyeVJlc2V0U3RvcmU7XG4gIH0sIFt0cnlSZXNldFN0b3JlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBwQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICAgIHN0b3JlOiBzdG9yZVxuICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiB1c2VVbmlxdWVDb250ZXh0SWQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VJZCgpO1xufVxuXG5mdW5jdGlvbiBEcmFnRHJvcENvbnRleHQocHJvcHMpIHtcbiAgY29uc3QgY29udGV4dElkID0gdXNlVW5pcXVlQ29udGV4dElkKCk7XG4gIGNvbnN0IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IHByb3BzLmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyB8fCBwcmVzZXQuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCBudWxsLCBzZXRDYWxsYmFja3MgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIHtcbiAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsXG4gICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzLFxuICAgIHNlbnNvcnM6IHByb3BzLnNlbnNvcnMsXG4gICAgb25CZWZvcmVDYXB0dXJlOiBwcm9wcy5vbkJlZm9yZUNhcHR1cmUsXG4gICAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZSxcbiAgICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgICBhdXRvU2Nyb2xsZXJPcHRpb25zOiBwcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmNvbnN0IHpJbmRleE9wdGlvbnMgPSB7XG4gIGRyYWdnaW5nOiA1MDAwLFxuICBkcm9wQW5pbWF0aW5nOiA0NTAwXG59O1xuY29uc3QgZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uID0gKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQsIGRyb3BwaW5nKSA9PiB7XG4gIGlmIChkcm9wcGluZykge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5kcm9wKGRyb3BwaW5nLmR1cmF0aW9uKTtcbiAgfVxuICBpZiAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9ucy5zbmFwO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucy5mbHVpZDtcbn07XG5jb25zdCBnZXREcmFnZ2luZ09wYWNpdHkgPSAoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZykgPT4ge1xuICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gaXNEcm9wQW5pbWF0aW5nID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBjb21iaW5lLm9wYWNpdHkuY29tYmluaW5nO1xufTtcbmNvbnN0IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSA9IGRyYWdnaW5nID0+IHtcbiAgaWYgKGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgfVxuICByZXR1cm4gZHJhZ2dpbmcubW9kZSA9PT0gJ1NOQVAnO1xufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nU3R5bGUoZHJhZ2dpbmcpIHtcbiAgY29uc3QgZGltZW5zaW9uID0gZHJhZ2dpbmcuZGltZW5zaW9uO1xuICBjb25zdCBib3ggPSBkaW1lbnNpb24uY2xpZW50O1xuICBjb25zdCB7XG4gICAgb2Zmc2V0LFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRyb3BwaW5nXG4gIH0gPSBkcmFnZ2luZztcbiAgY29uc3QgaXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbWJpbmVXaXRoKTtcbiAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZShkcmFnZ2luZyk7XG4gIGNvbnN0IGlzRHJvcEFuaW1hdGluZyA9IEJvb2xlYW4oZHJvcHBpbmcpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBpc0Ryb3BBbmltYXRpbmcgPyB0cmFuc2Zvcm1zLmRyb3Aob2Zmc2V0LCBpc0NvbWJpbmluZykgOiB0cmFuc2Zvcm1zLm1vdmVUbyhvZmZzZXQpO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB0b3A6IGJveC5tYXJnaW5Cb3gudG9wLFxuICAgIGxlZnQ6IGJveC5tYXJnaW5Cb3gubGVmdCxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogYm94LmJvcmRlckJveC53aWR0aCxcbiAgICBoZWlnaHQ6IGJveC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHRyYW5zaXRpb246IGdldERyYWdnaW5nVHJhbnNpdGlvbihzaG91bGRBbmltYXRlLCBkcm9wcGluZyksXG4gICAgdHJhbnNmb3JtLFxuICAgIG9wYWNpdHk6IGdldERyYWdnaW5nT3BhY2l0eShpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSxcbiAgICB6SW5kZXg6IGlzRHJvcEFuaW1hdGluZyA/IHpJbmRleE9wdGlvbnMuZHJvcEFuaW1hdGluZyA6IHpJbmRleE9wdGlvbnMuZHJhZ2dpbmcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH07XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVN0eWxlKHNlY29uZGFyeSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtcy5tb3ZlVG8oc2Vjb25kYXJ5Lm9mZnNldCksXG4gICAgdHJhbnNpdGlvbjogc2Vjb25kYXJ5LnNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQgPyB1bmRlZmluZWQgOiAnbm9uZSdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlJDEobWFwcGVkKSB7XG4gIHJldHVybiBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyA/IGdldERyYWdnaW5nU3R5bGUobWFwcGVkKSA6IGdldFNlY29uZGFyeVN0eWxlKG1hcHBlZCk7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwgPSBvcmlnaW4pIHtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGJvcmRlckJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjbGllbnQgPSBjYWxjdWxhdGVCb3goYm9yZGVyQm94LCBjb21wdXRlZFN0eWxlcyk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSB7XG4gICAgY2xpZW50LFxuICAgIHRhZ05hbWU6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICBkaXNwbGF5OiBjb21wdXRlZFN0eWxlcy5kaXNwbGF5XG4gIH07XG4gIGNvbnN0IGRpc3BsYWNlQnkgPSB7XG4gICAgeDogY2xpZW50Lm1hcmdpbkJveC53aWR0aCxcbiAgICB5OiBjbGllbnQubWFyZ2luQm94LmhlaWdodFxuICB9O1xuICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcixcbiAgICBwbGFjZWhvbGRlcixcbiAgICBkaXNwbGFjZUJ5LFxuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2RyYWdnYWJsZScpO1xuICBjb25zdCB7XG4gICAgZGVzY3JpcHRvcixcbiAgICByZWdpc3RyeSxcbiAgICBnZXREcmFnZ2FibGVSZWYsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgaXNFbmFibGVkXG4gIH0gPSBhcmdzO1xuICBjb25zdCBvcHRpb25zID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGlzRW5hYmxlZFxuICB9KSwgW2NhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBpc0VuYWJsZWQsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbiA9IHVzZUNhbGxiYWNrKHdpbmRvd1Njcm9sbCA9PiB7XG4gICAgY29uc3QgZWwgPSBnZXREcmFnZ2FibGVSZWYoKTtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGRpbWVuc2lvbiB3aGVuIG5vIHJlZiBpcyBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsKTtcbiAgfSwgW2Rlc2NyaXB0b3IsIGdldERyYWdnYWJsZVJlZl0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIG9wdGlvbnMsXG4gICAgZ2V0RGltZW5zaW9uXG4gIH0pLCBbZGVzY3JpcHRvciwgZ2V0RGltZW5zaW9uLCBvcHRpb25zLCB1bmlxdWVJZF0pO1xuICBjb25zdCBwdWJsaXNoZWRSZWYgPSB1c2VSZWYoZW50cnkpO1xuICBjb25zdCBpc0ZpcnN0UHVibGlzaFJlZiA9IHVzZVJlZih0cnVlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnJlZ2lzdGVyKHB1Ymxpc2hlZFJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gKCkgPT4gcmVnaXN0cnkuZHJhZ2dhYmxlLnVucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0ZpcnN0UHVibGlzaFJlZi5jdXJyZW50KSB7XG4gICAgICBpc0ZpcnN0UHVibGlzaFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSBwdWJsaXNoZWRSZWYuY3VycmVudDtcbiAgICBwdWJsaXNoZWRSZWYuY3VycmVudCA9IGVudHJ5O1xuICAgIHJlZ2lzdHJ5LmRyYWdnYWJsZS51cGRhdGUoZW50cnksIGxhc3QpO1xuICB9LCBbZW50cnksIHJlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xufVxuXG52YXIgRHJvcHBhYmxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIGNoZWNrSXNWYWxpZElubmVyUmVmKGVsKSB7XG4gICEoZWwgJiYgaXNIdG1sRWxlbWVudChlbCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgXG4gICAgcHJvdmlkZWQuaW5uZXJSZWYgaGFzIG5vdCBiZWVuIHByb3ZpZGVkIHdpdGggYSBIVE1MRWxlbWVudC5cblxuICAgIFlvdSBjYW4gZmluZCBhIGd1aWRlIG9uIHVzaW5nIHRoZSBpbm5lclJlZiBjYWxsYmFjayBmdW5jdGlvbnMgYXQ6XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvZ3VpZGVzL3VzaW5nLWlubmVyLXJlZi5tZFxuICBgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uJDEocHJvcHMsIGNvbnRleHRJZCwgZ2V0UmVmKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgZnVuY3Rpb24gcHJlZml4KGlkKSB7XG4gICAgICByZXR1cm4gYERyYWdnYWJsZVtpZDogJHtpZH1dOiBgO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHByb3BzLmRyYWdnYWJsZUlkO1xuICAgICFpZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RyYWdnYWJsZSByZXF1aXJlcyBhIGRyYWdnYWJsZUlkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIGlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBEcmFnZ2FibGUgcmVxdWlyZXMgYSBbc3RyaW5nXSBkcmFnZ2FibGVJZC5cbiAgICAgIFByb3ZpZGVkOiBbdHlwZTogJHt0eXBlb2YgaWR9XSAodmFsdWU6ICR7aWR9KWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhTnVtYmVyLmlzSW50ZWdlcihwcm9wcy5pbmRleCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke3ByZWZpeChpZCl9IHJlcXVpcmVzIGFuIGludGVnZXIgaW5kZXggcHJvcGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAocHJvcHMubWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0UmVmKCkpO1xuICAgIGlmIChwcm9wcy5pc0VuYWJsZWQpIHtcbiAgICAgICFmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7cHJlZml4KGlkKX0gVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGVgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSkge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VSZWYoaXNDbG9uZSk7XG4gICAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICAgICEoaXNDbG9uZSA9PT0gaW5pdGlhbFJlZi5jdXJyZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RyYWdnYWJsZSBpc0Nsb25lIHByb3AgdmFsdWUgY2hhbmdlZCBkdXJpbmcgY29tcG9uZW50IGxpZmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSwgW2lzQ2xvbmVdKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlcXVpcmVkQ29udGV4dChDb250ZXh0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICFyZXN1bHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCByZXF1aXJlZCBjb250ZXh0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcHJldmVudEh0bWw1RG5kKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5jb25zdCBEcmFnZ2FibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soKGVsID0gbnVsbCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZWw7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICBpbmRleDogcHJvcHMuaW5kZXgsXG4gICAgdHlwZSxcbiAgICBkcm9wcGFibGVJZFxuICB9KSwgW3Byb3BzLmRyYWdnYWJsZUlkLCBwcm9wcy5pbmRleCwgdHlwZSwgZHJvcHBhYmxlSWRdKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGlzRW5hYmxlZCxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBpc0Nsb25lLFxuICAgIG1hcHBlZCxcbiAgICBkcm9wQW5pbWF0aW9uRmluaXNoZWQ6IGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvblxuICB9ID0gcHJvcHM7XG4gIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpO1xuICB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpO1xuICBpZiAoIWlzQ2xvbmUpIHtcbiAgICBjb25zdCBmb3JQdWJsaXNoZXIgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgcmVnaXN0cnksXG4gICAgICBnZXREcmFnZ2FibGVSZWY6IGdldFJlZixcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9KSwgW2Rlc2NyaXB0b3IsIHJlZ2lzdHJ5LCBnZXRSZWYsIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcywgaXNFbmFibGVkXSk7XG4gICAgdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGZvclB1Ymxpc2hlcik7XG4gIH1cbiAgY29uc3QgZHJhZ0hhbmRsZVByb3BzID0gdXNlTWVtbygoKSA9PiBpc0VuYWJsZWQgPyB7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgJ2RhdGEtcmZkLWRyYWctaGFuZGxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICBvbkRyYWdTdGFydDogcHJldmVudEh0bWw1RG5kXG4gIH0gOiBudWxsLCBbY29udGV4dElkLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZHJhZ2dhYmxlSWQsIGlzRW5hYmxlZF0pO1xuICBjb25zdCBvbk1vdmVFbmQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKG1hcHBlZC50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbWFwcGVkLmRyb3BwaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZsdXNoU3luYyhkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24pO1xuICB9LCBbZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uLCBtYXBwZWRdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IGdldFN0eWxlJDEobWFwcGVkKTtcbiAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyAmJiBtYXBwZWQuZHJvcHBpbmcgPyBvbk1vdmVFbmQgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgaW5uZXJSZWY6IHNldFJlZixcbiAgICAgIGRyYWdnYWJsZVByb3BzOiB7XG4gICAgICAgICdkYXRhLXJmZC1kcmFnZ2FibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kXG4gICAgICB9LFxuICAgICAgZHJhZ0hhbmRsZVByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlUHJvcHMsIGRyYWdnYWJsZUlkLCBtYXBwZWQsIG9uTW92ZUVuZCwgc2V0UmVmXSk7XG4gIGNvbnN0IHJ1YnJpYyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSwgW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWQsIGRlc2NyaXB0b3IuaWQsIGRlc2NyaXB0b3IuaW5kZXgsIGRlc2NyaXB0b3IudHlwZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4ocHJvdmlkZWQsIG1hcHBlZC5zbmFwc2hvdCwgcnVicmljKSk7XG59O1xuXG52YXIgaXNTdHJpY3RFcXVhbCA9IChhLCBiKSA9PiBhID09PSBiO1xuXG52YXIgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbWJpbmUsXG4gICAgZGVzdGluYXRpb25cbiAgfSA9IHJlc3VsdDtcbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQgPSByZXN1bHQgPT4ge1xuICByZXR1cm4gcmVzdWx0LmNvbWJpbmUgPyByZXN1bHQuY29tYmluZS5kcmFnZ2FibGVJZCA6IG51bGw7XG59O1xuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0ID0gaW1wYWN0ID0+IHtcbiAgcmV0dXJuIGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnID8gaW1wYWN0LmF0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGdldERyYWdnYWJsZVNlbGVjdG9yKCkge1xuICBjb25zdCBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoKHgsIHkpID0+ICh7XG4gICAgeCxcbiAgICB5XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoKG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciA9IG51bGwsIGNvbWJpbmVXaXRoID0gbnVsbCwgZHJvcHBpbmcgPSBudWxsKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgaXNDbG9uZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IEJvb2xlYW4oZHJvcHBpbmcpLFxuICAgIGRyb3BBbmltYXRpb246IGRyb3BwaW5nLFxuICAgIG1vZGUsXG4gICAgZHJhZ2dpbmdPdmVyLFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGxcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZSgob2Zmc2V0LCBtb2RlLCBkaW1lbnNpb24sIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciA9IG51bGwsIGNvbWJpbmVXaXRoID0gbnVsbCwgZm9yY2VTaG91bGRBbmltYXRlID0gbnVsbCkgPT4gKHtcbiAgICBtYXBwZWQ6IHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBkcm9wcGluZzogbnVsbCxcbiAgICAgIGRyYWdnaW5nT3ZlcixcbiAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgbW9kZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGRpbWVuc2lvbixcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIG51bGwpXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQ7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAgIGNvbnN0IGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0KHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBmb3JjZVNob3VsZEFuaW1hdGUgPSBzdGF0ZS5mb3JjZVNob3VsZEFuaW1hdGU7XG4gICAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhtZW1vaXplZE9mZnNldChvZmZzZXQueCwgb2Zmc2V0LnkpLCBzdGF0ZS5tb3ZlbWVudE1vZGUsIGRpbWVuc2lvbiwgb3duUHJvcHMuaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZm9yY2VTaG91bGRBbmltYXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0Nsb25lID0gb3duUHJvcHMuaXNDbG9uZTtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0O1xuICAgICAgY29uc3QgbW9kZSA9IHJlc3VsdC5tb2RlO1xuICAgICAgY29uc3QgZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KHJlc3VsdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBzdGF0ZS5kcm9wRHVyYXRpb247XG4gICAgICBjb25zdCBkcm9wcGluZyA9IHtcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGN1cnZlOiBjdXJ2ZXMuZHJvcCxcbiAgICAgICAgbW92ZVRvOiBzdGF0ZS5uZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICBvcGFjaXR5OiBjb21iaW5lV2l0aCA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogbnVsbCxcbiAgICAgICAgc2NhbGU6IGNvbWJpbmVXaXRoID8gY29tYmluZS5zY2FsZS5kcm9wIDogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcHBlZDoge1xuICAgICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgICAgb2Zmc2V0OiBzdGF0ZS5uZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICBkcm9wcGluZyxcbiAgICAgICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICAgICAgY29tYmluZVdpdGgsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGwsXG4gICAgICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZHJvcHBpbmcpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yID0gbnVsbCkge1xuICByZXR1cm4ge1xuICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgIGlzRHJvcEFuaW1hdGluZzogZmFsc2UsXG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgZHJvcEFuaW1hdGlvbjogbnVsbCxcbiAgICBtb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nT3ZlcjogbnVsbCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgIGNvbWJpbmVXaXRoOiBudWxsXG4gIH07XG59XG5jb25zdCBhdFJlc3QgPSB7XG4gIG1hcHBlZDoge1xuICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgIG9mZnNldDogb3JpZ2luLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudDogdHJ1ZSxcbiAgICBzbmFwc2hvdDogZ2V0U2Vjb25kYXJ5U25hcHNob3QobnVsbClcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFNlY29uZGFyeVNlbGVjdG9yKCkge1xuICBjb25zdCBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoKHgsIHkpID0+ICh7XG4gICAgeCxcbiAgICB5XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoZ2V0U2Vjb25kYXJ5U25hcHNob3QpO1xuICBjb25zdCBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZSgob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yID0gbnVsbCwgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCkgPT4gKHtcbiAgICBtYXBwZWQ6IHtcbiAgICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgICAgb2Zmc2V0LFxuICAgICAgY29tYmluZVRhcmdldEZvcixcbiAgICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQsXG4gICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKVxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBnZXRGYWxsYmFjayA9IGNvbWJpbmVUYXJnZXRGb3IgPT4ge1xuICAgIHJldHVybiBjb21iaW5lVGFyZ2V0Rm9yID8gZ2V0TWVtb2l6ZWRQcm9wcyhvcmlnaW4sIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpIDogbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0UHJvcHMgPSAob3duSWQsIGRyYWdnaW5nSWQsIGltcGFjdCwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICAgIGNvbnN0IHZpc3VhbERpc3BsYWNlbWVudCA9IGltcGFjdC5kaXNwbGFjZWQudmlzaWJsZVtvd25JZF07XG4gICAgY29uc3QgaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCA9IEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5pblZpcnR1YWxMaXN0ICYmIGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbb3duSWRdKTtcbiAgICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmVUYXJnZXRGb3IgPSBjb21iaW5lICYmIGNvbWJpbmUuZHJhZ2dhYmxlSWQgPT09IG93bklkID8gZHJhZ2dpbmdJZCA6IG51bGw7XG4gICAgaWYgKCF2aXN1YWxEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGlmICghaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgICB9XG4gICAgICBpZiAoaW1wYWN0LmRpc3BsYWNlZC5pbnZpc2libGVbb3duSWRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbmdlID0gbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoY2hhbmdlLngsIGNoYW5nZS55KTtcbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYWNlQnkgPSBpbXBhY3QuZGlzcGxhY2VkQnkucG9pbnQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoZGlzcGxhY2VCeS54LCBkaXNwbGFjZUJ5LnkpO1xuICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdmlzdWFsRGlzcGxhY2VtZW50LnNob3VsZEFuaW1hdGUpO1xuICB9O1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgPT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQsIHN0YXRlLmltcGFjdCwgc3RhdGUuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkLCBjb21wbGV0ZWQuaW1wYWN0LCBjb21wbGV0ZWQuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59XG5jb25zdCBtYWtlTWFwU3RhdGVUb1Byb3BzJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGRyYWdnaW5nU2VsZWN0b3IgPSBnZXREcmFnZ2FibGVTZWxlY3RvcigpO1xuICBjb25zdCBzZWNvbmRhcnlTZWxlY3RvciA9IGdldFNlY29uZGFyeVNlbGVjdG9yKCk7XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4gZHJhZ2dpbmdTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IHNlY29uZGFyeVNlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgYXRSZXN0O1xuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzJDEgPSB7XG4gIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkXG59O1xuY29uc3QgQ29ubmVjdGVkRHJhZ2dhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzJDEsIG1hcERpc3BhdGNoVG9Qcm9wcyQxLCBudWxsLCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcmFnZ2FibGUpO1xuXG5mdW5jdGlvbiBQcml2YXRlRHJhZ2dhYmxlKHByb3BzKSB7XG4gIGNvbnN0IGRyb3BwYWJsZUNvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGlzVXNpbmdDbG9uZUZvciA9IGRyb3BwYWJsZUNvbnRleHQuaXNVc2luZ0Nsb25lRm9yO1xuICBpZiAoaXNVc2luZ0Nsb25lRm9yID09PSBwcm9wcy5kcmFnZ2FibGVJZCAmJiAhcHJvcHMuaXNDbG9uZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3RlZERyYWdnYWJsZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gUHVibGljRHJhZ2dhYmxlKHByb3BzKSB7XG4gIGNvbnN0IGlzRW5hYmxlZCA9IHR5cGVvZiBwcm9wcy5pc0RyYWdEaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nID8gIXByb3BzLmlzRHJhZ0Rpc2FibGVkIDogdHJ1ZTtcbiAgY29uc3QgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgPSBCb29sZWFuKHByb3BzLmRpc2FibGVJbnRlcmFjdGl2ZUVsZW1lbnRCbG9ja2luZyk7XG4gIGNvbnN0IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gQm9vbGVhbihwcm9wcy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NcbiAgfSkpO1xufVxuXG5jb25zdCBpc0VxdWFsID0gYmFzZSA9PiB2YWx1ZSA9PiBiYXNlID09PSB2YWx1ZTtcbmNvbnN0IGlzU2Nyb2xsID0gaXNFcXVhbCgnc2Nyb2xsJyk7XG5jb25zdCBpc0F1dG8gPSBpc0VxdWFsKCdhdXRvJyk7XG5jb25zdCBpc1Zpc2libGUgPSBpc0VxdWFsKCd2aXNpYmxlJyk7XG5jb25zdCBpc0VpdGhlciA9IChvdmVyZmxvdywgZm4pID0+IGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgfHwgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbmNvbnN0IGlzQm90aCA9IChvdmVyZmxvdywgZm4pID0+IGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgJiYgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbmNvbnN0IGlzRWxlbWVudFNjcm9sbGFibGUgPSBlbCA9PiB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBvdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IHN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IHN0eWxlLm92ZXJmbG93WVxuICB9O1xuICByZXR1cm4gaXNFaXRoZXIob3ZlcmZsb3csIGlzU2Nyb2xsKSB8fCBpc0VpdGhlcihvdmVyZmxvdywgaXNBdXRvKTtcbn07XG5jb25zdCBpc0JvZHlTY3JvbGxhYmxlID0gKCkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgY29uc3QgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWh0bWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoYm9keSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG4gIGNvbnN0IGh0bWxPdmVyZmxvdyA9IHtcbiAgICBvdmVyZmxvd1g6IGh0bWxTdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBodG1sU3R5bGUub3ZlcmZsb3dZXG4gIH07XG4gIGlmIChpc0JvdGgoaHRtbE92ZXJmbG93LCBpc1Zpc2libGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFdlIGhhdmUgZGV0ZWN0ZWQgdGhhdCB5b3VyIDxib2R5PiBlbGVtZW50IG1pZ2h0IGJlIGEgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICBXZSBoYXZlIGZvdW5kIG5vIHJlbGlhYmxlIHdheSBvZiBkZXRlY3Rpbmcgd2hldGhlciB0aGUgPGJvZHk+IGVsZW1lbnQgaXMgYSBzY3JvbGwgY29udGFpbmVyLlxuICAgIFVuZGVyIG1vc3QgY2lyY3Vtc3RhbmNlcyBhIDxib2R5PiBzY3JvbGwgYmFyIHdpbGwgYmUgb24gdGhlIDxodG1sPiBlbGVtZW50IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpXG5cbiAgICBCZWNhdXNlIHdlIGNhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIDxib2R5PiBpcyBhIHNjcm9sbCBjb250YWluZXIsIGFuZCBnZW5lcmFsbHkgaXQgaXMgbm90IG9uZSxcbiAgICB3ZSB3aWxsIGJlIHRyZWF0aW5nIHRoZSA8Ym9keT4gYXMgKm5vdCogYSBzY3JvbGwgY29udGFpbmVyXG5cbiAgICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvaG93LXdlLWRldGVjdC1zY3JvbGwtY29udGFpbmVycy5tZFxuICBgKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlID0gZWwgPT4ge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBpc0JvZHlTY3JvbGxhYmxlKCkgPyBlbCA6IG51bGw7XG4gIH1cbiAgaWYgKGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoZWwpKSB7XG4gICAgcmV0dXJuIGdldENsb3Nlc3RTY3JvbGxhYmxlKGVsLnBhcmVudEVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMgPSBzY3JvbGxhYmxlID0+IHtcbiAgaWYgKCFzY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFub3RoZXJTY3JvbGxQYXJlbnQgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzY3JvbGxhYmxlLnBhcmVudEVsZW1lbnQpO1xuICBpZiAoIWFub3RoZXJTY3JvbGxQYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgRHJvcHBhYmxlOiB1bnN1cHBvcnRlZCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lciBkZXRlY3RlZC5cbiAgICBBIERyb3BwYWJsZSBjYW4gb25seSBoYXZlIG9uZSBzY3JvbGwgcGFyZW50ICh3aGljaCBjYW4gYmUgaXRzZWxmKVxuICAgIE5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuXG5cbiAgICBXZSBob3BlIHRvIHN1cHBvcnQgbmVzdGVkIHNjcm9sbCBjb250YWluZXJzIHNvb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9pc3N1ZXMvMTMxXG4gIGApIDogdm9pZCAwO1xufTtcblxudmFyIGdldFNjcm9sbCA9IGVsID0+ICh7XG4gIHg6IGVsLnNjcm9sbExlZnQsXG4gIHk6IGVsLnNjcm9sbFRvcFxufSk7XG5cbmNvbnN0IGdldElzRml4ZWQgPSBlbCA9PiB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBnZXRJc0ZpeGVkKGVsLnBhcmVudEVsZW1lbnQpO1xufTtcbnZhciBnZXRFbnYgPSBzdGFydCA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoc3RhcnQpO1xuICBjb25zdCBpc0ZpeGVkT25QYWdlID0gZ2V0SXNGaXhlZChzdGFydCk7XG4gIHJldHVybiB7XG4gICAgY2xvc2VzdFNjcm9sbGFibGUsXG4gICAgaXNGaXhlZE9uUGFnZVxuICB9O1xufTtcblxudmFyIGdldERyb3BwYWJsZURpbWVuc2lvbiA9ICh7XG4gIGRlc2NyaXB0b3IsXG4gIGlzRW5hYmxlZCxcbiAgaXNDb21iaW5lRW5hYmxlZCxcbiAgaXNGaXhlZE9uUGFnZSxcbiAgZGlyZWN0aW9uLFxuICBjbGllbnQsXG4gIHBhZ2UsXG4gIGNsb3Nlc3Rcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSAoKCkgPT4ge1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50XG4gICAgfSA9IGNsb3Nlc3Q7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsU2l6ZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogc2Nyb2xsU2l6ZS5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodDogZnJhbWVDbGllbnQucGFkZGluZ0JveC5oZWlnaHQsXG4gICAgICB3aWR0aDogZnJhbWVDbGllbnQucGFkZGluZ0JveC53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlTWFyZ2luQm94OiBjbG9zZXN0LnBhZ2UubWFyZ2luQm94LFxuICAgICAgZnJhbWVDbGllbnQsXG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IGNsb3Nlc3Quc2hvdWxkQ2xpcFN1YmplY3QsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgaW5pdGlhbDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIGN1cnJlbnQ6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgICAgZGlmZjoge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBheGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2UsXG4gICAgYXhpcyxcbiAgICBpc0VuYWJsZWQsXG4gICAgY2xpZW50LFxuICAgIHBhZ2UsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuY29uc3QgZ2V0Q2xpZW50ID0gKHRhcmdldFJlZiwgY2xvc2VzdFNjcm9sbGFibGUpID0+IHtcbiAgY29uc3QgYmFzZSA9IGdldEJveCh0YXJnZXRSZWYpO1xuICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKHRhcmdldFJlZiAhPT0gY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCB0b3AgPSBiYXNlLnBhZGRpbmdCb3gudG9wIC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsVG9wO1xuICBjb25zdCBsZWZ0ID0gYmFzZS5wYWRkaW5nQm94LmxlZnQgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxMZWZ0O1xuICBjb25zdCBib3R0b20gPSB0b3AgKyBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQ7XG4gIGNvbnN0IHJpZ2h0ID0gbGVmdCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFdpZHRoO1xuICBjb25zdCBwYWRkaW5nQm94ID0ge1xuICAgIHRvcCxcbiAgICByaWdodCxcbiAgICBib3R0b20sXG4gICAgbGVmdFxuICB9O1xuICBjb25zdCBib3JkZXJCb3ggPSBleHBhbmQocGFkZGluZ0JveCwgYmFzZS5ib3JkZXIpO1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVCb3goe1xuICAgIGJvcmRlckJveCxcbiAgICBtYXJnaW46IGJhc2UubWFyZ2luLFxuICAgIGJvcmRlcjogYmFzZS5ib3JkZXIsXG4gICAgcGFkZGluZzogYmFzZS5wYWRkaW5nXG4gIH0pO1xuICByZXR1cm4gY2xpZW50O1xufTtcbnZhciBnZXREaW1lbnNpb24gPSAoe1xuICByZWYsXG4gIGRlc2NyaXB0b3IsXG4gIGVudixcbiAgd2luZG93U2Nyb2xsLFxuICBkaXJlY3Rpb24sXG4gIGlzRHJvcERpc2FibGVkLFxuICBpc0NvbWJpbmVFbmFibGVkLFxuICBzaG91bGRDbGlwU3ViamVjdFxufSkgPT4ge1xuICBjb25zdCBjbG9zZXN0U2Nyb2xsYWJsZSA9IGVudi5jbG9zZXN0U2Nyb2xsYWJsZTtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KHJlZiwgY2xvc2VzdFNjcm9sbGFibGUpO1xuICBjb25zdCBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IGNsb3Nlc3QgPSAoKCkgPT4ge1xuICAgIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZUNsaWVudCA9IGdldEJveChjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IHtcbiAgICAgIHNjcm9sbEhlaWdodDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsV2lkdGg6IGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFdpZHRoXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50OiBmcmFtZUNsaWVudCxcbiAgICAgIHBhZ2U6IHdpdGhTY3JvbGwoZnJhbWVDbGllbnQsIHdpbmRvd1Njcm9sbCksXG4gICAgICBzY3JvbGw6IGdldFNjcm9sbChjbG9zZXN0U2Nyb2xsYWJsZSksXG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3RcbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkaW1lbnNpb24gPSBnZXREcm9wcGFibGVEaW1lbnNpb24oe1xuICAgIGRlc2NyaXB0b3IsXG4gICAgaXNFbmFibGVkOiAhaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpc0ZpeGVkT25QYWdlOiBlbnYuaXNGaXhlZE9uUGFnZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgY2xpZW50LFxuICAgIHBhZ2UsXG4gICAgY2xvc2VzdFxuICB9KTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmNvbnN0IGltbWVkaWF0ZSA9IHtcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG5jb25zdCBkZWxheWVkID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xudmFyIGdldExpc3RlbmVyT3B0aW9ucyA9IG9wdGlvbnMgPT4gb3B0aW9ucy5zaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkgPyBpbW1lZGlhdGUgOiBkZWxheWVkO1xuXG5jb25zdCBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnID0gZHJhZ2dpbmcgPT4gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlIHx8IG51bGw7XG5mdW5jdGlvbiB1c2VEcm9wcGFibGVQdWJsaXNoZXIoYXJncykge1xuICBjb25zdCB3aGlsZURyYWdnaW5nUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhcHBDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcm9wcGFibGUnKTtcbiAgY29uc3Qge1xuICAgIHJlZ2lzdHJ5LFxuICAgIG1hcnNoYWxcbiAgfSA9IGFwcENvbnRleHQ7XG4gIGNvbnN0IHByZXZpb3VzUmVmID0gdXNlUHJldmlvdXMoYXJncyk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaWQ6IGFyZ3MuZHJvcHBhYmxlSWQsXG4gICAgdHlwZTogYXJncy50eXBlLFxuICAgIG1vZGU6IGFyZ3MubW9kZVxuICB9KSwgW2FyZ3MuZHJvcHBhYmxlSWQsIGFyZ3MubW9kZSwgYXJncy50eXBlXSk7XG4gIGNvbnN0IHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYgPSB1c2VSZWYoZGVzY3JpcHRvcik7XG4gIGNvbnN0IG1lbW9pemVkVXBkYXRlU2Nyb2xsID0gdXNlTWVtbygoKSA9PiBtZW1vaXplT25lKCh4LCB5KSA9PiB7XG4gICAgIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHVwZGF0ZSBzY3JvbGwgd2hlbiBkcmFnZ2luZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2Nyb2xsID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGRlc2NyaXB0b3IuaWQsIHNjcm9sbCk7XG4gIH0pLCBbZGVzY3JpcHRvci5pZCwgbWFyc2hhbF0pO1xuICBjb25zdCBnZXRDbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGlmICghZHJhZ2dpbmcgfHwgIWRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgcmV0dXJuIGdldFNjcm9sbChkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVwZGF0ZVNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzY3JvbGwgPSBnZXRDbG9zZXN0U2Nyb2xsKCk7XG4gICAgbWVtb2l6ZWRVcGRhdGVTY3JvbGwoc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgfSwgW2dldENsb3Nlc3RTY3JvbGwsIG1lbW9pemVkVXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IHNjaGVkdWxlU2Nyb2xsVXBkYXRlID0gdXNlTWVtbygoKSA9PiByYWZTY2hkKHVwZGF0ZVNjcm9sbCksIFt1cGRhdGVTY3JvbGxdKTtcbiAgY29uc3Qgb25DbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc2Nyb2xsIG9wdGlvbnMgd2hpbGUgc2Nyb2xsaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBvcHRpb25zID0gZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkpIHtcbiAgICAgIHVwZGF0ZVNjcm9sbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZSgpO1xuICB9LCBbc2NoZWR1bGVTY3JvbGxVcGRhdGUsIHVwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCA9IHVzZUNhbGxiYWNrKCh3aW5kb3dTY3JvbGwsIG9wdGlvbnMpID0+IHtcbiAgICAhIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IGEgZHJvcHBhYmxlIHdoaWxlIGEgZHJhZyBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHByZXZpb3VzID0gcHJldmlvdXNSZWYuY3VycmVudDtcbiAgICBjb25zdCByZWYgPSBwcmV2aW91cy5nZXREcm9wcGFibGVSZWYoKTtcbiAgICAhcmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3Qgd2l0aG91dCBhIGRyb3BwYWJsZSByZWYnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudiA9IGdldEVudihyZWYpO1xuICAgIGNvbnN0IGRyYWdnaW5nID0ge1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHNjcm9sbE9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IGRyYWdnaW5nO1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGdldERpbWVuc2lvbih7XG4gICAgICByZWYsXG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgZW52LFxuICAgICAgd2luZG93U2Nyb2xsLFxuICAgICAgZGlyZWN0aW9uOiBwcmV2aW91cy5kaXJlY3Rpb24sXG4gICAgICBpc0Ryb3BEaXNhYmxlZDogcHJldmlvdXMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkOiBwcmV2aW91cy5pc0NvbWJpbmVFbmFibGVkLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6ICFwcmV2aW91cy5pZ25vcmVDb250YWluZXJDbGlwcGluZ1xuICAgIH0pO1xuICAgIGNvbnN0IHNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG4gICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgIHNjcm9sbGFibGUuc2V0QXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQsIGFwcENvbnRleHQuY29udGV4dElkKTtcbiAgICAgIHNjcm9sbGFibGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzKHNjcm9sbGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9LCBbYXBwQ29udGV4dC5jb250ZXh0SWQsIGRlc2NyaXB0b3IsIG9uQ2xvc2VzdFNjcm9sbCwgcHJldmlvdXNSZWZdKTtcbiAgY29uc3QgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHJlY29sbGVjdCBEcm9wcGFibGUgY2xpZW50IGZvciBEcm9wcGFibGVzIHRoYXQgaGF2ZSBhIHNjcm9sbCBjb250YWluZXInKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXRTY3JvbGwoY2xvc2VzdCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZHJhZ1N0b3BwZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3AgZHJhZyB3aGVuIG5vIGFjdGl2ZSBkcmFnJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVTY3JvbGxVcGRhdGUuY2FuY2VsKCk7XG4gICAgY2xvc2VzdC5yZW1vdmVBdHRyaWJ1dGUoc2Nyb2xsQ29udGFpbmVyLmNvbnRleHRJZCk7XG4gICAgY2xvc2VzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbkNsb3Nlc3RTY3JvbGwsIGdldExpc3RlbmVyT3B0aW9ucyhkcmFnZ2luZy5zY3JvbGxPcHRpb25zKSk7XG4gIH0sIFtvbkNsb3Nlc3RTY3JvbGwsIHNjaGVkdWxlU2Nyb2xsVXBkYXRlXSk7XG4gIGNvbnN0IHNjcm9sbCA9IHVzZUNhbGxiYWNrKGNoYW5nZSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCB3aGVuIHRoZXJlIGlzIG5vIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhY2xvc2VzdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgYSBkcm9wcGFibGUgd2l0aCBubyBjbG9zZXN0IHNjcm9sbGFibGUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNsb3Nlc3Quc2Nyb2xsVG9wICs9IGNoYW5nZS55O1xuICAgIGNsb3Nlc3Quc2Nyb2xsTGVmdCArPSBjaGFuZ2UueDtcbiAgfSwgW10pO1xuICBjb25zdCBjYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsXG4gICAgICBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLFxuICAgICAgZHJhZ1N0b3BwZWQsXG4gICAgICBzY3JvbGxcbiAgICB9O1xuICB9LCBbZHJhZ1N0b3BwZWQsIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nLCBzY3JvbGxdKTtcbiAgY29uc3QgZW50cnkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgdW5pcXVlSWQsXG4gICAgZGVzY3JpcHRvcixcbiAgICBjYWxsYmFja3NcbiAgfSksIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIHVuaXF1ZUlkXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudCA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLnJlZ2lzdGVyKGVudHJ5KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCdVbnN1cHBvcnRlZDogY2hhbmdpbmcgdGhlIGRyb3BwYWJsZUlkIG9yIHR5cGUgb2YgYSBEcm9wcGFibGUgZHVyaW5nIGEgZHJhZycpIDogdm9pZCAwO1xuICAgICAgICBkcmFnU3RvcHBlZCgpO1xuICAgICAgfVxuICAgICAgcmVnaXN0cnkuZHJvcHBhYmxlLnVucmVnaXN0ZXIoZW50cnkpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIGRyYWdTdG9wcGVkLCBlbnRyeSwgbWFyc2hhbCwgcmVnaXN0cnkuZHJvcHBhYmxlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgIWFyZ3MuaXNEcm9wRGlzYWJsZWQpO1xuICB9LCBbYXJncy5pc0Ryb3BEaXNhYmxlZCwgbWFyc2hhbF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJzaGFsLnVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCBhcmdzLmlzQ29tYmluZUVuYWJsZWQpO1xuICB9LCBbYXJncy5pc0NvbWJpbmVFbmFibGVkLCBtYXJzaGFsXSk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgZW1wdHkgPSB7XG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIG1hcmdpbjogbm9TcGFjaW5nXG59O1xuY29uc3QgZ2V0U2l6ZSA9ICh7XG4gIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gIHBsYWNlaG9sZGVyLFxuICBhbmltYXRlXG59KSA9PiB7XG4gIGlmIChpc0FuaW1hdGluZ09wZW5Pbk1vdW50KSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG4gIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LmhlaWdodCxcbiAgICB3aWR0aDogcGxhY2Vob2xkZXIuY2xpZW50LmJvcmRlckJveC53aWR0aCxcbiAgICBtYXJnaW46IHBsYWNlaG9sZGVyLmNsaWVudC5tYXJnaW5cbiAgfTtcbn07XG5jb25zdCBnZXRTdHlsZSA9ICh7XG4gIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gIHBsYWNlaG9sZGVyLFxuICBhbmltYXRlXG59KSA9PiB7XG4gIGNvbnN0IHNpemUgPSBnZXRTaXplKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogcGxhY2Vob2xkZXIuZGlzcGxheSxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgIG1hcmdpblRvcDogc2l6ZS5tYXJnaW4udG9wLFxuICAgIG1hcmdpblJpZ2h0OiBzaXplLm1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW5Cb3R0b206IHNpemUubWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW5MZWZ0OiBzaXplLm1hcmdpbi5sZWZ0LFxuICAgIGZsZXhTaHJpbms6ICcwJyxcbiAgICBmbGV4R3JvdzogJzAnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB0cmFuc2l0aW9uOiBhbmltYXRlICE9PSAnbm9uZScgPyB0cmFuc2l0aW9ucy5wbGFjZWhvbGRlciA6IG51bGxcbiAgfTtcbn07XG5jb25zdCBQbGFjZWhvbGRlciA9IHByb3BzID0+IHtcbiAgY29uc3QgYW5pbWF0ZU9wZW5UaW1lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gIH0sIFtdKTtcbiAgY29uc3Qge1xuICAgIGFuaW1hdGUsXG4gICAgb25UcmFuc2l0aW9uRW5kLFxuICAgIG9uQ2xvc2UsXG4gICAgY29udGV4dElkXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2lzQW5pbWF0aW5nT3Blbk9uTW91bnQsIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnRdID0gdXNlU3RhdGUocHJvcHMuYW5pbWF0ZSA9PT0gJ29wZW4nKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIoKTtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50KGZhbHNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyO1xuICB9LCBbYW5pbWF0ZSwgaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgdHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyXSk7XG4gIGNvbnN0IG9uU2l6ZUNoYW5nZUVuZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQucHJvcGVydHlOYW1lICE9PSAnaGVpZ2h0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvblRyYW5zaXRpb25FbmQoKTtcbiAgICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZSgpO1xuICAgIH1cbiAgfSwgW2FuaW1hdGUsIG9uQ2xvc2UsIG9uVHJhbnNpdGlvbkVuZF0pO1xuICBjb25zdCBzdHlsZSA9IGdldFN0eWxlKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIGFuaW1hdGU6IHByb3BzLmFuaW1hdGUsXG4gICAgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyXG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wcy5wbGFjZWhvbGRlci50YWdOYW1lLCB7XG4gICAgc3R5bGUsXG4gICAgJ2RhdGEtcmZkLXBsYWNlaG9sZGVyLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblNpemVDaGFuZ2VFbmQsXG4gICAgcmVmOiBwcm9wcy5pbm5lclJlZlxuICB9KTtcbn07XG52YXIgUGxhY2Vob2xkZXIkMSA9IFJlYWN0Lm1lbW8oUGxhY2Vob2xkZXIpO1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gcnVuQ2hlY2tzKGFyZ3MsIGNoZWNrcykge1xuICBjaGVja3MuZm9yRWFjaChjaGVjayA9PiBjaGVjayhhcmdzKSk7XG59XG5jb25zdCBzaGFyZWQgPSBbZnVuY3Rpb24gcmVxdWlyZWQoe1xuICBwcm9wc1xufSkge1xuICAhcHJvcHMuZHJvcHBhYmxlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERyb3BwYWJsZSByZXF1aXJlcyBhIGRyb3BwYWJsZUlkIHByb3AnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhKHR5cGVvZiBwcm9wcy5kcm9wcGFibGVJZCA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQSBEcm9wcGFibGUgcmVxdWlyZXMgYSBbc3RyaW5nXSBkcm9wcGFibGVJZC4gUHJvdmlkZWQ6IFske3R5cGVvZiBwcm9wcy5kcm9wcGFibGVJZH1dYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGJvb2xlYW4oe1xuICBwcm9wc1xufSkge1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pc0NvbWJpbmVFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzQ29tYmluZUVuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlnbm9yZUNvbnRhaW5lckNsaXBwaW5nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lnbm9yZUNvbnRhaW5lckNsaXBwaW5nIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZih7XG4gIGdldERyb3BwYWJsZVJlZlxufSkge1xuICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXREcm9wcGFibGVSZWYoKSk7XG59XTtcbmNvbnN0IHN0YW5kYXJkID0gW2Z1bmN0aW9uIHBsYWNlaG9sZGVyKHtcbiAgcHJvcHMsXG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gIGlmICghcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmID0gZ2V0UGxhY2Vob2xkZXJSZWYoKTtcbiAgaWYgKHJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIERyb3BwYWJsZSBzZXR1cCBpc3N1ZSBbZHJvcHBhYmxlSWQ6IFwiJHtwcm9wcy5kcm9wcGFibGVJZH1cIl06XG4gICAgICBEcm9wcGFibGVQcm92aWRlZCA+IHBsYWNlaG9sZGVyIGNvdWxkIG5vdCBiZSBmb3VuZC5cblxuICAgICAgUGxlYXNlIGJlIHN1cmUgdG8gYWRkIHRoZSB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9IFJlYWN0IE5vZGUgYXMgYSBjaGlsZCBvZiB5b3VyIERyb3BwYWJsZS5cbiAgICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2FwaS9kcm9wcGFibGUubWRcbiAgICBgKSA6IHZvaWQgMDtcbn1dO1xuY29uc3QgdmlydHVhbCA9IFtmdW5jdGlvbiBoYXNDbG9uZSh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5yZW5kZXJDbG9uZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgcHJvdmlkZSBhIGNsb25lIHJlbmRlciBmdW5jdGlvbiAocmVuZGVyQ2xvbmUpIGZvciB2aXJ0dWFsIGxpc3RzJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGhhc05vUGxhY2Vob2xkZXIoe1xuICBnZXRQbGFjZWhvbGRlclJlZlxufSkge1xuICAhIWdldFBsYWNlaG9sZGVyUmVmKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB2aXJ0dWFsIGxpc3QgdG8gbm90IGhhdmUgYSBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59XTtcbmZ1bmN0aW9uIHVzZVZhbGlkYXRpb24oYXJncykge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgIHJ1bkNoZWNrcyhhcmdzLCBzaGFyZWQpO1xuICAgIGlmIChhcmdzLnByb3BzLm1vZGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCBzdGFuZGFyZCk7XG4gICAgfVxuICAgIGlmIChhcmdzLnByb3BzLm1vZGUgPT09ICd2aXJ0dWFsJykge1xuICAgICAgcnVuQ2hlY2tzKGFyZ3MsIHZpcnR1YWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNsYXNzIEFuaW1hdGVJbk91dCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLnByb3BzLm9uKSxcbiAgICAgIGRhdGE6IHRoaXMucHJvcHMub24sXG4gICAgICBhbmltYXRlOiB0aGlzLnByb3BzLnNob3VsZEFuaW1hdGUgJiYgdGhpcy5wcm9wcy5vbiA/ICdvcGVuJyA6ICdub25lJ1xuICAgIH07XG4gICAgdGhpcy5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYW5pbWF0ZSAhPT0gJ2Nsb3NlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmICghcHJvcHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHByb3BzLm9uKSxcbiAgICAgICAgZGF0YTogcHJvcHMub24sXG4gICAgICAgIGFuaW1hdGU6ICdub25lJ1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnb3BlbidcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YSxcbiAgICAgICAgYW5pbWF0ZTogJ2Nsb3NlJ1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICBhbmltYXRlOiAnY2xvc2UnLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlZCA9IHtcbiAgICAgIG9uQ2xvc2U6IHRoaXMub25DbG9zZSxcbiAgICAgIGRhdGE6IHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgIGFuaW1hdGU6IHRoaXMuc3RhdGUuYW5pbWF0ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4ocHJvdmlkZWQpO1xuICB9XG59XG5cbmNvbnN0IERyb3BwYWJsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XG4gICFhcHBDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgYXBwIGNvbnRleHQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBkcm9wcGFibGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBtb2RlLFxuICAgIGRpcmVjdGlvbixcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIHNuYXBzaG90LFxuICAgIHVzZUNsb25lLFxuICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsLFxuICAgIGdldENvbnRhaW5lckZvckNsb25lXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZ2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gZHJvcHBhYmxlUmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qgc2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGRyb3BwYWJsZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBwbGFjZWhvbGRlclJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHNldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICB1c2VWYWxpZGF0aW9uKHtcbiAgICBwcm9wcyxcbiAgICBnZXREcm9wcGFibGVSZWYsXG4gICAgZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSk7XG4gIGNvbnN0IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBnZXREcm9wcGFibGVSZWZcbiAgfSk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgKHtcbiAgICBvbkNsb3NlLFxuICAgIGRhdGEsXG4gICAgYW5pbWF0ZVxuICB9KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYWNlaG9sZGVyJDEsIHtcbiAgICBwbGFjZWhvbGRlcjogZGF0YSxcbiAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgIGlubmVyUmVmOiBzZXRQbGFjZWhvbGRlclJlZixcbiAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmRcbiAgfSkpLCBbY29udGV4dElkLCBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCwgcHJvcHMucGxhY2Vob2xkZXIsIHByb3BzLnNob3VsZEFuaW1hdGVQbGFjZWhvbGRlciwgc2V0UGxhY2Vob2xkZXJSZWZdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaW5uZXJSZWY6IHNldERyb3BwYWJsZVJlZixcbiAgICBwbGFjZWhvbGRlcixcbiAgICBkcm9wcGFibGVQcm9wczoge1xuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1pZCc6IGRyb3BwYWJsZUlkLFxuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkXG4gICAgfVxuICB9KSwgW2NvbnRleHRJZCwgZHJvcHBhYmxlSWQsIHBsYWNlaG9sZGVyLCBzZXREcm9wcGFibGVSZWZdKTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gdXNlQ2xvbmUgPyB1c2VDbG9uZS5kcmFnZ2luZy5kcmFnZ2FibGVJZCA6IG51bGw7XG4gIGNvbnN0IGRyb3BwYWJsZUNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBpc1VzaW5nQ2xvbmVGb3JcbiAgfSksIFtkcm9wcGFibGVJZCwgaXNVc2luZ0Nsb25lRm9yLCB0eXBlXSk7XG4gIGZ1bmN0aW9uIGdldENsb25lKCkge1xuICAgIGlmICghdXNlQ2xvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkcmFnZ2luZyxcbiAgICAgIHJlbmRlclxuICAgIH0gPSB1c2VDbG9uZTtcbiAgICBjb25zdCBub2RlID0gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCB7XG4gICAgICBkcmFnZ2FibGVJZDogZHJhZ2dpbmcuZHJhZ2dhYmxlSWQsXG4gICAgICBpbmRleDogZHJhZ2dpbmcuc291cmNlLmluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBmYWxzZSxcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiB0cnVlXG4gICAgfSwgKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCkgPT4gcmVuZGVyKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCwgZHJhZ2dpbmcpKTtcbiAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKG5vZGUsIGdldENvbnRhaW5lckZvckNsb25lKCkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3BwYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZHJvcHBhYmxlQ29udGV4dFxuICB9LCBjaGlsZHJlbihwcm92aWRlZCwgc25hcHNob3QpLCBnZXRDbG9uZSgpKTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICFkb2N1bWVudC5ib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnZG9jdW1lbnQuYm9keSBpcyBub3QgcmVhZHknKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbn1cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgbW9kZTogJ3N0YW5kYXJkJyxcbiAgdHlwZTogJ0RFRkFVTFQnLFxuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGlzRHJvcERpc2FibGVkOiBmYWxzZSxcbiAgaXNDb21iaW5lRW5hYmxlZDogZmFsc2UsXG4gIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nOiBmYWxzZSxcbiAgcmVuZGVyQ2xvbmU6IG51bGwsXG4gIGdldENvbnRhaW5lckZvckNsb25lOiBnZXRCb2R5XG59O1xuY29uc3QgYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyA9IG93blByb3BzID0+IHtcbiAgbGV0IG1lcmdlZFByb3BzID0ge1xuICAgIC4uLm93blByb3BzXG4gIH07XG4gIGxldCBkZWZhdWx0UHJvcEtleTtcbiAgZm9yIChkZWZhdWx0UHJvcEtleSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAob3duUHJvcHNbZGVmYXVsdFByb3BLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZFByb3BzID0ge1xuICAgICAgICAuLi5tZXJnZWRQcm9wcyxcbiAgICAgICAgW2RlZmF1bHRQcm9wS2V5XTogZGVmYXVsdFByb3BzW2RlZmF1bHRQcm9wS2V5XVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZFByb3BzO1xufTtcbmNvbnN0IGlzTWF0Y2hpbmdUeXBlID0gKHR5cGUsIGNyaXRpY2FsKSA9PiB0eXBlID09PSBjcml0aWNhbC5kcm9wcGFibGUudHlwZTtcbmNvbnN0IGdldERyYWdnYWJsZSA9IChjcml0aWNhbCwgZGltZW5zaW9ucykgPT4gZGltZW5zaW9ucy5kcmFnZ2FibGVzW2NyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG5jb25zdCBtYWtlTWFwU3RhdGVUb1Byb3BzID0gKCkgPT4ge1xuICBjb25zdCBpZGxlV2l0aEFuaW1hdGlvbiA9IHtcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IHRydWUsXG4gICAgc25hcHNob3Q6IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IG51bGwsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogZmFsc2VcbiAgICB9LFxuICAgIHVzZUNsb25lOiBudWxsXG4gIH07XG4gIGNvbnN0IGlkbGVXaXRob3V0QW5pbWF0aW9uID0ge1xuICAgIC4uLmlkbGVXaXRoQW5pbWF0aW9uLFxuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2VcbiAgfTtcbiAgY29uc3QgZ2V0RHJhZ2dhYmxlUnVicmljID0gbWVtb2l6ZU9uZShkZXNjcmlwdG9yID0+ICh7XG4gICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZGVzY3JpcHRvci50eXBlLFxuICAgIHNvdXJjZToge1xuICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBnZXRNYXBQcm9wcyA9IG1lbW9pemVPbmUoKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsIGlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0LCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpID0+IHtcbiAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGRyYWdnaW5nLmRlc2NyaXB0b3IuaWQ7XG4gICAgY29uc3QgaXNIb21lID0gZHJhZ2dpbmcuZGVzY3JpcHRvci5kcm9wcGFibGVJZCA9PT0gaWQ7XG4gICAgaWYgKGlzSG9tZSkge1xuICAgICAgY29uc3QgdXNlQ2xvbmUgPSByZW5kZXJDbG9uZSA/IHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXJDbG9uZSxcbiAgICAgICAgZHJhZ2dpbmc6IGdldERyYWdnYWJsZVJ1YnJpYyhkcmFnZ2luZy5kZXNjcmlwdG9yKVxuICAgICAgfSA6IG51bGw7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IHtcbiAgICAgICAgaXNEcmFnZ2luZ092ZXI6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsXG4gICAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIgPyBkcmFnZ2FibGVJZCA6IG51bGwsXG4gICAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IGRyYWdnaW5nLnBsYWNlaG9sZGVyLFxuICAgICAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IGZhbHNlLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgdXNlQ2xvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuICAgIGlmICghaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aEFuaW1hdGlvbjtcbiAgICB9XG4gICAgY29uc3Qgc25hcHNob3QgPSB7XG4gICAgICBpc0RyYWdnaW5nT3ZlcjogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lcixcbiAgICAgIGRyYWdnaW5nT3ZlcldpdGg6IGRyYWdnYWJsZUlkLFxuICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IG51bGwsXG4gICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBwbGFjZWhvbGRlcjogZHJhZ2dpbmcucGxhY2Vob2xkZXIsXG4gICAgICBzaG91bGRBbmltYXRlUGxhY2Vob2xkZXI6IHRydWUsXG4gICAgICBzbmFwc2hvdCxcbiAgICAgIHVzZUNsb25lOiBudWxsXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGNvbnN0IG93blByb3BzV2l0aERlZmF1bHRQcm9wcyA9IGF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMob3duUHJvcHMpO1xuICAgIGNvbnN0IGlkID0gb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLmRyb3BwYWJsZUlkO1xuICAgIGNvbnN0IHR5cGUgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMudHlwZTtcbiAgICBjb25zdCBpc0VuYWJsZWQgPSAhb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLmlzRHJvcERpc2FibGVkO1xuICAgIGNvbnN0IHJlbmRlckNsb25lID0gb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzLnJlbmRlckNsb25lO1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgY29uc3QgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcbiAgICAgIGNvbnN0IGlzRHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSA9PT0gaWQ7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXIsIGlzRHJhZ2dpbmdPdmVyLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2luZyA9IGdldERyYWdnYWJsZShjb21wbGV0ZWQuY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChjb21wbGV0ZWQucmVzdWx0KSA9PT0gaWQsIHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZCwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScgJiYgc3RhdGUuY29tcGxldGVkICYmICFzdGF0ZS5zaG91bGRGbHVzaCkge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3Zlcihjb21wbGV0ZWQuaW1wYWN0KSA9PT0gaWQ7XG4gICAgICBjb25zdCB3YXNDb21iaW5pbmcgPSBCb29sZWFuKGNvbXBsZXRlZC5pbXBhY3QuYXQgJiYgY29tcGxldGVkLmltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpO1xuICAgICAgY29uc3QgaXNIb21lID0gY29tcGxldGVkLmNyaXRpY2FsLmRyb3BwYWJsZS5pZCA9PT0gaWQ7XG4gICAgICBpZiAod2FzT3Zlcikge1xuICAgICAgICByZXR1cm4gd2FzQ29tYmluaW5nID8gaWRsZVdpdGhBbmltYXRpb24gOiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0hvbWUpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSB7XG4gIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsOiB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbFxufTtcbmNvbnN0IENvbm5lY3RlZERyb3BwYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCAoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzKG93blByb3BzKSxcbiAgICAuLi5zdGF0ZVByb3BzLFxuICAgIC4uLmRpc3BhdGNoUHJvcHNcbiAgfTtcbn0sIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyb3BwYWJsZSk7XG5cbmV4cG9ydCB7IERyYWdEcm9wQ29udGV4dCwgUHVibGljRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgQ29ubmVjdGVkRHJvcHBhYmxlIGFzIERyb3BwYWJsZSwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZU1vdXNlU2Vuc29yLCB1c2VUb3VjaFNlbnNvciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;